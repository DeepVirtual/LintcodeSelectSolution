indwww.we# -*- coding: utf-8 -*-
"""
Created on Sun Apr 29 17:56:19 2018

@author: cz
"""

#1. A + B Problem
class Solution:
    """
    @param a: An integer
    @param b: An integer
    @return: The sum of a and b 
    """
    #https://stackoverflow.com/questions/30696484/a-b-without-arithmetic-operators-python-vs-c
    #https://www.jiuzhang.com/solution/a-b-problem/#tag-other-lang-python
    
    def aplusb(self, a, b):
        # write your code here
        int_max=0x7FFFFFFF
        
        while b!=0:
            a,b=(a^b) & int_max,(a&b)<<1
        return a
a=100
b=-100           
if __name__ == "__main__":
    print(Solution().aplusb(a, b))            


#2. Trailing Zeros 
class Solution:
    """
    @param: n: An integer
    @return: An integer, denote the number of trailing zeros in n!
    """
    def trailingZeros(self, n):
        # write your code here, try to do it without arithmetic operators.
        
        
        def cal0(n):
            f=5
            ans=0
            while f<n:
              ans+=n//f
              f*=5
            return ans
        
        return  cal0(n) if n>4 else 0
        
#3. Digit Counts   
class Solution:
    """
    @param: : An integer
    @param: : An integer
    @return: An integer denote the count of digit k in 1..n
    """
    def digitCounts(self, k, n):
        # write your code here
        assert(n>=0 and  0<=k<=n )
        ans=0
        
        for x in range(n+1):
            while True:
                
                if x%10==k:
                    ans+=1
                x=x//10
                if x==0:
                    break
        return ans
n = 12
k = 0
if __name__ == "__main__":
    print(Solution().digitCounts( k, n))     
                
#4. Ugly Number II              
class Solution:
    """
    @param n: An integer
    @return: the nth prime number as description.
    """
    def nthUglyNumber(self, n):
        # write your code here

        import heapq
        heap=[1]
        
        for i in range(1,n+1):
            value= heapq.heappop(heap)
            heapq.heappush(heap,value*2)
            heapq.heappush(heap,value*3)
            heapq.heappush(heap,value*5)
            while  value==heap[0]:
                   heapq.heappop(heap)
        return value
        
n=9
if __name__ == "__main__":
    print(Solution().nthUglyNumber(n)) 
        
        
#5. Kth Largest Element         
class Solution:
    # @param k & A a integer and an array
    # @return ans a integer
    
    def kthLargestElement(self, k, A):
        n=len(A)
        k-=1
        def partition(s,e):
            p,q=s+1,e
            
            while p<=q:
                if A[p]>A[s]:
                    p+=1
                else:
                    A[p],A[q]=A[q],A[p]
                    q-=1
            A[s],A[q]=A[q], A[s]
            m=q
            
            if m==k:
                return A[m]
            elif m<k:
                return partition(m+1,e)
            else:
                return partition(s,m-1)
        return partition(0,n-1)
A=[9,3,2,4,8]
k=3                    
if __name__ == "__main__":
    print(Solution().kthLargestElement( k, A))                    
                
#6. Merge Two Sorted Arrays 
class Solution:
    """
    @param A: sorted integer array A
    @param B: sorted integer array B
    @return: A new sorted integer array
    """
    def mergeSortedArray(self, A, B):
        # write your code here
        
        i=0
        j=0
        l=[]

        while i<len(A)  and j < len(B):
           
            if A[i]<B[j]:
               l.append(A[i])
               i+=1
            else:
               l.append(B[j])
               j+=1
        if i<len(A):
          l+=A[i:]
        if j<len(B):
          l+=B[j:]
        return l

A=[1,2,3,4]

B=[2,4,5,6]
if __name__ == "__main__":
    print(Solution().mergeSortedArray( A, B))               
          
#7. Serialize and Deserialize Binary Tree               
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""

 
 

class Solution:
    """
    @param root: An object of TreeNode, denote the root of the binary tree.
    This method will be invoked first, you should design your own algorithm 
    to serialize a binary tree which denote by a root node to a string which
    can be easily deserialized by your own "deserialize" method later.
    """
    def serialize(self, root):
        # write your code here
        from collections import deque
        string=''
        queue=deque([root])
        while queue:
              cur=queue.popleft()
              if cur:
                 string+=','+str(cur.val)
                 queue.append(cur.left)
                 queue.append(cur.right)
              else:
                 string+=',None'
        return string
            
   

    """
    @param data: A string serialized by your serialize method.
    This method will be invoked second, the argument data is what exactly
    you serialized at method "serialize", that means the data is not given by
    system, it's given by your own serialize method. So the format of data is
    designed by yourself, and deserialize it here as you serialize it in 
    "serialize" method.
    """
    def deserialize(self, data):
        # write your code here
        from collections import deque
        data=data.split(',')
        data=deque(data)
        _,val=data.popleft(),data.popleft()
        root=TreeNode(val) if val!='None' else None
        queue=deque([root])
        
        while queue:
              node=queue.popleft()
              if node:
                 left,right=data.popleft(),data.popleft()
                 leftnode=None  if left=='None' else TreeNode(int(left))
                 rightnode=None  if right=='None' else TreeNode(int(right)) 
                 node.left=leftnode
                 node.right=rightnode
                 queue.append(node.left)
                 queue.append(node.right)
        return root

#root=TreeNode(3)
#root.left=TreeNode(9)
#root.right=TreeNode(20)
#root.right.left=TreeNode(15)
#root.right.right=TreeNode(7)

#
#An example of testdata: Binary tree {3,9,20,#,#,15,7}, denote the following structure:
#
#  3
# / \
#9  20
#  /  \
# 15   7        
if __name__ == "__main__":
    print(Solution().serialize( root))  


    
#8. Rotate String        
class Solution:
    """
    @param str: An array of char
    @param offset: An integer
    @return: nothing
    """
    def rotateString(self, str, offset):
        # write your code here 
        #work in python 2
        n=len(str)
        if n>0:
            offset=offset%n
        
        M=offset
        str[:-M]=str[:-M][::-1]
        str[-M:]=str[-M:][::-1]
        str[:]=str[:][::-1]
        #print(str)
            
            
str="abcdefg"
offset=2
if __name__ == "__main__":
    print(Solution().rotateString(str, offset))        
        
#9. Fizz Buzz        
class Solution:
    """
    @param n: An integer
    @return: A list of strings.
    """
    def fizzBuzz(self, n):
        # write your code here

        ans=[]
        for i in range(1,n+1):
            if i%3==0 and i%15!=0:
                ans.append("fizz")
            elif i%5==0 and i%15!=0:
                ans.append("buzz")
            elif i%15==0 :
                ans.append("fizz buzz")
            else:
                ans.append(str(i))
        return ans
n=15
if __name__ == "__main__":
    print(Solution().fizzBuzz( n)) 

                  
#11. Search Range in Binary Search Tree                 
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""

class Solution:
    """
    @param root: param root: The root of the binary search tree
    @param k1: An integer
    @param k2: An integer
    @return: return: Return all keys that k1<=key<=k2 in ascending order
    """
    def searchRange(self, root, k1, k2):
        # write your code here
        res=[]
        
        def searchRange(node,k1,k2,res):
            if not node:
                return 
            if node.val>k2:
               searchRange(node.left,k1,k2,res)
            elif node.val<k1:
               searchRange(node.right,k1,k2,res)
            else:
                res.append(node.val)
                searchRange(node.left,k1,k2,res)
                searchRange(node.right,k1,k2,res)
        searchRange(root,k1,k2,res)
        return sorted(res)
                
#12. Min Stack            
class MinStack:
    
    def __init__(self):
        # do intialization if necessary
        self.stack=[]
        self.minstack=[]
    """
    @param: number: An integer
    @return: nothing
    """
    def push(self, number):
        # write your code here
        self.stack.append(number)
        if not self.minstack or number <= self.minstack[-1]:
             self.minstack.append(number)

    """
    @return: An integer
    """
    def pop(self):
        # write your code here
        
        if self.stack[-1]==self.minstack[-1]:
            self.minstack.pop()
        return self.stack.pop()

    """
    @return: An integer
    """
    def min(self):
        # write your code here
        return self.minstack[-1]
        
#13. Implement strStr()        
class Solution:
    """
    @param: source: source string to be scanned.
    @param: target: target string containing the sequence of characters to match
    @return: a index to the first occurrence of target in source, or -1  if target is not part of source.
    """
    def strStr(self, source, target):
        # write your code here 
        if target is None:
            return -1
        if not target:
            return 0
        if not source or not target:
            return -1
        
        ns=len(source)
        nt=len(target)
        if ns< nt :
            return -1
        for i in range(ns-nt+1):
            
            j=0
            tempi=i
            while j<nt and target[j]==source[tempi]:
            
                j+=1
                tempi+=1
                print(j,tempi)
            if j==nt:
                return i
        return -1
source = "source" 
target = "target" 
source = "abcdabcdefg" 
target = "bcd"               
if __name__ == "__main__":
    print(Solution().strStr( source, target))                
            
#14. First Position of Target        
class Solution:
    """
    @param nums: The integer array.
    @param target: Target to find.
    @return: The first position of target. Position starts from 0.
    """
    def binarySearch(self, nums, target):
        # write your code here
        n=len(nums)
        
        left=0
        right=n-1
        
        while left +1<right:
            mid=(left+right)//2
            if nums[mid]>=target:
                right=mid
            else:
                left=mid
        if nums[left]==target:
            return left
        elif nums[right]==target:
            return right
        else:
            return -1
            
nums=[1, 2, 3, 3, 4, 5, 10] 
target=3               
if __name__ == "__main__":
    print(Solution(). binarySearch( nums, target))            
                
                
#15. Permutations            
class Solution:
    """
    @param: nums: A list of integers.
    @return: A list of permutations.
    """
    def permute(self, nums):
        # write your code here
        res=[]
        
        def helper(res,path,nums):
            if not nums:
                res.append(path)
                return 
            for i in range(len(nums)):
                helper(res,path+[nums[i]],nums[:i]+nums[i+1:])
        
        if nums==[]:
            return [[]]
        if nums=='':
            return []
        helper(res,[],nums)
        return res
nums = [1,2,3]
if __name__ == "__main__":
    print(Solution().permute( nums))   

#16. Permutations II
class Solution:
    """
    @param: :  A list of integers
    @return: A list of unique permutations
    """

    def permuteUnique(self, nums):
        # write your code here
        res=[]
        
        def helper(res,path,nums):
            if not nums:
                res.append(path)
                return 
            for i in range(len(nums)):
                if i>0 and nums[i]==nums[i-1]:
                    continue
                helper(res,path+[nums[i]],nums[:i]+nums[i+1:])
        
        if nums==[]:
            return [[]]
        if nums is None:
            return []
        helper(res,[],sorted(nums))
        return res
nums = [1,2,2]
if __name__ == "__main__":
    print(Solution().permuteUnique( nums))   
        
#17. Subsets        
class Solution:
    """
    @param nums: A set of numbers
    @return: A list of lists
    """
    def subsets(self, nums):
        # write your code here
        
        def dfs(res,path,nums):
            res.append(path)
            if not nums:
                return 
            for i in range(len(nums)):
                dfs(res,path+[nums[i]],nums[i+1:])
        res=[]
        dfs(res,[],sorted(nums))
        return res
nums = [1,2,3]
if __name__ == "__main__":
    print(Solution().subsets( nums))
            
#18. Subsets II        
class Solution:
    """
    @param nums: A set of numbers.
    @return: A list of lists. All valid subsets.
    """
    def subsetsWithDup(self, nums):
        # write your code here
        def dfs(res,path,nums):
            res.append(path)
            if not nums:
                return 
            for i in range(len(nums)):
                if i>0 and nums[i-1]==nums[i]:
                    continue
                dfs(res,path+[nums[i]],nums[i+1:])
        res=[]
        dfs(res,[],sorted(nums))
        return res
nums = [1,2,2]
if __name__ == "__main__":
    print(Solution().subsetsWithDup( nums)) 

#20. Dices Sum       
class Solution:
    # @param {int} n an integer
    # @return {tuple[]} a list of tuple(sum, probability)
    def dicesSum(self, n):
        # Write your code here
#https://zhengyang2015.gitbooks.io/lintcode/dices_sum_20.html
        
        dp=[[0 for y in range(6*n+1)]  for x in range(n+1)]
        
        for i in range(1,7):
            dp[1][i]=1/6
        
        for i in range(2,n+1):
            for j in range(i,6*n+1):
                for k in range(1,7):
                    if j>k:
                        dp[i][j]+=dp[i-1][j-k]
                
                dp[i][j]/=6.0
        res=[]
        
        for i in range(n,6*n+1):
            res.append([i, dp[n][i]])
        return res
n=2
if __name__ == "__main__":
    print(Solution().dicesSum( n)) 
        
#Flatten List
class Solution(object):

    # @param nestedList a list, each element in the list 
    # can be a list or integer, for example [1,2,[1,2]]
    # @return {int[]} a list of integer
    def flatten(self, nestedList):
        # Write your code here
        
        def flat(ele,res):
            if isinstance(ele,int):
                res.append(ele)
                
            else:
                for e in ele:
                    res=flat(e,res)
            return res
        res=[]
        
        return flat(nestedList,res)
nestedList=[4,[3,[2,[1]]]]
if __name__ == "__main__":
    print(Solution().flatten(nestedList)) 

#24. LFU Cache     
class LFUCache:
    """
    @param: capacity: An integer
    """
    def __init__(self, capacity):
        # do intialization if necessary
        self.capacity=capacity
        self.map={}   #  key value dictionary
        self.freq_time={} # key to freq time dictionary
        self.prior_queue=[] #  (freq,time,key)
        self.time=0
        self.update=set()
        

    """
    @param: key: An integer
    @param: value: An integer
    @return: nothing
    """
    def set(self, key, value):
        # write your code here

        import heapq
        self.time+=1
        
        if not key in self.map:
            
           if self.capacity <=len(self.map):
        
                 while self.prior_queue and self.prior_queue[0][2] in self.update:
                       _,_,k=heapq.heappop(self.prior_queue)
                       f,t=self.freq_time[k]
                       heapq.heappush(self.prior_queue,(f,t,k))
                       self.update.remove(k)
                 _,_,k=heapq.heappop(self.prior_queue)
                 self.freq_time.pop(k)
                 self.map.pop(k)
                
           self.freq_time[key] =(0,self.time)
           heapq.heappush(self.prior_queue,(0,self.time,key))
           
        else:
            f,_=self.freq_time[key]
            self.freq_time[key]=(f+1,self.time)
            self.update.add(key)
        
        self.map[key]=value
            
 
    
    def get(self, key):
        # write your code here 
        """
         @param: key: An integer
         @return: An integer
        """
        self.time+=1
        if self.capacity<=0:
            return 
        
        if key in self.map:
            f,_=self.freq_time[key]
            self.freq_time[key]=(f+1,self.time)
            self.update.add(key)
            return self.map[key]
        return -1
#28. Search a 2D Matrix            
class Solution:
    """
    @param matrix: matrix, a list of lists of integers
    @param target: An integer
    @return: a boolean, indicate whether matrix contains target
    """
    def searchMatrix(self, matrix, target):
        # write your code here
        if not matrix:
            return False
        array=[]
        for row in matrix:
            array+=row
        l=0
        r=len(array)-1
        
        while l<r:
            
            mid=(l+r)//2
            
            if array[mid]==target:
                return True
            elif array[mid]>target:
                r=mid-1
            else:
                l=mid+1
        return array[l]==target
matrix=[
    [1, 3, 5, 7],
    [10, 11, 16, 20],
    [23, 30, 34, 50]
]   

target=3
if __name__ == "__main__":
    print(Solution().searchMatrix(matrix, target))     
        
#29. Interleaving String        
class Solution:
    """
    @param s1: A string
    @param s2: A string
    @param s3: A string
    @return: Determine whether s3 is formed by interleaving of s1 and s2
    """
    def isInterleave(self, s1, s2, s3):
        # write your code here
        if not s1 and not s2 and not s3:
            return True
        
        
        
        n1=len(s1)
        n2=len(s2)
        n3=len(s3)
        
        if n1+n2!=n3:
            return False
        
        dp=[[False] * (n2+1)   for _ in range(n1+1)]
        
        dp[0][0]=True
        
        for i in range(1,n1+1):
            dp[i][0]= ( dp[i-1][0] and s1[i-1]==s3[i-1])
        for j in range(1,n2+1):
            dp[0][j]= ( dp[0][j-1] and s2[j-1]==s3[j-1])
            
            
        for i in range(1,n1+1):
           for j in range(1,n2+1):
               
               if (dp[i-1][j] and s1[i-1]==s3[i+j-1])  or (dp[i][j-1] and s2[j-1]==s3[i+j-1]):
                   dp[i][j]=True
        return dp[n1][n2]
s1 = "aabcc"
s2 = "dbbca"
s3 = "aadbbcbcac"
s3 = "aadbbbaccc"
if __name__ == "__main__":
    print(Solution().isInterleave( s1, s2, s3))          
        
#30. Insert Interval        
"""
Definition of Interval.
class Interval(object):
    def __init__(self, start, end):
        self.start = start
        self.end = end
"""

class Solution:
    """
    @param intervals: Sorted interval list.
    @param newInterval: new interval.
    @return: A new interval list.
    """
    def insert(self, intervals, newInterval):
        # write your code here
        
        insert_pos=0
        res=[]
        for interval in intervals:
            if newInterval.start>interval.end:
                res.append(interval)
                insert_pos+=1
            elif newInterval.end<interval.start:
                res.append(interval)
            else:
                newInterval.end=max(newInterval.end,interval.end)
                newInterval.start=min(newInterval.start,interval.start)
        res.insert(insert_pos,newInterval)
        return res
intervals=[]
newInterval=Interval(5,7)
if __name__ == "__main__":
    print(Solution().insert( intervals, newInterval))
                
#31. Partition Array  
class Solution:
    """
    @param nums: The integer array you should partition
    @param k: An integer
    @return: The index after partition
    """
    def partitionArray(self, nums, k):
        # write your code here


       l=0
       r=len(nums)-1
       
       while l<=r:
           
             while l<=r and nums[l] < k:
                 l+=1
             
             while l<=r and nums[r] >= k:
                 r-=1
             
             if l<r:
                 nums[l], nums[r]=nums[r],nums[l]
       return [nums,l,r]
nums=[7,7,9,8,6,6,8,7,9,8,6,6]
k=7
if __name__ == "__main__":
    print(Solution().partitionArray( nums, k))

#32. Minimum Window Substring 
class Solution:
    """
    @param source : A string
    @param target: A string
    @return: A string denote the minimum window, return "" if there is no such a string
    """
    def minWindow(self, source , target):
        # write your code here
        
        from collections import Counter
        need=Counter(target)
        missing=len(target)
        
        
        I=0
        i=0
        J=0
        for j,c in enumerate(source,1):
            if c in need and need[c]>0:
                
                missing-=1
            if c in need:
                need[c]-=1
            
            if not missing:
                while i<j and (source[i] not in need or need[source[i]]<0):
                    if source[i] in need:
                         need[source[i]]+=1
                    i+=1
                if not J or    J-I > j-i:
                    J=j
                    I=i
        return source[I:J]
 
source = "ADOBECODEBANC"
target = "ABC"     
if __name__ == "__main__":
    print(Solution().minWindow( source , target))   
            
#33. N-Queens            
class Solution:
    """
    @param: n: The number of queens
    @return: All distinct solutions
    """
    def solveNQueens(self, n):
        # write your code here
        
        import copy
        
        board=[['.' for _ in range(n)]  for _ in range(n)] 
        emptycol=[True for _ in range(n)]
        empty45=[True for _ in range(2*n-1)]
        empty135=[True for _ in range(2*n-1)]
        
        res=[]
        def backtrack(row):
            if row==n:
                res.append([''.join(row) for row in board])
                
            for col in range(n):
                    if emptycol[col]  and empty45[row-col+n-1]  and  empty135[row+col]:
                       board[row][col]='Q'
                       emptycol[col]=False
                       empty45[row-col+n-1]=False
                       empty135[row+col]=False
                       backtrack(row+1)
                       emptycol[col]=True
                       empty45[row-col+n-1]=True
                       empty135[row+col]=True
                       board[row][col]='.'
        backtrack(0)
        return res
n=4
if __name__ == "__main__":
    print(Solution().solveNQueens( n)) 
                       
#34. N-Queens II                
class Solution:
    """
    @param n: The number of queens.
    @return: The total number of distinct solutions.
    """
    def totalNQueens(self, n):
        # write your code here
        self.col={}
        self.n=n
        self.res=0
        self.search(0)
        return self.res
    def attack(self,row,col):
        for c,r in self.col.items():
            if c-r==col-row or c+r==col+row:
                return True
        return False
    
    def search(self,row):
        if row==self.n:
            self.res+=1
            return 
        
        for col in range(self.n):
            if col in self.col:
                continue
            if self.attack(row,col):
                continue
            self.col[col]=row
            self.search(row+1)
            del self.col[col]
    
            
            
n=4
if __name__ == "__main__":
    print(Solution().totalNQueens( n))         
        
#35. Reverse Linked List        
"""
Definition of ListNode

class ListNode(object):

    def __init__(self, val, next=None):
        self.val = val
        self.next = next
"""

class Solution:
    """
    @param head: n
    @return: The new head of reversed linked list.
    """
    def reverse(self, head):
        # write your code here
          
        cur=head
        prev=None
        while cur:
              temp=cur.next
              cur.next=prev
              prev=cur
              cur=temp
        return prev
        
        
#36. Reverse Linked List II   
"""
Definition of ListNode
class ListNode(object):
    def __init__(self, val, next=None):
        self.val = val
        self.next = next
"""

class Solution:
    """
    @param head: ListNode head is the head of the linked list 
    @param m: An integer
    @param n: An integer
    @return: The head of the reversed ListNode
    """
    def reverseBetween(self, head, m, n):
        # write your code here
        def reverse(head):
            if not head:
                return head
            prev=None
            cur=head
            while cur:
                temp=cur.next
                cur.next=prev
                prev=cur
                cur=temp
            return prev
        
        def findkth(head,k):
            cur=head
            for _ in range(k):
                if not cur:
                    return cur
                cur=cur.next
            return cur
        dummy= ListNode(-1,head)
        mth_prev=findkth(dummy,m-1)
        mth=mth_prev.next
        nth=findkth(dummy,n)
        nth_next=nth.next
        nth.next=None
        
        
        mth_prev.next=reverse(mth)
        mth.next=nth_next
        
        return dummy.next
        
#https://leetcode.com/problems/reverse-linked-list-ii/discuss/30666/Simple-Java-solution-with-clear-explanation?page=2        
#37. Reverse 3-digit Integer
class Solution:
    """
    @param number: A 3-digit number.
    @return: Reversed number.
    """
    def reverseInteger(self, number):
        # write your code here
        return int(str(number)[::-1])
#38. Search a 2D Matrix II
class Solution:
    """
    @param matrix: A list of lists of integers
    @param target: An integer you want to search in matrix
    @return: An integer indicate the total occurrence of target in the given matrix
    """
    def searchMatrix(self, matrix, target):
        # write your code here
        if not matrix:
            return 0
        def search(row,col,target):
            if matrix[row][col]==target:
                self.res+=1
                return 
            if matrix[row][col]<target:
                for (r,c) in ((row+1,col),(row,col+1)):
                    if 0<=r<len(matrix)  and 0<=c<len(matrix[0])  and (r,c) not in self.visited:
                       self.visited.add((r,c)) 
                       search(r,c,target)
            
        self.res=0
        self.visited=set((0,0))
        search(0,0,target)  
        return self.res
target=3        
matrix=[
  [1, 3, 5, 7],
  [2, 4, 7, 8],
  [3, 5, 9, 10]
]   
matrix=[[62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80],
        [63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81],
        [64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82],
        [65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83],
        [66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84],
        [67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85]]
target=81     
if __name__ == "__main__":
    print(Solution().searchMatrix(matrix, target))         
        
#39. Recover Rotated Sorted Array        
class Solution:
    """
    @param nums: An integer array
    @return: nothing
    """
    def recoverRotatedSortedArray(self, nums):
        # write your code here
        i=1
        minI=0
        while i<len(nums) :
            
            if nums[i]<nums[i-1]:
                minI=i
                break
            i+=1
        nums[:minI]=nums[:minI][::-1]
        nums[minI:]=nums[minI:][::-1]
        nums[:]=nums[::-1]
        return nums
nums=    [4, 5, 1, 2, 3]
if __name__ == "__main__":
    print(Solution().recoverRotatedSortedArray( nums))   

#40. Implement Queue by Two Stacks
class MyQueue:
    
    def __init__(self):
        # do intialization if necessary
        self.stack1=[]
        self.stack2=[]

    """
    @param: element: An integer
    @return: nothing
    """
    def push(self, element):
        # write your code here
        self.stack1.append(element)

    """
    @return: An integer
    """
    def pop(self):
        # write your code here
        self.top()
        return self.stack2.pop()

    """
    @return: An integer
    """
    def top(self):
        # write your code here
        if not self.stack2:
            while self.stack1:
                self.stack2.append(self.stack1.pop())
        return self.stack2[-1]
#41. Maximum Subarray 
class Solution:
    """
    @param nums: A list of integers
    @return: A integer indicate the sum of max subarray
    """
    def maxSubArray(self, nums):
        # write your code here
        
        dp=[0]*len(nums)
        
        res=nums[0]
        dp[0]=nums[0]
        
        for i in range(1,len(nums)):
            if dp[i-1]<=0:
                dp[i]=nums[i]
            else:
                dp[i]=dp[i-1]+nums[i]
            res=max(dp[i],res)
        return res
nums= [-2,2,-3,4,-1,2,1,-5,3]
if __name__ == "__main__":
    print(Solution().maxSubArray(nums))   
               
#42. Maximum Subarray II        
class Solution:
    """
    @param: nums: A list of integers
    @return: An integer denotes the sum of max two non-overlapping subarrays
    """
    def maxTwoSubArrays(self, nums):
        # write your code here
        
        n=len(nums)
        
        left=[0]*n
        right=[0]*n
        
        left[0]=nums[0]
        max_end_here=nums[0]
        max_sofar=nums[0]
        
        for i in range(1,n):
            max_end_here=max(nums[i],max_end_here+nums[i])
            max_sofar=max(max_sofar,max_end_here)
            left[i]=max_sofar
        
        right[n-1]=nums[n-1]
        max_end_here=nums[n-1]
        max_sofar=nums[n-1]
        
        for i in range(n-2,-1,-1):
            max_end_here=max(nums[i],max_end_here+nums[i])
            max_sofar=max(max_sofar,max_end_here)
            right[i]=max_sofar
            
        res=float('-inf')
        
        for i in range(n-1):
            res=max(res,left[i]+right[i+1])
        return res
nums= [1, 3, -1, 2, -1, 2]
if __name__ == "__main__":
    print(Solution().maxTwoSubArrays(nums))   
        
#43. Maximum Subarray III
class Solution:
    """
    @param nums: A list of integers
    @param k: An integer denote to find k non-overlapping subarrays
    @return: An integer denote the sum of max k non-overlapping subarrays
    """
    def maxSubArray(self, nums, k):
        # write your code here
        n=len(nums)
        if not nums or k<=0 or k>n:
            return -1
        
        localMax=[[0 for _ in range(k+1)] for _ in range(n+1)]
        globalMax=[[0 for _ in range(k+1)] for _ in range(n+1)]
        
        for j in range(1,k+1):
            localMax[j-1][j]=float('-inf')
            for i in range(j,n+1):
                localMax[i][j]=max(globalMax[i-1][j-1],localMax[i-1][j])+nums[i-1]
                if i==j:
                    globalMax[i][j]=localMax[i][j]
                else:
                    globalMax[i][j]=max(globalMax[i-1][j],localMax[i][j])
        return globalMax[n][k]
nums= [-1,4,-2,3,-2,3]
k=2
if __name__ == "__main__":
    print(Solution().maxSubArray(nums, k))                    
                    
#44. Minimum Subarray    
class Solution:
    """
    @param: nums: a list of integers
    @return: A integer indicate the sum of minimum subarray
    """
    def minSubArray(self, nums):
        # write your code here        
        
        n=len(nums)
        dp=[0]*n
        res=nums[0]
        dp[0]=nums[0]
        
        for i in range(1,n):
            dp[i]=min(nums[i],nums[i]+dp[i-1])
            res=min(res,dp[i])
        return res
nums= [1, -1, -2, 1]

if __name__ == "__main__":
    print(Solution().minSubArray( nums))   

       
#45. Maximum Subarray Difference
class Solution:
    """
    @param nums: A list of integers
    @return: An integer indicate the value of maximum difference between two substrings
    """
    def maxDiffSubArrays(self, nums):
        # write your code here
        n=len(nums)
        
        leftmin_so_far=[0]*n
        leftmax_so_far=[0]*n
        rightmin_so_far=[0]*n
        rightmax_so_far=[0]*n
        
                     
        leftmin_so_far[0]=nums[0]
        leftmax_so_far[0]=nums[0]
        
        min_end_here=nums[0]
        max_end_here=nums[0]
        
        for i in range(1,n):
            min_end_here=min(nums[i],min_end_here+nums[i])
            leftmin_so_far[i]=min(min_end_here,leftmin_so_far[i-1])
            
            max_end_here=max(nums[i],max_end_here+nums[i])
            leftmax_so_far[i]=max(max_end_here,leftmax_so_far[i-1])
            
      
        rightmin_so_far[n-1]=nums[n-1]
        rightmax_so_far[n-1]=nums[n-1]
        min_end_here=nums[n-1]
        max_end_here=nums[n-1]
        
        for i in range(n-2,-1,-1):
            min_end_here=min(nums[i],min_end_here+nums[i])
            rightmin_so_far[i]=min(min_end_here,rightmin_so_far[i+1])
            
            max_end_here=max(nums[i],max_end_here+nums[i])
            rightmax_so_far[i]=max(max_end_here,rightmax_so_far[i+1])
        
        res=float('-inf')
        
        for i in range(n-1):
            res=max(abs(leftmax_so_far[i]-rightmin_so_far[i+1]),res)
            res=max(abs(leftmin_so_far[i]-rightmax_so_far[i+1]),res)
            
        print('leftmax_so_far',leftmax_so_far)    
        print('rightmin_so_far',rightmin_so_far)
        print('leftmin_so_far',leftmin_so_far)    
        print('rightmax_so_far',rightmax_so_far)
        
        return res
nums=    [-5,-4]
if __name__ == "__main__":
    print(Solution().maxDiffSubArrays(nums))      


#46. Majority Element
class Solution:
    """
    @param: nums: a list of integers
    @return: find a  majority number
    """
    def majorityNumber(self, nums):
        # write your code here
        
        from collections import defaultdict
        count=defaultdict(int)
        for n in nums:
            count[n]+=1
            if count[n]==len(nums)//2+1:
                return n

nums=[1, 1, 1, 1, 2, 2, 2]
if __name__ == "__main__":
    print(Solution().majorityNumber( nums))        
        
#47. Majority Element II  
class Solution:
    """
    @param: nums: a list of integers
    @return: The majority number that occurs more than 1/3
    """
    def majorityNumber(self, nums):
        # write your code here
        
        from collections import defaultdict
        count=defaultdict(int)
        for n in nums:
            count[n]+=1
            if count[n]==len(nums)//3+1:
                return n
nums=[1, 2, 1, 2, 1, 3, 3]
if __name__ == "__main__":
    print(Solution().majorityNumber(nums))     
        
        
#48. Majority Number III         
class Solution:
    """
    @param nums: A list of integers
    @param k: An integer
    @return: The majority number
    """
    def majorityNumber(self, nums, k):
        # write your code here        
        from collections import defaultdict
        count=defaultdict(int)
        for n in nums:
            count[n]+=1
            if count[n]==len(nums)//k+1:
                return n
                
nums=[3,1,2,3,2,3,3,4,4,4]
k=3        
if __name__ == "__main__":
    print(Solution().majorityNumber(nums, k))        
        
#49. Sort Letters by Case        
class Solution:
    """
    @param: chars: The letter array you should sort by Case
    @return: nothing
    """
    def sortLetters(self, chars):
        # write your code here
        i=0
        j=len(chars)-1
        chars=list(chars)
        while i<=j:
            
            while i<=j and chars[i].islower():
                i+=1
            while i<=j and chars[j].isupper():
                j-=1
            if i<j:
                chars[i], chars[j]=chars[j],chars[i]
        print(chars)
                
chars="abAcD"
if __name__ == "__main__":
    print(Solution().sortLetters( chars)) 

#Product of Array Exclude Itself
class Solution:
    """
    @param: nums: Given an integers array A
    @return: A long long array B and B[i]= A[0] * ... * A[i-1] * A[i+1] * ... * A[n-1]
    """
    def productExcludeItself(self, nums):
        # write your code here
        
        n=len(nums)
        
        res=[1]*n
        
        for i in range(1,n):
            res[i]=res[i-1]*nums[i-1]
        print(res)
        
        right=1
        
        for i in range(n-1,-1,-1):
            res[i]=res[i]*right
            right=nums[i]*right
        return res
        
nums=[1, 2, 3]        
if __name__ == "__main__":
    print(Solution().productExcludeItself( nums))        

#51. Previous Permutation
class Solution:
    """
    @param: nums: A list of integers
    @return: A list of integers that's previous permuation
    """
    def previousPermuation(self, nums):
        # write your code here    
        n=len(nums)
        
        if n<=1:
            return nums
        
        for i in range(n-2,-1,-1):
            if nums[i]>nums[i+1]:
                for j in range(n-1,i,-1):
                    if nums[j]<nums[i]:
                       nums[j],nums[i]=nums[i],nums[j]
                       nums[i+1:]=reversed (sorted(nums[i+1:]))
                       break
                break
            else:
                if i==0:
                   nums.reverse()
        return nums
nums=    [1,3,2,3]
nums=   [1,2,3,4]
if __name__ == "__main__":
    print(Solution().previousPermuation(nums))                
        
        
#52. Next Permutation         
class Solution:
    """
    @param nums: A list of integers
    @return: A list of integers
    """
    def nextPermutation(self, nums):
        # write your code here
        n=len(nums)
        
        if n<=1:
            return nums
        
        for i in range(n-2,-1,-1):
            if nums[i]<nums[i+1]:
                for j in range(n-1,i,-1):
                    if nums[j]>nums[i]:
                       nums[j],nums[i]=nums[i],nums[j]
                       nums[i+1:]=sorted(nums[i+1:])
                       break
                break
            else:
                if i==0:
                   nums.reverse()
        return nums
    
nums=[1,3,2,3]  [1,3,3,2] 
nums=[4,3,2,1]  [1,2,3,4]
if __name__ == "__main__":
    print(Solution().nextPermutation( nums)) 

#53. Reverse Words in a String 
class Solution:
    """
    @param: s: A string
    @return: A string
    """
    def reverseWords(self, s):
        # write your code here
        if not s:
            return s
        slist=s.split()
        if len(slist)==1:
            return s
        else:
            return ' '.join(reversed(slist))
s="How are you?"        
if __name__ == "__main__":
    print(Solution().reverseWords( s))       
        
#54. String to Integer (atoi)         
class Solution:
    """
    @param str: A string
    @return: An integer
    """
    def atoi(self, str):
        # write your code here
        if not str:
            return 0
      
        intmax=(1<<31)-1
        res=0
        i=0
        sign=1
        str=str.strip()
        n=len(str)
        if str[i]=='-':
            sign=-1
            i+=1
        elif str[i]=='+':
            i+=1
        
       
        for j in range(i,n):
            if str[j]<'0' or str[j]>'9':
                break
            
            res=res*10+int(str[j])
            
            
        res*=sign
        if res>intmax:
            return intmax
        elif res< intmax*-1:
            return intmax*-1-1
        else:
            return res

str= "    -5211314"       
if __name__ == "__main__":
    print(Solution().atoi( str))       

#55. Compare Strings            
class Solution:
    """
    @param A: A string
    @param B: A string
    @return: if string A contains all of the characters in B return true else return false
    """
    def compareStrings(self, A, B):
        # write your code here
        from collections import Counter
        AC=Counter(A)
        BC=Counter(B)
        dif = BC-AC
        return not dif
#56. Two Sum
class Solution:
    """
    @param numbers: An array of Integer
    @param target: target = numbers[index1] + numbers[index2]
    @return: [index1 + 1, index2 + 1] (index1 < index2)
    """
    def twoSum(self, numbers, target):
        # write your code here
        
        for i,n in enumerate(numbers):
            if target-n in numbers:
                if target-n !=n:
                    return [i,numbers.index(target-n)]
                else:
                    return [i,len(numbers)-1-(numbers[::-1].index(target-n))]
            
numbers=[2, 7, 11, 15]
target=9
numbers=[0,4,3,0]
target=0        
if __name__ == "__main__":
    print(Solution().twoSum(numbers, target))        
        

#57. 3Sum
class Solution:
    """
    @param numbers: Give an array numbers of n integer
    @return: Find all unique triplets in the array which gives the sum of zero.
    """
    def threeSum(self, numbers):
        # write your code here
        if not numbers:
            return []
        n=len(numbers)
        res=[]
        numbers.sort()
        for i in range(0,n-2):
            if i>0 and numbers[i]==numbers[i-1]:
                continue
            l=i+1
            r=n-1
            
            while l<r:
               s=numbers[i]+numbers[l]+numbers[r]
               if s>0:
                  r-=1
               elif s<0:
                  l+=1
               else:
                  res.append([numbers[i],numbers[l],numbers[r]])
                  while l<r  and numbers[l]==numbers[l+1]:
                      l+=1
                  while l<r  and numbers[r]==numbers[r-1]:
                      r-=1
                  l+=1
                  r-=1
        return res
    
numbers=[-1, 0, 1 ,2 ,-1, -4]
if __name__ == "__main__":
    print(Solution().threeSum(numbers))                   
        
        
#58. 4Sum        
class Solution:
    """
    @param numbers: Give an array
    @param target: An integer
    @return: Find all unique quadruplets in the array which gives the sum of zero
    """
    def fourSum(self, numbers, target):
        # write your code here
        def findNsum(nums,target,N,result,results):
            if N<2 or len(nums)<N or nums[0]*N>target or nums[-1]*N<target:
                return 
            if N==2:
                l=0
                r=len(nums)-1
                while l<r:
                    s=nums[l]+nums[r]
                    if s>target:
                        r-=1
                    elif s<target:
                        l+=1
                    else:
                        results.append(result+[nums[l],nums[r]])
                        while l<r  and nums[l]==nums[l+1]:
                            l+=1
                        while l<r and nums[r]==nums[r-1]:
                            r-=1
                        l+=1
                        r-=1
                        
            else:
                for i in range(len(nums)-N+1):
                   if i==0 or nums[i-1]!=nums[i]:
                      findNsum(nums[i+1:],target-nums[i],N-1,result+[nums[i]],results)
                      
                      
        results=[]
        findNsum(sorted( numbers),target,4,[],results)
        return results
numbers = [1 ,0, -1, 0, -2, 2]  
target = 0     
if __name__ == "__main__":
    print(Solution().fourSum( numbers, target))        
                
#59. 3Sum Closest 
class Solution:
    """
    @param numbers: Give an array numbers of n integer
    @param target: An integer
    @return: return the sum of the three integers, the sum closest target.
    """
    def threeSumClosest(self, numbers, target):
        # write your code here

        if not numbers:
               return 0
        numbers.sort()
        
        res=numbers[0]+numbers[1]+numbers[2]
        
        for i in range(len(numbers)-2):
            l=i+1
            r=len(numbers)-1
            
            while l <r:
                sumN=numbers[i]+numbers[l]+numbers[r]
                
                if sumN==target:
                    return sumN
                if abs(sumN-target )< abs(res-target ):
                    res=sumN
                
                if sumN<target:
                    l+=1
                elif sumN>target:
                    r-=1
        return res
numbers = [-1, 2, 1, -4]
target = 1
if __name__ == "__main__":
    print(Solution(). threeSumClosest(numbers, target))

#60. Search Insert Position                
class Solution:
    """
    @param A: an integer sorted array
    @param target: an integer to be inserted
    @return: An integer
    """
    def searchInsert(self, A, target):
        # write your code here
        if not A:
            return 0
        
        n=len(A)
        
        l=0
        r=n-1
        
        while l<=r:
            mid=(l+r)//2
            
            if A[mid]==target:
                return mid
            elif  A[mid]>target:
                r=mid-1
            else:
                l=mid+1
                
        return l
    def searchInsert(self, A, target):
        # write your code here
        if not A:
            return 0
        
        n=len(A)
        
        l=0
        r=n-1
        
        while l+1<r:
            mid=(l+r)//2
            
            if A[mid]==target:
                return mid
            elif  A[mid]>target:
                r=mid
            else:
                l=mid
        
        if A[l]>=target:
            return l
        if A[r]>=target:
            return r
        
                
        return n
    
    
    
    
      
A=[1,3,5,6]
target=5 → 2

A=[1,3,5,6]
target= 2 → 1

A=[1,3,5,6]
target=7 → 4

A=[1,3,5,6]
target= 0 → 0
                    
if __name__ == "__main__":
    print(Solution().searchInsert(A, target))


#61. Search for a Range   
class Solution:
    """
    @param A: an integer sorted array
    @param target: an integer to be inserted
    @return: a list of length 2, [index1, index2]
    """
    def searchRange(self, A, target):
        # write your code here
        if not A:
           return [-1,-1]     
        n=len(A)
        #get the leftmost 
        l=0
        r=n-1
        while l<=r:
            mid=(l+r)//2
            if A[mid]<target:
                l=mid+1
            else:
                r=mid-1
        if l<0 or l>=n or A[l]!=target:
            return [-1,-1]
        left=l
        
        l=0
        r=n-1
        while l<=r:
            mid=(l+r)//2
            if A[mid]>target:
                r=mid-1
            else:
                l=mid+1
        right=r
        return [left,right]
A=[5, 7, 7, 8, 8, 10]
target= 8        
if __name__ == "__main__":
    print(Solution().searchRange(A, target))                          
                        
#62. Search in Rotated Sorted Array 
class Solution:
    """
    @param A: an integer rotated sorted array
    @param target: an integer to be searched
    @return: an integer
    """
    def search(self, A, target):
        # write your code here
        if not A:
            return -1
        n=len(A)
        l=0
        r=n-1
        
        while l<=r:
            mid=(l+r)//2
            if A[mid]==target:
                return mid
            if  A[mid]<A[r]: # right part is sorted 
                 if A[mid]< target and target <= A[r]:
                     l=mid+1
                 else:
                     r=mid-1
            else:#left part is sorted
                if A[l]<=target and target < A[mid]:
                    r=mid-1
                else:
                    l=mid+1
        return -1
A=[4, 5, 1, 2, 3] 
target=1
A=[4, 5, 1, 2, 3]
target=0
A=[6,8,9,1,3,5]
target=5
if __name__ == "__main__":
    print(Solution().search(A, target))                    
            
                
#63. Search in Rotated Sorted Array II  
class Solution:
    """
    @param A: an integer ratated sorted array and duplicates are allowed
    @param target: An integer
    @return: a boolean 
    """
    def search(self, A, target):
        # write your code here
        if not A:
            return False
        l=0
        
        n=len(A)
        r=n-1
       
        
        while l<=r:
            mid=(l+r)>>1
            if A[mid]==target:
                return True
            if  A[mid]==A[l]  and A[mid]==A[r]:
                l+=1
                r-=1
            elif A[mid] < A[r]:# right part is sorted
                 if A[mid]<target and target<=A[r]:
                     l=mid+1
                 else:
                     r=mid-1
            else:# left part is sorted
                if A[l]<=target and target < A[mid]:
                    r=mid-1
                else:
                    l=mid+1
        return False
A=[1, 1, 0, 1, 1, 1] 
target=0
A=[4, 5, 1, 2, 3]
target=0
A=[6,8,9,1,3,5]
target=5
A=[1, 1, 1, 1, 1, 1]
target=0
if __name__ == "__main__":
    print(Solution().search(A, target))                    
                
#64. Merge Sorted Array                 
class Solution:
    """
    @param: A: sorted integer array A which has m elements, but size of A is m+n
    @param: m: An integer
    @param: B: sorted integer array B which has n elements
    @param: n: An integer
    @return: nothing
    """
    def mergeSortedArray(self, A, m, B, n):
        # write your code here
        i=m-1
        j=n-1
        index=m+n-1
        while    i>-1 and j>-1:
             if A[i]<B[j]:
                 A[index]=B[j]
                 j-=1
             else:
                 A[index]=A[i]
                 i-=1
             index-=1
        while j>-1:
            A[index]=B[j]
            index-=1
            j-=1
      
A = [1, 2, 3, empty, empty]
B = [4, 5]
if __name__ == "__main__":
    print(Solution().search(A, target))            
                 
#65. Median of two Sorted Arrays  
class Solution:
    """
    @param: A: An integer array
    @param: B: An integer array
    @return: a double whose format is *.5 or *.0
    """
    def findMedianSortedArrays(self, A, B):
    
        def findKth(A,B,k):
            a=len(A)
            b=len(B)
            if a>b:
               A,B=B,A
            print(A,B)
            if not A:
               return B[k]
            if k==a+b-1:
               return max(A[-1],B[-1])
        
            i=min(a-1,k//2)
            j=min(b-1,k-i)
        
        
            if A[i]>B[j]:
               return findKth(A[:i],B[j:],i)
            else:
               return findKth(A[i:],B[:j],j)
        
        l=len(A)+len(B)
        
        if l%2==1:
            return findKth(A,B,l//2)
        else:
            return (findKth(A,B,l//2-1)+findKth(A,B,l//2))/2
        
A=[1,2,3,4,5,6]
B=[2,3,4,5]       

[1, 2, 2, 3, 3, 4, 4, 5, 5, 6]     
A=[2]
B=[]
if __name__ == "__main__":
    print(Solution().findMedianSortedArrays( A, B))           
        
#66. Binary Tree Preorder Traversal 
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""

class Solution:
    """
    @param root: A Tree
    @return: Preorder in ArrayList which contains node values.
    """
    def preorderTraversal(self, root):
        # write your code here
        
        def tranverse(node,res):
            
            if node:
                res.append(node.val)
                tranverse(node.left,res)
                tranverse(node.right,res)
            return res
        res=[]
        return tranverse(root,res)
    
    
    
        #Non_recursive
        if not root:
            return []
        stack=[root]
        preorder=[]
        
        while stack:
            node=stack.pop()
            preorder.append(node.val)
            if node.right:
                stack.append(node.right)
            if node.left:
                stack.append(node.left)
        return preorder
                
#67. Binary Tree Inorder Traversal         
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""

class Solution:
    """
    @param root: A Tree
    @return: Inorder in ArrayList which contains node values.
    """
    def inorderTraversal(self, root):
        # write your code here
        if not root:
            return []
        
        stack=[]
        inorder=[]
        
        cur=root
        while cur:
            stack.append(cur)
            cur=cur.left
        
        
        while stack:
            node=stack.pop()
            inorder.append(node.val)
            if node.right:
                cur=node.right
                while cur:
                    stack.append(cur)
                    cur=cur.left
        return inorder
#68. Binary Tree Postorder Traversal 
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""

class Solution:
    """
    @param root: A Tree
    @return: Postorder in ArrayList which contains node values.
    """
    def postorderTraversal(self, root):
        # write your code here    
        if not root:
            return []
        
        stack=[root]
        postorder=[]
        while stack:
            node=stack.pop()
            postorder.insert(0,node.val)
            
            if node.left:
                stack.append(node.left)
            if node.right:
                stack.append(node.right)
        return postorder
            
#69. Binary Tree Level Order Traversal 
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
class Solution:
    """
    @param root: A Tree
    @return: Level order a list of lists of integer
    """
    def levelOrder(self, root):
        # write your code here
        if not root:
            return []
        
        q=[root]
        result=[]
        
        while q:
            new_q=[]
            result.append([n.val for n in q])
            
            for n in q:
                if n.left:
                    
                  new_q.append(n.left)
                if n.right:
                  new_q.append(n.right)
            q=new_q
                    
        return result
    
root=TreeNode(1)  
root.left=    TreeNode(2) 
root.right=    TreeNode(3) 
root.left.left=TreeNode(4)
root.left.right=TreeNode(5) 
root.left.right.left=TreeNode(7)
root.left.right.right=TreeNode(8)
root.right.right=TreeNode(6)



    1
   / \
  2   3
 / \   \
4   5   6
   / \
  7   8 
if __name__ == "__main__":
    print(Solution().levelOrder(root)) 

#70. Binary Tree Level Order Traversal II
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""

class Solution:
    """
    @param root: A tree
    @return: buttom-up level order a list of lists of integer
    """
    def levelOrderBottom(self, root):
        # write your code here
        if not root:
            return []
        
        q=[root]
        result=[]
        
        while q:
            new_q=[]
            result.append([n.val for n in q])
            
            for n in q:
                if n.left:
                    
                  new_q.append(n.left)
                if n.right:
                  new_q.append(n.right)
            q=new_q
                    
        return result[::-1]


#71. Binary Tree Zigzag Level Order Traversal
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""

class Solution:
    """
    @param root: A Tree
    @return: A list of lists of integer include the zigzag level order traversal of its nodes' values.
    """
    def zigzagLevelOrder(self, root):
        # write your code here
        if not root:
            return []
        
        q=[root]
        result=[]
        direction=True
        
        while q:
            new_q=[]
            if direction:
               result.append([n.val for n in q])
            else:
               result.append([n.val for n in q][::-1])
            direction= not direction
                
            
            for n in q:
                if n.left:
                    
                  new_q.append(n.left)
                if n.right:
                  new_q.append(n.right)
            q=new_q
                    
        return result
    
    
root=TreeNode(1)  
root.left=    TreeNode(2) 
root.right=    TreeNode(3) 
root.left.left=TreeNode(4)
root.left.right=TreeNode(5) 
root.left.right.left=TreeNode(7)
root.left.right.right=TreeNode(8)
root.right.right=TreeNode(6)
    1
   / \
  2   3
 / \   \
4   5   6
   / \
  7   8 
if __name__ == "__main__":
    print(Solution().zigzagLevelOrder( root))         
        
#72. Construct Binary Tree from Inorder and Postorder Traversal        
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""

class Solution:
    """
    @param inorder: A list of integers that inorder traversal of a tree
    @param postorder: A list of integers that postorder traversal of a tree
    @return: Root of a tree
    """
    def buildTree(self, inorder, postorder):
        # write your code here
        if not inorder or not postorder:
            return None
        
        root=TreeNode(postorder[-1])
        
        rootPOS=inorder.index(postorder[-1])
        
        root.left=self.buildTree(inorder[:rootPOS],postorder[:rootPOS])
        root.right=self.buildTree(inorder[rootPOS+1:],postorder[rootPOS:-1])
        return root

#73. Construct Binary Tree from Preorder and Inorder Traversal 
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""

class Solution:
    """
    @param inorder: A list of integers that inorder traversal of a tree
    @param postorder: A list of integers that postorder traversal of a tree
    @return: Root of a tree
    """
    def buildTree(self,  preorder,inorder):
        # write your code here
#(a) Inorder (Left, Root, Right) : 4 2 5 1 3
#(b) Preorder (Root, Left, Right) : 1 2 4 5 3
#(c) Postorder (Left, Right, Root) : 4 5 2 3 1 
        if not inorder :
            return None
        
        root=TreeNode(preorder[0])
        rootPOS=inorder.index(preorder[0])
        root.left=self.buildTree(preorder[1:rootPOS+1],inorder[:rootPOS])
        root.right=self.buildTree(preorder[rootPOS+1:],inorder[rootPOS+1:])
        return root
        
#74. First Bad Version 
"""
class SVNRepo:
    @classmethod
    def isBadVersion(cls, id)
        # Run unit tests to check whether verison `id` is a bad version
        # return true if unit tests passed else false.
You can use SVNRepo.isBadVersion(10) to check whether version 10 is a 
bad version.
"""


class Solution:
    """
    @param: n: An integer
    @return: An integer which is the first bad version.
    """
    def findFirstBadVersion(self, n):
        # write your code here
        if n<=1:
            return n
        
        
        l=1
        r=n
        
        while l+1<r:
            mid=(l+r)>>1
            if SVNRepo.isBadVersion(mid):
                r=mid
            else:
                l=mid
        
        
        for i in range(l,r+1):
            if  not SVNRepo.isBadVersion(i)  and SVNRepo.isBadVersion(i+1):
                return i+1

#75. Find Peak Element
class Solution:
    """
    @param: A: An integers array.
    @return: return any of peek positions.
    """
    def findPeak(self, A):
        # write your code here
        n=len(A)
        
        if n==1:
            return A[0]
        
        start=0
        end=n-1
        
        while start+1<end:
            mid=(start+end)>>1
            if A[mid]<A[mid+1]:
                start=mid
            elif A[mid]<A[mid-1]:
                end=mid
            else:
                end=mid
        
        if A[start]>A[end]:
            return start
        else:
            return end
A=[1, 2, 1, 3, 4, 5, 7, 6]
if __name__ == "__main__":
    print(Solution().findPeak( A))            
            
#76. Longest Increasing Subsequence 
class Solution:
    """
    @param nums: An integer array
    @return: The length of LIS (longest increasing subsequence)
    """
    def longestIncreasingSubsequence(self, nums):
        # write your code here
        #n**2
        if not nums:
            return 0
        
        n=len(nums)
        
        dp=[1]*n
        
        for i , val in enumerate(nums):
            for j in range(i):
                if nums[j]<val:
                   dp[i]=max(dp[i],dp[j]+1)
        return max(dp)
        #n*lgn
        if not nums:
            return 0
        
        n=len(nums)
        
        tail=[0]*n
        size=0
        
        for x in nums:
            i=0
            j=size
            while i!=j:
                mid=(i+j)>>1
                if tail[mid]<x:
                    i=mid+1
                else:
                    j=mid
            tail[i]=x
            size=max(size,i+1)
        return size
                
#77. Longest Common Subsequence
class Solution:
    """
    @param A: A string
    @param B: A string
    @return: The length of longest common subsequence of A and B
    """
    def longestCommonSubsequence(self, A, B):
        # write your code here
        m=len(A)
        n=len(B)
        
        if not m or not n:
            return 0
        
        dp=[[0 for _ in range(n+1)]  for _ in range(m+1)]
        
        for i in range(1,n+1):
            for j in range(1,m+1):
                if A[i-1]==B[j-1]:
                    dp[i][j]=dp[i-1][j-1]+1
                else:
                    dp[i][j]=max(dp[i][j-1],dp[i-1][j])
        return dp[m][n]
#78. Longest Common Prefix
class Solution:
    """
    @param strs: A list of strings
    @return: The longest common prefix
    """
    def longestCommonPrefix(self, strs):
        # write your code here
        if not strs:
            return ''
        
        if len(strs)==1:
            return strs[0]
        
        
        for i in range(len(strs[0])):
            for string in strs[1:]:
                if i+1>len(string)  or strs[0][i]!=string[i]:
                    return strs[0][:i]
        return strs[0]
strs=["ABCD", "ABEF"]
strs=["abc","abcd","","ab","ac"]
if __name__ == "__main__":
    print(Solution().longestCommonPrefix( strs))           
        
#79. Longest Common Substring        
class Solution:
    """
    @param A: A string
    @param B: A string
    @return: the length of the longest common substring.
    """
    def longestCommonSubstring(self, A, B):
        # write your code here
        m=len(A)
        n=len(B) 
        
        if not m or not n:
            return 0
        dp = [[0 for _ in range(n+1)] for _ in range(m+1)]
        ans=0
        for i in range(1,m+1):
            for j in range(1,n+1):
                if A[i-1]==B[j-1]:
                    dp[i][j]=dp[i-1][j-1]+1
                ans=max(ans,dp[i][j])
        print(dp)
        return ans
                    
A="www.lintcode.com code"
B="www.ninechapter.com code"        
if __name__ == "__main__":
    print(Solution().longestCommonSubstring( A, B))                 
#80. Median        
class Solution:
    """
    @param nums: A list of integers
    @return: An integer denotes the middle number of the array
    """
    def median(self, nums):
        # write your code here        
        def partition(s,e,k):
            
            p=s+1
            q=len(nums)-1
            
            while p<=q:
                if nums[p]>nums[s]:
                    p+=1
                else:
                    nums[p],nums[q]=nums[q],nums[p]
                    q-=1
            nums[s],nums[q]=nums[q],nums[s]
            
            m=q
            
            if m==k:
                return nums[m]
            elif m>k:
                return partition(s,m-1,k)
            else:
                return partition(m+1,e,k)
        
        if len(nums)%2==1:
            return  partition(0,len(nums)-1,len(nums)//2)
        else:
            #print(partition(0,len(nums)-1,len(nums)//2))
            #print(partition(0,len(nums)-1,len(nums)//2-1))
            return partition(0,len(nums)-1,len(nums)//2)
nums=[4, 5, 1, 2, 3]   
nums=[7, 9, 4, 5]             
if __name__ == "__main__":
    print(Solution().median( nums))         
        
#81. Find Median from Data Stream
import heapq        
class Solution:
    """
    @param nums: A list of integers
    @return: the median of numbers
    """
    
    def medianII(self, nums):
        # write your code here 
        minheap=[]
        maxheap=[]
        ans=[]
        
            
        def add_to_heap(minheap,maxheap,num):
            if not maxheap or num < -maxheap[0]:
                heapq.heappush(maxheap,-num)
            else:
                heapq.heappush(minheap,num)
                
        
        def balance(minheap,maxheap):
            while len(maxheap) < len(minheap):
                heapq.heappush(maxheap,-heapq.heappop(minheap))
            while len(maxheap) > len(minheap)+1:
                heapq.heappush(minheap,-heapq.heappop(maxheap))
            
            
        for num in nums:
            add_to_heap(minheap,maxheap,num)
            balance(minheap,maxheap)
            median=-maxheap[0]
            ans.append(median)
            print(minheap,maxheap)
        return ans
nums=[4, 5, 1, 3, 2, 6, 0,200,100]            
if __name__ == "__main__":
    print(Solution(). medianII( nums))         
        
#82. Single Number
class Solution:
    """
    @param A: An integer array
    @return: An integer
    """
    def singleNumber(self, A):
        # write your code here
        
        res=A[0]
        
        for i in range(1,len(A)):
            res^=A[i]
        return res
A=[1,2,2,1,3,4,3]
if __name__ == "__main__":
    print(Solution().singleNumber( A))       


#83. Single Number II 
class Solution:
    """
    @param A: An integer array
    @return: An integer
    """
    def singleNumberII(self, A):
        # write your code here
        # 创建一个长度为32的数组countsPerBit，  
        # countsPerBit[i]表示A中所有数字在i位出现的次数  
        countsPerBit=[0]*32
        res=0
        
        for i in range(32):
            for j in A:
                if (j>>i)&1 ==1:
                    countsPerBit[i]=(countsPerBit[i]+1)%3
            res|=countsPerBit[i]<<i
        return res
A=[1,1,2,3,3,3,2,2,4,1]        
if __name__ == "__main__":
    print(Solution().singleNumberII( A))        
        
#84. Single Number III         
class Solution:
    """
    @param: A: An integer array
    @return: An integer array
    """
    def singleNumberIII(self, A):
        # write your code here        
#http://fisherlei.blogspot.com/2015/10/leetcode-single-number-iii-solution.html
#Why diff &= ~(diff - 1)
#First, this the original formula to get the last set bit. The diff &= -diff is just an abbreviation with the knowledge of ~(diff - 1) = - (diff - 1) - 1 = -diff.
#
#If diff is set on the least significant bit, then this is trivially provable: the least significant bit is the last set bit. After the -1 operation, this least significant bit became 0, and is the only change to all bits of diff. Then we ~ the result, which means the least significant bit gets reverted to 1, while all the other bits are guaranteed to have been reverted. Thus the least significant bit is the only bit that is left unchanged and that could survive the & operation.
#If diff is unset on the least significant bit: let's focus on the rightmost occurrence of 10 in diff. The 1 bit in this 10 is the last set bit of diff. After -1 operation, this 10 becomes 01. All the 0 bits to the right of this rightmost 10 are all change to 1 bits, and all the other whatever bits to the left of this rightmost 10 would be remain unchanged:
#**..**10_00..00
#after -1:
#**..**01_11..11
#Then we do ~ operation. The **..** part would all be reverted, and none of them would survive the upcoming & operation. 01 would become back 10, and would both survive the & operation, although the bit 1 is the only one we care about. All those 11..11 part gets reverted back to 00..00 after the ~ operation, and does not matter to the & operation. Thus the only thing surviving the & operation would be the rightmost 10, or the last set bit which is within it.
#
#Incidentally, it does not really matter which bit we choose for the second pass to succeed, but since there is an elegant way to find the rightmost set bit, then let's use that.
#        
        dif=0
        for num in A:
            dif^=num
        dif=dif & (~(dif-1))
        
        c1=0
        c2=0
        for num in A:
            if dif&num==0:
                c1^=num
                
            else:
                c2^=num
        return [c1,c2]
        
#85. Insert Node in a Binary Search Tree 
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""


class Solution:
    """
    @param: root: The root of the binary search tree.
    @param: node: insert this node into the binary search tree
    @return: The root of the new binary search tree.
    """
    def insertNode(self, root, node):
        # write your code here
        if not root:
            return node
        
        cur=root
        
        while cur !=node:
            if node.val<cur.val:
                if not cur.left:
                    cur.left=node
                cur=cur.left
            else:
                if not cur.right:
                    cur.right=node
                cur=cur.right
        return root
                
        
#86. Binary Search Tree Iterator         
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None

Example of iterate a tree:
iterator = BSTIterator(root)
while iterator.hasNext():
    node = iterator.next()
    do something for node 
"""


class BSTIterator:
    """
    @param: root: The root of binary tree.
    """
    def __init__(self, root):
        # do intialization if necessary
        self.stack=[]
        self.root=root

    """
    @return: True if there has next node, or false
    """
    def hasNext(self ):
        # write your code here
        if self.stack or self.root:
            return True

    """
    @return: return next node
    """
    def next(self ):
        # write your code here
        
        while self.root:
            self.stack.append(self.root)
            
            self.root=self.root.left
        node=self.stack.pop()
        nxt=node
        self.root=node.right
        return nxt
                
#87. Remove Node in Binary Search Tree 
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""


class Solution:
    """
    @param: root: The root of the binary search tree.
    @param: value: Remove the node with given value.
    @return: The root of the binary search tree after removal.
    """
    def removeNode(self, root, value):
        # write your code here 
        if root.val > value:
            root.left=self.removeNode(root.left,value)
        elif root.val < value:
            root.right=self.removeNode(root.right,value)
        else:
            if not root.left:
                return root.right
            elif not root.right:
                return root.left
            else:
                smallestright=root.right
                while smallestright.left:
                    smallestright=smallestright.left
                smallestright.left=root.left
                return root.right
        return root
                      
#88. Lowest Common Ancestor of a Binary Tree 
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""


class Solution:
    """
    @param: root: The root of the binary search tree.
    @param: A: A TreeNode in a Binary.
    @param: B: A TreeNode in a Binary.
    @return: Return the least common ancestor(LCA) of the two nodes.
    """
    def lowestCommonAncestor(self, root, A, B):
        # write your code here

        if not root:
          return root
        if root==A or root==B:
            return root
        
        left=self.lowestCommonAncestor(root.left,A,B)
        right=self.lowestCommonAncestor(root.right,A,B)
        
        if left  and right:
            return root
        
        if left:
            return left 
        if right:
            return right
        return None
            
#89. k Sum 
class Solution:
    """
    @param A: An integer array
    @param k: A positive integer (k <= length(A))
    @param target: An integer
    @return: An integer
    """
    
    def kSum(self, A, k, target):
        # write your code here
        
#        self.result=0
#        def findkSum(A,k,target):
#            
#            if not A or len(A)<k or A[0]*k >target or     A[-1]*k <target  :
#               return 
#            
#            if k==1:
#                for a in A:
#                    if a==target:
#                       self.result+=1
#                
#                
#        
#            elif k==2:
#               r=len(A)-1
#               l=0
#               while l<r:
#                   tempsum=A[r]+A[l]
#                   if tempsum>target:
#                       r-=1
#                   elif tempsum<target:
#                       l+=1
#                   else:
#                       self.result+=1
#                       while l<r and A[l]==A[l+1]:
#                           l+=1
#                       while l<r and A[r]==A[r-1]:
#                           r-=1
#                       r-=1
#                       l+=1
#            else:         
#              for i in range(len(A)-k+1):
#                if i==0 or A[i]!=A[i-1]:
#                   findkSum(A[i+1:],k-1,target-A[i])
#            
#        
#        A.sort()
#        
#        findkSum(A,k,target)
#        return self.result
            
            n=len(A)
            ksum=[[[0 for _ in range(k+1)]  for _ in range(n+1)]  for _ in range(target+1)]
            for i in range(n+1):
               ksum[0][i][0]=1
        
            for i in range(1,target+1):
              for j in range(1,n+1):
                for l in range(1,min(j,k)+1):
                   ksum[i][j][l] =ksum[i][j-1][l]
                   if i>=A[j-1]  :
                       ksum[i][j][l]+=ksum[i-A[j-1]][j-1][l-1]
        
            return ksum[target][n][k]
                       
A=[1,3,4,5,8,10,11,12,14,17,20,22,24,25,28,30,31,34,35,37,38,40,42,44,45,48,51,54,56,59,60,61,63,66]
k = 24
target = 842 
A=[1,2,3,4]
k = 2
target = 5 
A=[1,3,5,7,10,13,14,17,19,22,24,27,30,33,34,36,38,41] 
k=5
target=176                    
if __name__ == "__main__":
    print(Solution().kSum( A, k, target))        
                               
#90. k Sum II                          
class Solution:
    """
    @param: A: an integer array
    @param: k: a postive integer <= length(A)
    @param: targer: an integer
    @return: A list of lists of integer
    """
    def kSumII(self, A, k, target):
        # write your code here
        def findkSum(A,k,target,result,results):
            
            
            if not A or len(A)<k or A[0]*k >target or     A[-1]*k <target  :
               return 
            
            if k==1:
                for a in A:
                    if a==target:
                       results.append([a])
                
                
        
            elif k==2:
               r=len(A)-1
               l=0
               while l<r:
                   tempsum=A[r]+A[l]
                   if tempsum>target:
                       r-=1
                   elif tempsum<target:
                       l+=1
                   else:
                       results.append(result+[A[r],A[l] ])
                       while l<r and A[l]==A[l+1]:
                           l+=1
                       while l<r and A[r]==A[r-1]:
                           r-=1
                       r-=1
                       l+=1
            else:         
              for i in range(len(A)-k+1):
                if i==0 or A[i]!=A[i-1]:
                   findkSum(A[i+1:],k-1,target-A[i],result+[A[i]],results)
            
        results=[]
        A.sort()
        
        findkSum(A,k,target,[],results)
        
        return results 
A=[1,4,5,6,8]
k=1
target=4                          
if __name__ == "__main__":
    print(Solution().kSumII( A, k, target)) 
       
#91. Minimum Adjustment Cost
class Solution:
    """
    @param: A: An integer array
    @param: target: An integer
    @return: An integer
    """
    def MinAdjustmentCost(self, A, target):
        # write your code here                                                          
#http://ryanleetcode.blogspot.com/2015/05/minimum-adjustment-cost.html
#https://www.geeksforgeeks.org/find-minimum-adjustment-cost-of-an-array/                       
#https://zhengyang2015.gitbooks.io/lintcode/minimum_adjustment_cost_91.html
        if not A:
          return 0
      
        #you can assume each number in the array is a positive integer and not greater than 100.
        dp=[[0 for _ in range(101)] for _ in range(len(A)+1) ]
        
        for i in range(1,101):
            dp[1][i]=abs(A[0]-i)
            
        for i in range(2,len(A)+1):
            for j in range(1,101):
                dp[i][j]=float('inf')
                for k in range(1,101):
                    if abs(k-j)<=target:
                        dp[i][j]=min(dp[i][j],dp[i-1][k]+abs(j-A[i-1]))
        
        res=float('inf')
        for j in range(1,101):
        
            res=min(res,dp[len(A)][j])
        return res
A=[1,4,2,3] 
target = 1    
if __name__ == "__main__":
    print(Solution().MinAdjustmentCost( A, target) )
        
#92. Backpack
class Solution:
    """
    @param m: An integer m denotes the size of a backpack
    @param A: Given n items with size A[i]
    @return: The maximum size
    """
    def backPack(self, m, A):
        # write your code here
#https://aaronice.gitbooks.io/lintcode/content/dynamic_programming/backpack.html
#f[i][S] “前i”个物品，取出一些能否组成和为S            
#        if not A:
#            return 0
#        n=len(A)
#        dp =[ [0 for _ in range(m+1)] for _ in range(n+1)  ]  
#        dp[0][0]=True
#        
##        for j in range(1,m+1):
##            dp[0][j]=False
##            
##        for j in range(1,n+1) :   
##            dp[j][0]=True
#            
#            
#        for i in range(1,n+1):
#            for j in range(m+1):
#                if dp[i-1][j] or ( j-A[i-1] >=0 and dp[i-1][j-A[i-1]] ):
#                    dp[i][j]=True
#                else:
#                    dp[i][j]=False
#        
#        
#        for k in range(m,0,-1):
#            if dp[n][k]:
#                return k
#        return 0
        if not A:
            return 0
        n=len(A)
        
        dp=[0 for _ in range(m+1)]
        dp[0]=True
        ans=0
        for item in A:
            for j in range(m,0,-1):
                if j-item>=0 and dp[j-item]:
                    dp[j]=True
                    ans=max(ans,j)
        return ans
                    
A=[81,112,609,341,164,601,97,709,944,828,627,730,460,523,643,901,602,508,401,442,738,443,555,471,97,644,184,964,418,492,920,897,99,711,916,178,189,202,72,692,86,716,588,297,512,605,209,100,107,938,246,251,921,767,825,133,465,224,807,455,179,436,201,842,325,694,132,891,973,107,284,203,272,538,137,248,329,234,175,108,745,708,453,101,823,937,639,485,524,660,873,367,153,191,756,162,50,267,166,996,552,675,383,615,985,339,868,393,178,932] 
m = 80000  
if __name__ == "__main__":
    print(Solution().backPack( m, A) )                    

#93. Balanced Binary Tree
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""

class Solution:
    """
    @param root: The root of binary tree.
    @return: True if this Binary tree is Balanced, or false.
    """
    def isBalanced(self, root):
        # write your code here
        def getHeight(node):
            if not node:
                return 0
            lh=getHeight(node.left)
            rh=getHeight(node.right)
            return max(lh,rh)+1
        
        if not root:
            return True
        
        lh=getHeight(root.left)
        rh=getHeight(root.right)
        return abs(lh-rh) <=1  and self.isBalanced(root.left)  and self.isBalanced(root.right)
                    
#94. Binary Tree Maximum Path Sum 
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""

class Solution:
    """
    @param root: The root of binary tree.
    @return: An integer
    """
    def maxPathSum(self, root):
        # write your code here
        self.maxseen=float('-inf')
        def pathSum(node):
            if not node:
                return 0
            
            left=max(0,pathSum(node.left))
            right=max(0,pathSum(node.right))
            
            self.maxseen=max(self.maxseen,left+right+node.val)
            return node.val+max(left,right)
            
        pathSum(root)   
        return self.maxseen        
  1
 / \
2   3                      
root= TreeNode(1)
root.left=TreeNode(2)
root.right=TreeNode(3) 
if __name__ == "__main__":
    print(Solution().maxPathSum( root) )   

#95. Validate Binary Search Tree 
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""

class Solution:
    """
    @param root: The root of binary tree.
    @return: True if the binary tree is BST, or false
    """
    def isValidBST(self, root):
        # write your code here
        
        def inorder(root):
            if root.left:
                inorder(root.left)
            ans.append(root.val)
            if root.right:
                inorder(root.right)
        
        if not root:
            return True
        ans=[]
        inorder(root)
        
        print(ans)
        last=None
        for node in  sorted(ans):
            print(last,node)
            if not last:
                last=node
                continue
            
            if last==node:
                return False
            last=node
            
        if ans[:]==sorted(ans):
            return True
        else:
            return False

                
#{2,1,2}                
            
root= TreeNode(2)
root.left=TreeNode(1)
root.right=TreeNode(2) 
if __name__ == "__main__":
    print(Solution().isValidBST( root) )
                   
                    
#96. Partition List            
"""
Definition of ListNode
class ListNode(object):
    def __init__(self, val, next=None):
        self.val = val
        self.next = next
"""

class Solution:
    """
    @param head: The first node of linked list
    @param x: An integer
    @return: A ListNode
    """
    def partition(self, head, x):
        # write your code here            
        
        
        
#Given 1->4->3->2->5->2->null and x = 3,
#return 1->2->2->4->3->5->null.  
        smallhead=ListNode(None)
        largehead=ListNode(None)
        
        
            
        cur=head
        smallheadcur    =smallhead
        largeheadcur    =largehead
        while cur:
            if cur.val<x:
                smallheadcur.next=cur
                if smallheadcur.next:
                   smallheadcur=smallheadcur.next
            else:
                largeheadcur.next=cur
                largeheadcur=largeheadcur.next
            #print(smallheadcur.val,largeheadcur.val)
            cur=cur.next
        if largeheadcur.next:
            largeheadcur.next=None
            
        smallheadcur.next=largehead.next
        
        temp=smallhead.next
        while temp:
            print(temp.val,sep=',', end='')
            temp=temp.next
        
        return smallhead.next
#1->4->3->2->5->2
head=ListNode(1)
head.next=ListNode(4)
head.next.next=ListNode(3)
head.next.next.next=ListNode(2)
head.next.next.next.next=ListNode(5)
head.next.next.next.next.next=ListNode(2)


head=ListNode(3)
head.next=ListNode(3)
head.next.next=ListNode(1)
head.next.next.next=ListNode(2)
head.next.next.next.next=ListNode(4)

x=3
if __name__ == "__main__":
    print(Solution().partition( head, x) )        
        
#97. Maximum Depth of Binary Tree                
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""

class Solution:
    """
    @param root: The root of binary tree.
    @return: An integer
    """
    def maxDepth(self, root):
        # write your code here
#  1
# / \ 
#2   3
#   / \
#  4   5            
#        
        def height(node):
           if not node:
               return 0
           return max(height(node.left),height(node.right))+1
       
        return height(root)
        
#98. Sort List      
"""
Definition of ListNode
class ListNode(object):
    def __init__(self, val, next=None):
        self.val = val
        self.next = next
"""

class Solution:
    """
    @param head: The head of linked list.
    @return: You should return the head of the sorted linked list, using constant space complexity.
    """
    def sortList(self, head):
        # write your code here
        def merge(list1,list2) :
            if not list1:
                return list2
            if not list2:
                return list1
            
            head=None
            
            if list1.val<list2.val:
                head=list1
                list1=list1.next
            else:
                head=list2
                list2=list2.next
                
            temp=head
            
            while list1 and list2:
                  if list1.val<list2.val:
                      temp.next=list1
                      list1=list1.next
                      temp=temp.next
                  else:
                      temp.next=list2
                      list2=list2.next
                      temp=temp.next
            if list1:
                temp.next=list1
            if list2:
                temp.next=list2
                
            return head
        
        
        if not head:
            return head
        
        if not head.next:
            return head
        
        slow=head
        fast=head
        
        while fast.next and fast.next.next:
              fast=fast.next.next
              slow=slow.next
        mid=slow.next
        slow.next=None
        
        
        
        list1=self.sortList(head)
        list2=self.sortList(mid)
        
        newhead=merge(list1,list2)
        return newhead
        
#99. Reorder List        
"""
Definition of ListNode
class ListNode(object):
    def __init__(self, val, next=None):
        self.val = val
        self.next = next
"""

class Solution:
    """
    @param head: The head of linked list.
    @return: nothing
    """
    def reorderList(self, head):
        # write your code here
        if not head or not head.next or not head.next.next:
            return head
        
        pfast=head
        pslow=head
        
        while pfast.next and pfast.next.next:
            pfast=pfast.next.next
            pslow=pslow.next
        
        part2_head=pslow.next
        pslow.next=None
        
        cur=part2_head.next
        prev=part2_head
        part2_head.next=None
        
        while cur:
            temp=cur.next
            cur.next=prev
            prev=cur
            cur=temp
        
        
        part1_node=head
        part2_node=prev
        
        while part2_node:
               temp=part2_node.next
               part2_node.next=part1_node.next
               part1_node.next=part2_node
               part2_node=temp
               part1_node=part1_node.next.next
        cur=head
        while cur:
           print(cur.val,sep=',',end='')
           cur=cur.next
        return head
               
#1->2->3->4        
            
head=ListNode(1)
head.next=ListNode(2)
head.next.next=ListNode(3)
head.next.next.next=ListNode(4)
if __name__ == "__main__":
    print(Solution().reorderList( head) )               
#100. Remove Duplicates from Sorted Array        
class Solution:
    """
    @param: nums: An ineger array
    @return: An integer
    """
    def removeDuplicates(self, nums):
        # write your code here
        n=len(nums)
        if n==0 :
            return 0
        index=0
        for i in range(1,n):
            if nums[index]!=nums[i]:
                index+=1
                nums[index]=nums[i]
        return index+1
nums=   [-10,0,1,2,3]
nums=   [-10,0,1,1,1,2,3]
nums=[]
if __name__ == "__main__":
    print(Solution().removeDuplicates( nums) )                 
            
#101. Remove Duplicates from Sorted Array II    
class Solution:
    """
    @param: nums: An ineger array
    @return: An integer
    """
    def removeDuplicates(self, nums):
        # write your code here  
        n=len(nums)
        if n==0 :
            return 0
        if n==1:
            return 1
        
        if n==2:
            return 2
        
        index=1
       
        for i in range(2,n):
            if  nums[index-1]!=nums[i]:
                index+=1
                nums[index]=nums[i]
        print(nums[:index+1])
        return index+1
        
nums=   [-10,0,1,2,3]
nums=   [-10,0,1,1,1,2,3]
nums=[]        
if __name__ == "__main__":
    print(Solution().removeDuplicates( nums) )           
                
#102. Linked List Cycle                       
"""
Definition of ListNode
class ListNode(object):

    def __init__(self, val, next=None):
        self.val = val
        self.next = next
"""


class Solution:
    """
    @param: head: The first node of linked list.
    @return: True if it has a cycle, or false
    """
    def hasCycle(self, head):
        # write your code here
        if not head:
           return   False
        fast=head
        slow=head
        
        while fast.next and fast.next.next:
            fast=fast.next.next
            slow=slow.next
            if fast==slow:
                return True
        return False
            
#103. Linked List Cycle II        
"""
Definition of ListNode
class ListNode(object):

    def __init__(self, val, next=None):
        self.val = val
        self.next = next
"""


class Solution:
    """
    @param: head: The first node of linked list.
    @return: The node where the cycle begins. if there is no cycle, return null
    """
    def detectCycle(self, head):
        # write your code here
        if not head or not head.next or not head.next.next:
            return None
#        fast=head.next.next
#        slow=head.next
        
        fast=head
        slow=head
        
        while fast and fast.next:
              fast=fast.next.next
              slow=slow.next
              if not fast or not fast.next:
                  return None
              if fast==slow:
                  break
        fast=head
        
        while True:
            fast=fast.next
            slow=slow.next
            if fast==slow:
                break
        return slow
            
        
       
    
-21->10->17->8->4->26->5    
head= ListNode(21)
head.next=ListNode(10)
head.next.next=ListNode(17) 
head.next.next.next=ListNode(8) 
head.next.next.next.next=ListNode(4) 
head.next.next.next.next.next=ListNode(26) 
head.next.next.next.next.next.next =ListNode(5)  

head.next.next.next.next.next.next.next=head2

->35>33->-7 -16->27->-12->6
head2= ListNode(35)
head2.next=ListNode(33)
head2.next.next=ListNode(7) 
head2.next.next.next=ListNode(16) 
head2.next.next.next.next=ListNode(27) 
head2.next.next.next.next.next=ListNode(12) 
head2.next.next.next.next.next.next =ListNode(6)
  
head2.next.next.next.next.next.next.next=head3

29- 12->5->9->20->14->14-
head3= ListNode(29)
head3.next=ListNode(12)
head3.next.next=ListNode(5) 
head3.next.next.next=ListNode(9) 
head3.next.next.next.next=ListNode(20) 
head3.next.next.next.next.next=ListNode(14) 
head3.next.next.next.next.next.next =ListNode(14)

head3.next.next.next.next.next.next.next=head4

2->13->-24->21->23->-21->5 
head4= ListNode(2)
head4.next=ListNode(13)
head4.next.next=ListNode(24) 
head4.next.next.next=ListNode(21) 
head4.next.next.next.next=ListNode(23) 
head4.next.next.next.next.next=ListNode(21) 
head4.next.next.next.next.next.next =ListNode(5)

head4.next.next.next.next.next.next.next= head4.next.next

-21->10->17->8->4->26->5
->35>33->-7 -16->27->-12->6
->29- 12->5->9->20->14->14-
>2->13->-24->21->23->-21->5 

if __name__ == "__main__":
    print(Solution().detectCycle(  head) )              
        
#104. Merge K Sorted Lists  
"""
Definition of ListNode
class ListNode(object):

    def __init__(self, val, next=None):
        self.val = val
        self.next = next
"""
import heapq
class Solution:
    """
    @param lists: a list of ListNode
    @return: The head of one sorted list.
    """
    def mergeKLists(self, lists):
        # write your code here   
        heap=[]
        for i,ll in  enumerate(lists):
            if ll:
                heapq.heappush(heap,(ll.val,i,ll))
        
        dummy=ListNode(-1)
        
        cur=dummy
        while heap:
            _,idx,node=heapq.heappop(heap)
            cur.next=node
            cur=cur.next
            if cur.next:
                heapq.heappush(heap,(cur.next.val,idx,cur.next))
        return dummy.next
                
#105. Copy List with Random Pointer             
"""
Definition for singly-linked list with a random pointer.
class RandomListNode:
    def __init__(self, x):
        self.label = x
        self.next = None
        self.random = None
"""


class Solution:
    # @param head: A RandomListNode
    # @return: A RandomListNode
    def copyRandomList(self, head):
        # write your code here
        if not head :
           return None


        root=   RandomListNode(head.label) 
        cur=head
        cur_copy=root
        while cur:
              if cur.next:
                  nextnode=RandomListNode(cur.next.label)
              else:
                  nextnode=None
              if cur.random:
                  nextrandom=RandomListNode(cur.random.label)
              else:
                  nextrandom=None
              
              cur_copy.next=  nextnode 
              cur_copy.random=  nextrandom
              cur=cur.next
              cur_copy=cur_copy.next
        return root
              
#106. Convert Sorted List to Binary Search Tree            
"""
Definition of ListNode
class ListNode(object):

    def __init__(self, val, next=None):
        self.val = val
        self.next = next

Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""


class Solution:
    """
    @param: head: The first node of linked list.
    @return: a tree node
    """
    def sortedListToBST(self, head):
        # write your code here 
        
        
        if not head:
            return None
        if not head.next:
            return TreeNode(head.val)
        
        fast=head.next.next
        slow=head
        
        while fast and fast.next:
            fast=fast.next.next
            slow=slow.next
        
        temp=slow.next
        slow.next=None
        
        root=TreeNode(temp.val)
        root.left=self.sortedListToBST(head)
        root.right=self.sortedListToBST(temp.next)
        return root
        
#107. Word Break            
class Solution:
    """
    @param: s: A string
    @param: dict: A dictionary of words dict
    @return: A boolean
    """
    def wordBreak(self, s, dict):
        # write your code here 
           
        if not s:
            return len(s)==0
        if not dict:
            return False
        n=len(s)
        dp=[False for _ in range(n+1)]
        dp[0]=True
        
        
        maxlen=max([len(w)  for w in dict])
        
        
        for i in range(n+1):
            for j in range(1,min(i,maxlen)+1):
                if not dp[i-j]:
                    continue
                if s[i-j:i]  in dict:
                    dp[i]=True
                    break
        return dp[n]
            

            
s = "lintcode"   
dict = ["lint", "code"]     
if __name__ == "__main__":
    print(Solution().wordBreak( s, dict))            
        
#108. Palindrome Partitioning II         
class Solution:
    """
    @param s: A string
    @return: An integer
    """
    def minCut(self, s):
        # write your code here
        n=len(s)
        
        dp=[i-1 for i in range(n+1)]
        
        for i in range(n+1):
            j=0
            k=1
            while i+j<n and i-j>=0 and s[i+j]==s[i-j]:
                dp[i+j+1]=min(dp[i+j+1],dp[i-j]+1)
                j+=1
            while i+k<n and i-k+1>=0 and s[i+k]==s[i-k+1]:
                dp[i+k+1]=min(dp[i+k+1],dp[i-k+1]+1)
                k+=1
        return dp[n]
s="aab"
s='bb'
if __name__ == "__main__":
    print(Solution().minCut(s))         
        
#109. Triangle         
class Solution:
    """
    @param triangle: a list of lists of integers
    @return: An integer, minimum path sum
    """
    def minimumTotal(self, triangle):
        # write your code here  
        n=len(triangle)
        dp=[[float('inf') for _ in range(n)] for _ in range(n)]
        dp[0][0]=triangle[0][0]
        
        for i in range(1,n):
            for j in range(i+1):
                
               if j==0:
                  dp[i][j] =dp[i-1][j]+ triangle[i][j]
               elif j==i:
                  dp[i][j]=dp[i-1][j-1]+ triangle[i][j]
               else:
                  dp[i][j]=min(dp[i-1][j-1],dp[i-1][j])+ triangle[i][j]
               
        #print(dp)
        return min(dp[n-1][i] for i in range(n))
  
triangle=[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
] 
triangle=[[-7],
 [-2,1],
 [-5,-5,9],
 [-4,-5,4,4],
 [-6,-6,2,-1,-5],
 [3,7,8,-3,7,-9],
 [-9,-1,-9,6,9,0,7],
 [-7,0,-6,-8,7,1,-4,9],
 [-3,2,-6,-9,-7,-6,-9,4,0],
 [-8,-6,-3,-9,-2,-6,7,-5,0,7],
 [-9,-1,-2,4,-2,4,4,-1,2,-5,5],
 [1,1,-6,1,-2,-4,4,-2,6,-6,0,6],
 [-3,-3,-6,-2,-6,-2,7,-9,-5,-7,-5,5,1]]       

if __name__ == "__main__":
    print(Solution().minimumTotal(triangle))        
        
#110. Minimum Path Sum        
class Solution:
    """
    @param grid: a list of lists of integers
    @return: An integer, minimizes the sum of all numbers along its path
    """
    def minPathSum(self, grid):
        # write your code here
        m=len(grid)
        n=len(grid[0])
        if not grid:
            return 0
        dp=[[float('inf') for _ in range(n)] for _ in range(m)]
        dp[0][0]=grid[0][0]
        for i in range(1,m):
            dp[i][0]=grid[i][0]+dp[i-1][0]
        for j in range(1,n):
            dp[0][j]=grid[0][j]+dp[0][j-1]
        #print(dp)    
        for i in range(1,m):
            for j in range(1,n):
                
                dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j]
        #print(dp)
        return dp[m-1][n-1]
        
grid=[[1,2],
      [1,1]]  
if __name__ == "__main__":
    print(Solution().minPathSum(grid))      
        
#111. Climbing Stairs        
class Solution:
    """
    @param n: An integer
    @return: An integer
    """
    def climbStairs(self, n):
        # write your code here   
        
        dp=[0 for _ in range(n+1)]
        if n==0:
            return 0
        dp[1]=1
        if n>1:
           dp[2]=2
        if n>2:
           dp[3]=3
        
        for i in range(4,n+1):
            print(dp[n])
            dp[i]+=dp[i-1]
            dp[i]+=dp[i-2]
        print(dp)
        return dp[n]
n=5    
if __name__ == "__main__":
    print(Solution().climbStairs( n))
        
#112. Remove Duplicates from Sorted List        
"""
Definition of ListNode
class ListNode(object):
    def __init__(self, val, next=None):
        self.val = val
        self.next = next
"""

class Solution:
    """
    @param head: head is the head of the linked list
    @return: head of linked list
    """
    def deleteDuplicates(self, head):
        # write your code here 
        
        if not head :
            return None
        head=cur
        
        while cur:
            while cur.next and  cur.val==cur.next.val:
                cur.next=cur.next.next
            cur=cur.next
        return head
#113. Remove Duplicates from Sorted List II                 
"""
Definition of ListNode
class ListNode(object):
    def __init__(self, val, next=None):
        self.val = val
        self.next = next
"""

class Solution:
    """
    @param head: head is the head of the linked list
    @return: head of the linked list
    """
    def deleteDuplicates(self, head):
        # write your code here            
        if not head:
            return None
      
        dummy=ListNode(float('inf'))
        dummy.next=head
        cur=dummy
        while cur:
            if cur and cur.next and cur.next.next and cur.next.next.val==cur.next.val  and cur.next.val !=cur.val:
               temp=cur.next
               while temp and temp.next and  temp.next.val==temp.val :
                     temp=temp.next
               cur.next=temp.next
           
               
            if cur.next and cur.next.next and cur.next.next.val==cur.next.val:
                 continue
            else:    
                 cur=cur.next
#        cur=dummy
#        while cur:
#            print(cur.val,sep=',',end='')
#            cur=cur.next
               
        return dummy.next
        
head=ListNode(1)
head.next=   ListNode(2) 
head.next.next=   ListNode(3) 
head.next.next.next=   ListNode(3) 
head.next.next.next.next=   ListNode(4)
head.next.next.next.next.next=   ListNode(4)   
head.next.next.next.next.next.next=   ListNode(5)  

0->1->1->2->3



head=ListNode(1)
head.next=   ListNode(1) 
head.next.next=   ListNode(1) 
head.next.next.next=   ListNode(2) 
head.next.next.next.next=   ListNode(3)


head=ListNode(1)
head.next=   ListNode(1) 
head.next.next=   ListNode(1) 
head.next.next.next=   ListNode(1) 
head.next.next.next.next=   ListNode(1)
head.next.next.next.next.next=   ListNode(2)   
head.next.next.next.next.next.next=   ListNode(2)  
head.next.next.next.next.next.next.next=   ListNode(2) 
head.next.next.next.next.next.next.next.next=   ListNode(2) 
head.next.next.next.next.next.next.next.next.next=   ListNode(2) 
      
        
Given 1->2->3->3->4->4->5, return 1->2->5.
Given 1->1->1->2->3, return 2->3.        
if __name__ == "__main__":
    print(Solution().deleteDuplicates( head))        
        
#114. Unique Paths  
class Solution:
    """
    @param m: positive integer (1 <= m <= 100)
    @param n: positive integer (1 <= n <= 100)
    @return: An integer
    """
    def uniquePaths(self, m, n):
        # write your code here
        
        dp=[[0 for _ in range(n)]  for _ in range(m)]
        
        for i in range(m):
            dp[i][0]=1
        for j in range(n):
            dp[0][j]=1
        
        for i in range(1,m):
            for j in range(1,n):
                dp[i][j]+=dp[i-1][j]
                dp[i][j]+=dp[i][j-1]
        return dp[m-1][n-1]
m = 4 
n = 5
m = 3 
n = 3                
if __name__ == "__main__":
    print(Solution().uniquePaths( m, n))              
            
#115. Unique Paths II         
class Solution:
    """
    @param obstacleGrid: A list of lists of integers
    @return: An integer
    """
    def uniquePathsWithObstacles(self, obstacleGrid):
        # write your code here  
        if not obstacleGrid:
            return 0
        
        m=len(obstacleGrid)
        n=len(obstacleGrid[0])
        dp=[[0 for _ in range(n)]  for _ in range(m)]
        for i in range(m):
            if obstacleGrid[i][0]==0:
               dp[i][0]=1
            else:
                break
        for j in range(n):
            if obstacleGrid[0][j]==0:
               dp[0][j]=1
            else:
                break
        
        for i in range(1,m):
            for j in range(1,n):
                if obstacleGrid[i][j]!=1:
                    dp[i][j]+=dp[i-1][j]
                    dp[i][j]+=dp[i][j-1]
                
        return dp[m-1][n-1]
obstacleGrid=[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]        
if __name__ == "__main__":
    print(Solution().uniquePathsWithObstacles( obstacleGrid))             
        
#116. Jump Game   
class Solution:
    """
    @param A: A list of integers
    @return: A boolean
    """
    def canJump(self, A):
        # write your code here
        if not A:
            return False
        
       
        m=len(A)
        if m==1:
            return True
       
        
        dp=[False for _ in range(m)]
        
        if A[0]>0:
            dp[0]=True
        
        for i in range(m):
            for j in range(1,A[i]+1):
                if dp[i] and i+j < m:
                    dp[i+j]=True
        return dp[m-1]
        
 
        
A = [2,3,1,1,4], return true.

A = [3,2,1,0,4], return false.     
if __name__ == "__main__":
    print(Solution().canJump( A))          
        
#117. Jump Game II        
class Solution:
    """
    @param A: A list of integers
    @return: An integer
    """
    def jump(self, A):
        # write your code here
#        if not A:
#            return False
#        m=len(A)
#        if m==1:
#            return True
#        dp=[float('inf') for _ in range(m)]
#        dp[0]=0
#        for i in range(m):
#            for j in range(1,A[i]+1):
#                if i+j < m:
#                    dp[i+j]=min(dp[i]+1,dp[i+j])
#        return dp[m-1]
        
        m=len(A)
        if m==1:
            return 0
        maxreach=A[0]+0
        step=1
        i=0
        
        while  maxreach <m-1:
               step+=1
               for j in range(i+1,A[i]+i+1):
                   if A[j]+j>maxreach:
                       maxreach= A[j]+j
                       temp=j
                i=temp
        return step
 
A = [2,3,1,1,4]

if __name__ == "__main__":
    print(Solution().jump( A))          
        
The minimum number of jumps to reach the last index is 2. 
(Jump 1 step from index 0 to 1, then 3 steps to the last index        
        
#118. Distinct Subsequences         
class Solution:
    """
    @param: : A string
    @param: : A string
    @return: Count the number of distinct subsequences
    """

    def numDistinct(self, S, T):
        # write your code here
        #看leetcode的描述更清晰
        #给出字符串S和字符串T，计算S的不同的子序列中T出现的个数。
        m=len(T)
        n=len(S)
        
        dp=[[0 for _ in range(n+1)] for _ in range(m+1)]
        
        for j in range(n+1):
            dp[0][j]=1
        
        for i in range(m):
            for j in range(n):
                if T[i]==S[j]:
                    dp[i+1][j+1]=dp[i+1][j]+dp[i][j]
                else:
                    dp[i+1][j+1]=dp[i+1][j]
        return dp[m][n]
               *  * ]
#      S = [acdabefbc]
#mem[1] = [0111222222]
#mem[2] = [0000022244]        

S = "rabbbit"
T = "rabbit"  
if __name__ == "__main__":
    print(Solution().numDistinct( S, T))          
        
#119. Edit Distance             
class Solution:
    """
    @param word1: A string
    @param word2: A string
    @return: The minimum number of steps.
    """
    def minDistance(self, word1, word2):
        # write your code here
        #看leetcode的描述更清晰
        m=len(word1)
        n=len(word2)
        
        dp=[[0 for _ in range(n+1)]for _ in range(m+1)]
        
        for i in range(m+1):
            dp[i][0]=i
        for j in range(n+1):
            dp[0][j]=j
            
        for i in range(1,m+1):
            for j in range(1,n+1):
                if word1[i-1]==word2[j-1]:
                    dp[i][j]=dp[i-1][j-1]
                else:
                    dp[i][j]=min(dp[i-1][j-1]+1,dp[i-1][j]+1,dp[i][j-1]+1)
        return dp[m][n]
word1 = "horse"
word2 = "ros"  
word1 = "intention"
word2 = "execution"          
if __name__ == "__main__":
    print(Solution().minDistance( word1, word2))        
        
        
#120. Word Ladder        
class Solution:
    """
    @param: start: a string
    @param: end: a string
    @param: dict: a set of string
    @return: An integer
    """
    def ladderLength(self, start, end, dict):
        # write your code here
        #看leetcode的描述更清晰
        
       
        import string 
        dic=set(dict)
        dic.add(end)
        dic.add(start)
        
        from collections import deque
      
        q=deque([(start,1)])
       
    
        while q:
            word,step=q.popleft()
           
            if word==end:
                return step
            
            for j in range(len(start)):
                    for k in string.ascii_lowercase:
                        if word[j] !=k:
                            nextword=word[:j]+k+word[j+1:]
                            if nextword in dic:
                                q.append((nextword,step+1))
                                dic.remove(nextword)
                                
                
                    
        return 0
                
                
            
             
        
start = "hit"
end = "cog"
dict = ["hot","dot","dog","lot","log"]   

start ="sand"     
end =       "acne" 

dict =["slit","bunk","wars","ping","viva","wynn","wows","irks","gang","pool","mock","fort","heel","send","ship","cols","alec","foal","nabs","gaze","giza","mays","dogs","karo","cums","jedi","webb","lend","mire","jose","catt","grow","toss","magi","leis","bead","kara","hoof","than","ires","baas","vein","kari","riga","oars","gags","thug","yawn","wive","view","germ","flab","july","tuck","rory","bean","feed","rhee","jeez","gobs","lath","desk","yoko","cute","zeus","thus","dims","link","dirt","mara","disc","limy","lewd","maud","duly","elsa","hart","rays","rues","camp","lack","okra","tome","math","plug","monk","orly","friz","hogs","yoda","poop","tick","plod","cloy","pees","imps","lead","pope","mall","frey","been","plea","poll","male","teak","soho","glob","bell","mary","hail","scan","yips","like","mull","kory","odor","byte","kaye","word","honk","asks","slid","hopi","toke","gore","flew","tins","mown","oise","hall","vega","sing","fool","boat","bobs","lain","soft","hard","rots","sees","apex","chan","told","woos","unit","scow","gilt","beef","jars","tyre","imus","neon","soap","dabs","rein","ovid","hose","husk","loll","asia","cope","tail","hazy","clad","lash","sags","moll","eddy","fuel","lift","flog","land","sigh","saks","sail","hook","visa","tier","maws","roeg","gila","eyes","noah","hypo","tore","eggs","rove","chap","room","wait","lurk","race","host","dada","lola","gabs","sobs","joel","keck","axed","mead","gust","laid","ends","oort","nose","peer","kept","abet","iran","mick","dead","hags","tens","gown","sick","odis","miro","bill","fawn","sumo","kilt","huge","ores","oran","flag","tost","seth","sift","poet","reds","pips","cape","togo","wale","limn","toll","ploy","inns","snag","hoes","jerk","flux","fido","zane","arab","gamy","raze","lank","hurt","rail","hind","hoot","dogy","away","pest","hoed","pose","lose","pole","alva","dino","kind","clan","dips","soup","veto","edna","damp","gush","amen","wits","pubs","fuzz","cash","pine","trod","gunk","nude","lost","rite","cory","walt","mica","cart","avow","wind","book","leon","life","bang","draw","leek","skis","dram","ripe","mine","urea","tiff","over","gale","weir","defy","norm","tull","whiz","gill","ward","crag","when","mill","firs","sans","flue","reid","ekes","jain","mutt","hems","laps","piss","pall","rowe","prey","cull","knew","size","wets","hurl","wont","suva","girt","prys","prow","warn","naps","gong","thru","livy","boar","sade","amok","vice","slat","emir","jade","karl","loyd","cerf","bess","loss","rums","lats","bode","subs","muss","maim","kits","thin","york","punt","gays","alpo","aids","drag","eras","mats","pyre","clot","step","oath","lout","wary","carp","hums","tang","pout","whip","fled","omar","such","kano","jake","stan","loop","fuss","mini","byrd","exit","fizz","lire","emil","prop","noes","awed","gift","soli","sale","gage","orin","slur","limp","saar","arks","mast","gnat","port","into","geed","pave","awls","cent","cunt","full","dint","hank","mate","coin","tars","scud","veer","coax","bops","uris","loom","shod","crib","lids","drys","fish","edit","dick","erna","else","hahs","alga","moho","wire","fora","tums","ruth","bets","duns","mold","mush","swop","ruby","bolt","nave","kite","ahem","brad","tern","nips","whew","bait","ooze","gino","yuck","drum","shoe","lobe","dusk","cult","paws","anew","dado","nook","half","lams","rich","cato","java","kemp","vain","fees","sham","auks","gish","fire","elam","salt","sour","loth","whit","yogi","shes","scam","yous","lucy","inez","geld","whig","thee","kelp","loaf","harm","tomb","ever","airs","page","laud","stun","paid","goop","cobs","judy","grab","doha","crew","item","fogs","tong","blip","vest","bran","wend","bawl","feel","jets","mixt","tell","dire","devi","milo","deng","yews","weak","mark","doug","fare","rigs","poke","hies","sian","suez","quip","kens","lass","zips","elva","brat","cosy","teri","hull","spun","russ","pupa","weed","pulp","main","grim","hone","cord","barf","olav","gaps","rote","wilt","lars","roll","balm","jana","give","eire","faun","suck","kegs","nita","weer","tush","spry","loge","nays","heir","dope","roar","peep","nags","ates","bane","seas","sign","fred","they","lien","kiev","fops","said","lawn","lind","miff","mass","trig","sins","furl","ruin","sent","cray","maya","clog","puns","silk","axis","grog","jots","dyer","mope","rand","vend","keen","chou","dose","rain","eats","sped","maui","evan","time","todd","skit","lief","sops","outs","moot","faze","biro","gook","fill","oval","skew","veil","born","slob","hyde","twin","eloy","beat","ergs","sure","kobe","eggo","hens","jive","flax","mons","dunk","yest","begs","dial","lodz","burp","pile","much","dock","rene","sago","racy","have","yalu","glow","move","peps","hods","kins","salk","hand","cons","dare","myra","sega","type","mari","pelt","hula","gulf","jugs","flay","fest","spat","toms","zeno","taps","deny","swag","afro","baud","jabs","smut","egos","lara","toes","song","fray","luis","brut","olen","mere","ruff","slum","glad","buds","silt","rued","gelt","hive","teem","ides","sink","ands","wisp","omen","lyre","yuks","curb","loam","darn","liar","pugs","pane","carl","sang","scar","zeds","claw","berg","hits","mile","lite","khan","erik","slug","loon","dena","ruse","talk","tusk","gaol","tads","beds","sock","howe","gave","snob","ahab","part","meir","jell","stir","tels","spit","hash","omit","jinx","lyra","puck","laue","beep","eros","owed","cede","brew","slue","mitt","jest","lynx","wads","gena","dank","volt","gray","pony","veld","bask","fens","argo","work","taxi","afar","boon","lube","pass","lazy","mist","blot","mach","poky","rams","sits","rend","dome","pray","duck","hers","lure","keep","gory","chat","runt","jams","lays","posy","bats","hoff","rock","keri","raul","yves","lama","ramp","vote","jody","pock","gist","sass","iago","coos","rank","lowe","vows","koch","taco","jinn","juno","rape","band","aces","goal","huck","lila","tuft","swan","blab","leda","gems","hide","tack","porn","scum","frat","plum","duds","shad","arms","pare","chin","gain","knee","foot","line","dove","vera","jays","fund","reno","skid","boys","corn","gwyn","sash","weld","ruiz","dior","jess","leaf","pars","cote","zing","scat","nice","dart","only","owls","hike","trey","whys","ding","klan","ross","barb","ants","lean","dopy","hock","tour","grip","aldo","whim","prom","rear","dins","duff","dell","loch","lava","sung","yank","thar","curl","venn","blow","pomp","heat","trap","dali","nets","seen","gash","twig","dads","emmy","rhea","navy","haws","mite","bows","alas","ives","play","soon","doll","chum","ajar","foam","call","puke","kris","wily","came","ales","reef","raid","diet","prod","prut","loot","soar","coed","celt","seam","dray","lump","jags","nods","sole","kink","peso","howl","cost","tsar","uric","sore","woes","sewn","sake","cask","caps","burl","tame","bulk","neva","from","meet","webs","spar","fuck","buoy","wept","west","dual","pica","sold","seed","gads","riff","neck","deed","rudy","drop","vale","flit","romp","peak","jape","jews","fain","dens","hugo","elba","mink","town","clam","feud","fern","dung","newt","mime","deem","inti","gigs","sosa","lope","lard","cara","smug","lego","flex","doth","paar","moon","wren","tale","kant","eels","muck","toga","zens","lops","duet","coil","gall","teal","glib","muir","ails","boer","them","rake","conn","neat","frog","trip","coma","must","mono","lira","craw","sled","wear","toby","reel","hips","nate","pump","mont","died","moss","lair","jibe","oils","pied","hobs","cads","haze","muse","cogs","figs","cues","roes","whet","boru","cozy","amos","tans","news","hake","cots","boas","tutu","wavy","pipe","typo","albs","boom","dyke","wail","woke","ware","rita","fail","slab","owes","jane","rack","hell","lags","mend","mask","hume","wane","acne","team","holy","runs","exes","dole","trim","zola","trek","puma","wacs","veep","yaps","sums","lush","tubs","most","witt","bong","rule","hear","awry","sots","nils","bash","gasp","inch","pens","fies","juts","pate","vine","zulu","this","bare","veal","josh","reek","ours","cowl","club","farm","teat","coat","dish","fore","weft","exam","vlad","floe","beak","lane","ella","warp","goth","ming","pits","rent","tito","wish","amps","says","hawk","ways","punk","nark","cagy","east","paul","bose","solo","teed","text","hews","snip","lips","emit","orgy","icon","tuna","soul","kurd","clod","calk","aunt","bake","copy","acid","duse","kiln","spec","fans","bani","irma","pads","batu","logo","pack","oder","atop","funk","gide","bede","bibs","taut","guns","dana","puff","lyme","flat","lake","june","sets","gull","hops","earn","clip","fell","kama","seal","diaz","cite","chew","cuba","bury","yard","bank","byes","apia","cree","nosh","judo","walk","tape","taro","boot","cods","lade","cong","deft","slim","jeri","rile","park","aeon","fact","slow","goff","cane","earp","tart","does","acts","hope","cant","buts","shin","dude","ergo","mode","gene","lept","chen","beta","eden","pang","saab","fang","whir","cove","perk","fads","rugs","herb","putt","nous","vane","corm","stay","bids","vela","roof","isms","sics","gone","swum","wiry","cram","rink","pert","heap","sikh","dais","cell","peel","nuke","buss","rasp","none","slut","bent","dams","serb","dork","bays","kale","cora","wake","welt","rind","trot","sloe","pity","rout","eves","fats","furs","pogo","beth","hued","edam","iamb","glee","lute","keel","airy","easy","tire","rube","bogy","sine","chop","rood","elbe","mike","garb","jill","gaul","chit","dons","bars","ride","beck","toad","make","head","suds","pike","snot","swat","peed","same","gaza","lent","gait","gael","elks","hang","nerf","rosy","shut","glop","pain","dion","deaf","hero","doer","wost","wage","wash","pats","narc","ions","dice","quay","vied","eons","case","pour","urns","reva","rags","aden","bone","rang","aura","iraq","toot","rome","hals","megs","pond","john","yeps","pawl","warm","bird","tint","jowl","gibe","come","hold","pail","wipe","bike","rips","eery","kent","hims","inks","fink","mott","ices","macy","serf","keys","tarp","cops","sods","feet","tear","benz","buys","colo","boil","sews","enos","watt","pull","brag","cork","save","mint","feat","jamb","rubs","roxy","toys","nosy","yowl","tamp","lobs","foul","doom","sown","pigs","hemp","fame","boor","cube","tops","loco","lads","eyre","alta","aged","flop","pram","lesa","sawn","plow","aral","load","lied","pled","boob","bert","rows","zits","rick","hint","dido","fist","marc","wuss","node","smog","nora","shim","glut","bale","perl","what","tort","meek","brie","bind","cake","psst","dour","jove","tree","chip","stud","thou","mobs","sows","opts","diva","perm","wise","cuds","sols","alan","mild","pure","gail","wins","offs","nile","yelp","minn","tors","tran","homy","sadr","erse","nero","scab","finn","mich","turd","then","poem","noun","oxus","brow","door","saws","eben","wart","wand","rosa","left","lina","cabs","rapt","olin","suet","kalb","mans","dawn","riel","temp","chug","peal","drew","null","hath","many","took","fond","gate","sate","leak","zany","vans","mart","hess","home","long","dirk","bile","lace","moog","axes","zone","fork","duct","rico","rife","deep","tiny","hugh","bilk","waft","swig","pans","with","kern","busy","film","lulu","king","lord","veda","tray","legs","soot","ells","wasp","hunt","earl","ouch","diem","yell","pegs","blvd","polk","soda","zorn","liza","slop","week","kill","rusk","eric","sump","haul","rims","crop","blob","face","bins","read","care","pele","ritz","beau","golf","drip","dike","stab","jibs","hove","junk","hoax","tats","fief","quad","peat","ream","hats","root","flak","grit","clap","pugh","bosh","lock","mute","crow","iced","lisa","bela","fems","oxes","vies","gybe","huff","bull","cuss","sunk","pups","fobs","turf","sect","atom","debt","sane","writ","anon","mayo","aria","seer","thor","brim","gawk","jack","jazz","menu","yolk","surf","libs","lets","bans","toil","open","aced","poor","mess","wham","fran","gina","dote","love","mood","pale","reps","ines","shot","alar","twit","site","dill","yoga","sear","vamp","abel","lieu","cuff","orbs","rose","tank","gape","guam","adar","vole","your","dean","dear","hebe","crab","hump","mole","vase","rode","dash","sera","balk","lela","inca","gaea","bush","loud","pies","aide","blew","mien","side","kerr","ring","tess","prep","rant","lugs","hobo","joke","odds","yule","aida","true","pone","lode","nona","weep","coda","elmo","skim","wink","bras","pier","bung","pets","tabs","ryan","jock","body","sofa","joey","zion","mace","kick","vile","leno","bali","fart","that","redo","ills","jogs","pent","drub","slaw","tide","lena","seep","gyps","wave","amid","fear","ties","flan","wimp","kali","shun","crap","sage","rune","logs","cain","digs","abut","obit","paps","rids","fair","hack","huns","road","caws","curt","jute","fisk","fowl","duty","holt","miss","rude","vito","baal","ural","mann","mind","belt","clem","last","musk","roam","abed","days","bore","fuze","fall","pict","dump","dies","fiat","vent","pork","eyed","docs","rive","spas","rope","ariz","tout","game","jump","blur","anti","lisp","turn","sand","food","moos","hoop","saul","arch","fury","rise","diss","hubs","burs","grid","ilks","suns","flea","soil","lung","want","nola","fins","thud","kidd","juan","heps","nape","rash","burt","bump","tots","brit","mums","bole","shah","tees","skip","limb","umps","ache","arcs","raft","halo","luce","bahs","leta","conk","duos","siva","went","peek","sulk","reap","free","dubs","lang","toto","hasp","ball","rats","nair","myst","wang","snug","nash","laos","ante","opal","tina","pore","bite","haas","myth","yugo","foci","dent","bade","pear","mods","auto","shop","etch","lyly","curs","aron","slew","tyro","sack","wade","clio","gyro","butt","icky","char","itch","halt","gals","yang","tend","pact","bees","suit","puny","hows","nina","brno","oops","lick","sons","kilo","bust","nome","mona","dull","join","hour","papa","stag","bern","wove","lull","slip","laze","roil","alto","bath","buck","alma","anus","evil","dumb","oreo","rare","near","cure","isis","hill","kyle","pace","comb","nits","flip","clop","mort","thea","wall","kiel","judd","coop","dave","very","amie","blah","flub","talc","bold","fogy","idea","prof","horn","shoo","aped","pins","helm","wees","beer","womb","clue","alba","aloe","fine","bard","limo","shaw","pint","swim","dust","indy","hale","cats","troy","wens","luke","vern","deli","both","brig","daub","sara","sued","bier","noel","olga","dupe","look","pisa","knox","murk","dame","matt","gold","jame","toge","luck","peck","tass","calf","pill","wore","wadi","thur","parr","maul","tzar","ones","lees","dark","fake","bast","zoom","here","moro","wine","bums","cows","jean","palm","fume","plop","help","tuba","leap","cans","back","avid","lice","lust","polo","dory","stew","kate","rama","coke","bled","mugs","ajax","arts","drug","pena","cody","hole","sean","deck","guts","kong","bate","pitt","como","lyle","siam","rook","baby","jigs","bret","bark","lori","reba","sups","made","buzz","gnaw","alps","clay","post","viol","dina","card","lana","doff","yups","tons","live","kids","pair","yawl","name","oven","sirs","gyms","prig","down","leos","noon","nibs","cook","safe","cobb","raja","awes","sari","nerd","fold","lots","pete","deal","bias","zeal","girl","rage","cool","gout","whey","soak","thaw","bear","wing","nagy","well","oink","sven","kurt","etna","held","wood","high","feta","twee","ford","cave","knot","tory","ibis","yaks","vets","foxy","sank","cone","pius","tall","seem","wool","flap","gird","lore","coot","mewl","sere","real","puts","sell","nuts","foil","lilt","saga","heft","dyed","goat","spew","daze","frye","adds","glen","tojo","pixy","gobi","stop","tile","hiss","shed","hahn","baku","ahas","sill","swap","also","carr","manx","lime","debs","moat","eked","bola","pods","coon","lacy","tube","minx","buff","pres","clew","gaff","flee","burn","whom","cola","fret","purl","wick","wigs","donn","guys","toni","oxen","wite","vial","spam","huts","vats","lima","core","eula","thad","peon","erie","oats","boyd","cued","olaf","tams","secs","urey","wile","penn","bred","rill","vary","sues","mail","feds","aves","code","beam","reed","neil","hark","pols","gris","gods","mesa","test","coup","heed","dora","hied","tune","doze","pews","oaks","bloc","tips","maid","goof","four","woof","silo","bray","zest","kiss","yong","file","hilt","iris","tuns","lily","ears","pant","jury","taft","data","gild","pick","kook","colt","bohr","anal","asps","babe","bach","mash","biko","bowl","huey","jilt","goes","guff","bend","nike","tami","gosh","tike","gees","urge","path","bony","jude","lynn","lois","teas","dunn","elul","bonn","moms","bugs","slay","yeah","loan","hulk","lows","damn","nell","jung","avis","mane","waco","loin","knob","tyke","anna","hire","luau","tidy","nuns","pots","quid","exec","hans","hera","hush","shag","scot","moan","wald","ursa","lorn","hunk","loft","yore","alum","mows","slog","emma","spud","rice","worn","erma","need","bags","lark","kirk","pooh","dyes","area","dime","luvs","foch","refs","cast","alit","tugs","even","role","toed","caph","nigh","sony","bide","robs","folk","daft","past","blue","flaw","sana","fits","barr","riot","dots","lamp","cock","fibs","harp","tent","hate","mali","togs","gear","tues","bass","pros","numb","emus","hare","fate","wife","mean","pink","dune","ares","dine","oily","tony","czar","spay","push","glum","till","moth","glue","dive","scad","pops","woks","andy","leah","cusp","hair","alex","vibe","bulb","boll","firm","joys","tara","cole","levy","owen","chow","rump","jail","lapp","beet","slap","kith","more","maps","bond","hick","opus","rust","wist","shat","phil","snow","lott","lora","cary","mote","rift","oust","klee","goad","pith","heep","lupe","ivan","mimi","bald","fuse","cuts","lens","leer","eyry","know","razz","tare","pals","geek","greg","teen","clef","wags","weal","each","haft","nova","waif","rate","katy","yale","dale","leas","axum","quiz","pawn","fend","capt","laws","city","chad","coal","nail","zaps","sort","loci","less","spur","note","foes","fags","gulp","snap","bogs","wrap","dane","melt","ease","felt","shea","calm","star","swam","aery","year","plan","odin","curd","mira","mops","shit","davy","apes","inky","hues","lome","bits","vila","show","best","mice","gins","next","roan","ymir","mars","oman","wild","heal","plus","erin","rave","robe","fast","hutu","aver","jodi","alms","yams","zero","revs","wean","chic","self","jeep","jobs","waxy","duel","seek","spot","raps","pimp","adan","slam","tool","morn","futz","ewes","errs","knit","rung","kans","muff","huhs","tows","lest","meal","azov","gnus","agar","sips","sway","otis","tone","tate","epic","trio","tics","fade","lear","owns","robt","weds","five","lyon","terr","arno","mama","grey","disk","sept","sire","bart","saps","whoa","turk","stow","pyle","joni","zinc","negs","task","leif","ribs","malt","nine","bunt","grin","dona","nope","hams","some","molt","smit","sacs","joan","slav","lady","base","heck","list","take","herd","will","nubs","burg","hugs","peru","coif","zoos","nick","idol","levi","grub","roth","adam","elma","tags","tote","yaws","cali","mete","lula","cubs","prim","luna","jolt","span","pita","dodo","puss","deer","term","dolt","goon","gary","yarn","aims","just","rena","tine","cyst","meld","loki","wong","were","hung","maze","arid","cars","wolf","marx","faye","eave","raga","flow","neal","lone","anne","cage","tied","tilt","soto","opel","date","buns","dorm","kane","akin","ewer","drab","thai","jeer","grad","berm","rods","saki","grus","vast","late","lint","mule","risk","labs","snit","gala","find","spin","ired","slot","oafs","lies","mews","wino","milk","bout","onus","tram","jaws","peas","cleo","seat","gums","cold","vang","dewy","hood","rush","mack","yuan","odes","boos","jami","mare","plot","swab","borg","hays","form","mesh","mani","fife","good","gram","lion","myna","moor","skin","posh","burr","rime","done","ruts","pays","stem","ting","arty","slag","iron","ayes","stub","oral","gets","chid","yens","snub","ages","wide","bail","verb","lamb","bomb","army","yoke","gels","tits","bork","mils","nary","barn","hype","odom","avon","hewn","rios","cams","tact","boss","oleo","duke","eris","gwen","elms","deon","sims","quit","nest","font","dues","yeas","zeta","bevy","gent","torn","cups","worm","baum","axon","purr","vise","grew","govs","meat","chef","rest","lame"]  
if __name__ == "__main__":
    print(Solution().ladderLength(start, end, dict))                
      
#121. Word Ladder II 
from  collections import defaultdict, deque
import string 
 
class Solution:
    """
    @param: start: a string
    @param: end: a string
    @param: dict: a set of string
    @return: a list of lists of string
    """
    def findLadders(self, start, end, dict):
        # write your code here
#        使用BFS去計算每個字變成終點的字的距離(step of transformation)，並且用Hash Map去記錄著
#同時也用Hash Map記錄著每個字跟他的鄰居們(next word)
#
#在用DFS去遍歷，從起點到終點，同時只選擇那些下一個字的距離是目前字的距離的少1
        
        dict.add(start)
        dict.add(end)
        distance=  defaultdict(int) 
        graph=defaultdict(list) 
        
        for word in dict:
            for j in range(len(word)):
                for k in string.ascii_lowercase:
                    nextword=word[:j]+k+word[j+1:]
                    if word[j]!=k  and nextword in dict:
                        graph[word]+=[nextword]
        
                        
        
        
        
        
        def bfs(start, end, dict, distance,graph):
            q=deque([end])
            visited=set([end])
            step=0
            
            while q:
               n=len(q)
                
               for _ in range(n):
                    word=q.popleft()
                    distance[word]=step
                    for nextword in  graph[word]:
                        if nextword not in visited:
                            visited.add(nextword)
                            q.append(nextword)
                            
               step+=1
            
                
                    
        def dfs(cur_word, end, path, distance,graph,res):
            if cur_word==end:
                path.append(cur_word)
                res.append(path+[])
                path.pop()
                return 
                
                 
            
            for next_word in graph[cur_word]:
                    if distance[next_word] +1==distance[cur_word]:
                        path+=[cur_word]
                        dfs(next_word, end, path, distance,graph,res)
                        path.pop()
        
        res=[] 
        bfs(start, end, dict, distance,graph)
        #print(distance)
        #print(graph)              
        dfs(start, end, [], distance,graph,res)  
        return res
 

start = "hit"
end = "cog"
dict = set(["hot","dot","dog","lot","log"])
Return
  [
    ["hit","hot","dot","dog","cog"],
    ["hit","hot","lot","log","cog"]
  ]
start = "qa"
end = "sq"
dict =["si","go","se","cm","so","ph","mt","db","mb","sb","kr","ln","tm","le","av","sm","ar","ci","ca","br","ti","ba","to","ra","fa","yo","ow","sn","ya","cr","po","fe","ho","ma","re","or","rn","au","ur","rh","sr","tc","lt","lo","as","fr","nb","yb","if","pb","ge","th","pm","rb","sh","co","ga","li","ha","hz","no","bi","di","hi","qa","pi","os","uh","wm","an","me","mo","na","la","st","er","sc","ne","mn","mi","am","ex","pt","io","be","fm","ta","tb","ni","mr","pa","he","lr","sq","ye"]  
  
if __name__ == "__main__":
    print(Solution().findLadders( start, end, dict))


#122. Largest Rectangle in Histogram
class Solution:
    """
    @param height: A list of integer
    @return: The area of largest rectangle in the histogram
    """
    def largestRectangleArea(self, height):
        # write your code here
        stack=[-1]
        height.append(0)
        
        ans=0
        for i in range(len(height)):
            while height[i]<height[stack[-1]]:
                h=height[stack.pop()]
                w=i-stack[-1]-1
                ans=max(ans,h*w)
            stack.append(i)
        return ans
height = [2,1,5,6,2,3]
if __name__ == "__main__":
    print(Solution().largestRectangleArea( height))


#123. Word Search
class Solution:
    """
    @param board: A list of lists of character
    @param word: A string
    @return: A boolean
    """
    def exist(self, board, word):
        # write your code here
        
        def find(board,i,x,y):
            if i==len(word):
                return True
            if x<0 or y < 0 or x>=len(board) or y>=len(board[0]):
                return False
            if board[x][y]!=word[i]:
                return False
            else:
                temp=board[x][y]
                board[x][y]='#'
                if find(board,i+1,x-1,y) or find(board,i+1,x+1,y) or find(board,i+1,x,y-1) or find(board,i+1,x,y+1):
                    return True
                else:
                    board[x][y]=temp 
                    return False
               
                
                
        
        for x in range(len(board)):
                for y in range(len(board[0])):
                  if find(board,0,x,y):
                      return True
        return False
                      
   
                            

board =[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]

word = "ABCCED", return true.
word = "SEE", return true.
word = "ABCB", return false.

board2=[]
for row in board:
    board2.append(list(row))
    
    
board =["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa","aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa","aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa","aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa","aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa","aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa","aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa","aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa","aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa","aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa","aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa","aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa","aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa","aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa","aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa","aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa","aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa","aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa","aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa","aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa","aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa","aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa","aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa","aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa","aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa","aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa","aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa","aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa","aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa","aaaaaaaaaaaaaaaaaaaaaaaaaaaaab"]
word ="baaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
board2=[]
for row in board:
    board2.append(list(row))

board=board2

if __name__ == "__main__":
    print(Solution().exist( board, word))

#124. Longest Consecutive Sequence
class Solution:
    """
    @param num: A list of integers
    @return: An integer
    """
    def longestConsecutive(self, num):
        # write your code here
        dic={}
        
        for x in num:
            dic[x]=1
        ans=0
        for x in num:
            if x in dic:
                length=1
                left=x-1
                right=x+1
                del dic[x]
                while left in dic:
                    del dic[left]
                    #print(left)
                    left-=1
                    length+=1
                    #print(left,length)
                while right in dic:
                    del dic[right]
                    right+=1
                    length+=1
            if ans < length:
                    ans=length
        return ans
        
num=    [100, 4, 200, 1, 3, 2]
if __name__ == "__main__":
    print(Solution().longestConsecutive( num))
    
    
    
    
#125. Backpack II
class Solution:
    """
    @param m: An integer m denotes the size of a backpack
    @param A: Given n items with size A[i]
    @param V: Given n items with value V[i]
    @return: The maximum value
    """
    def backPackII(self, m, A, V):
        # write your code here
        #用子问题定义状态：即f[i][v]表示前 i 件物品恰放入一个容量为 j 的背包可以获得的最大价值。
#        item=[]
#        for size,value in zip(A,V):
#            item.append((size,value))
#        item.sort(key= lambda x: (-x[1],x[0])  )
#        sofar=0
#        self.res=0
#        def search(m,item,sofar):
#            if self.res<sofar:
#                self.res=sofar
#            if not item:
#                return 
#            for   i,itm in enumerate(item):
#                  s,v=itm
#                  if m-s>=0:
#                      search(m-s,item[:i]+item[i+1:],sofar+v)
#        search(m,item,sofar)
#        return  self.res    
        n=len(A)
        dp=[[0 for _ in range(m+1)] for _ in range(n+1)]
        
        for i in range(1,n+1):
            for j in range(1,m+1):
                if j<A[i-1]:
                    dp[i][j]=dp[i-1][j]
                else:
                    dp[i][j]=max(dp[i-1][j],dp[i-1][j-A[i-1]]+V[i-1])
        return dp[n][m]
    
A=[2, 3, 5, 7]
V= [1, 5, 2, 4]    
m=10 
m=1000
A=[71,34,82,23,1,88,12,57,10,68,5,33,37,69,98,24,26,83,16,26,18,43,52,71,22,65,68,8,40,40,24,72,16,34,10,19,28,13,34,98,29,31,79,33,60,74,44,56,54,17,63,83,100,54,10,5,79,42,65,93,52,64,85,68,54,62,29,40,35,90,47,77,87,75,39,18,38,25,61,13,36,53,46,28,44,34,39,69,42,97,34,83,8,74,38,74,22,40,7,94]
V=[26,59,30,19,66,85,94,8,3,44,5,1,41,82,76,1,12,81,73,32,74,54,62,41,19,10,65,53,56,53,70,66,58,22,72,33,96,88,68,45,44,61,78,78,6,66,11,59,83,48,52,7,51,37,89,72,23,52,55,44,57,45,11,90,31,38,48,75,56,64,73,66,35,50,16,51,33,58,85,77,71,87,69,52,10,13,39,75,38,13,90,35,83,93,61,62,95,73,26,85]                
if __name__ == "__main__":
    print(Solution().backPackII( m, A, V))            
    
    
#127. Topological Sorting 
"""
Definition for a Directed graph node
class DirectedGraphNode:
    def __init__(self, x):
        self.label = x
        self.neighbors = []
"""


class Solution:
    """
    @param: graph: A list of Directed graph node
    @return: Any topological order for the given graph.
    """
    def topSort(self, graph):
        # write your code here
        def topSort(self, graph):
        # write your code here
        def dfs(i,counter,ans):
            ans.append(i)
            counter[i]-=1
            for j in i.neighbors:
                counter[j]-=1
                if counter[j]==0 :
                   dfs(j,counter,ans)
        counter={}
        ans=[]
        for i in graph:
            counter[i]=0
        for i in graph:
            for j in i.neighbors:
                counter[j]=counter[j]+1
        
        
        for i in graph:
            if counter[i]==0 :
                dfs(i,counter,ans)
        return ans
                
if __name__ == "__main__":
    print(Solution().topSort(graph))            
                    
#128. Hash Function    
class Solution:
    """
    @param key: A string you should hash
    @param HASH_SIZE: An integer
    @return: An integer
    """
    def hashCode(self, key, HASH_SIZE):
        # write your code here
        ans=0
        for x in key:
            ans=(ans*33+ ord(x)) % HASH_SIZE
        return ans
    
#129. Rehashing    
"""
Definition of ListNode
class ListNode(object):

    def __init__(self, val, next=None):
        self.val = val
        self.next = next
"""
class Solution:
    """
    @param hashTable: A list of The first node of linked list
    @return: A list of The first node of linked list which have twice size
    """
    def rehashing(self, hashTable):
        # write your code here
       n=len(hashTable)
        newhash=[None for _ in range(2*n)]
        for i,x in enumerate(hashTable):
            while x:
                pos=x.val%(2*n)
                if not newhash[pos]:
                       newhash[pos]=ListNode(x.val)
                else:
                       cur= newhash[pos]
                       while  cur.next:
                              cur=cur.next
                       cur.next=ListNode(x.val)
                x=x.next
        return newhash
Given [null, 21->9->null, 14->null, null],

return [null, 9->null, null, null, null, 21->null, 14->null, null]    
                                 
#130. Heapify                    
class Solution:
    """
    @param: A: Given an integer array
    @return: nothing
    """
    def heapify(self, A):
        # write your code here
        #從尾到頭掃一遍，如果遇到本身的值比parent element的值小的
#就一直跟parent element的值交換，直到交換到最頂層或是本身的值大於parent element的值
        def  move_up(i,A):
            while (i-1)//2 >=0 and A[(i-1)//2]>A[i]:
                  A[(i-1)//2],A[i]=A[i],A[(i-1)//2]
                  i=(i-1)//2
        for i in range(1,len(A)):
            move_up(i,A)
            print(A)
A=[3,2,1,4,5]            
if __name__ == "__main__":
    print(Solution().heapify(A))             
                
#131. The Skyline Problem                
class Solution:
    """
    @param buildings: A list of lists of integers
    @return: Find the outline of those buildings
    """
    def buildingOutline(self, buildings):
        # write your code here   
#        import heapq
#        events=sorted([ ( L,-H,R) for L,R ,H in buildings ]  + list({(R,0,None) for _ ,R,_ in buildings}))
#        res=[[0,0]]
#        hq=[(0,float('inf'))]
#        for x,negH,R in events:
#            while x >= hq[0][1]:
#                heapq.heappop(hq)
#            if negH:
#                heapq.heappush(hq,(negH,R))
#            if res[-1][1]+hq[0][0]:
#                res+=[x,-hq[0][0]],
#        return res[1:]
    
    
        import heapq
        events=sorted([ ( L,-H,R) for L,R ,H in buildings ]  + list({(R,0,None) for _ ,R,_ in buildings}))
        res=[[0,0]]
        hq=[(0,float('inf'))]
        for x,negH,R in events:
            while x >= hq[0][1]:
                heapq.heappop(hq)
            if negH:
                heapq.heappush(hq,(negH,R))
            if res[-1][1]+hq[0][0]:
                
                res+=[x,-hq[0][0]],
        res2=[]
        for i in range(1,len(res)-1):
            if res[i][1]==0:
                continue
            else:
                res2.append(list((res[i][0],res[i+1][0],res[i][1]))) 
        return res2
    
    
    
buildings=[[1,3,3],[2,4,4],[5,6,1]]    
[[1,3],[2,4],[4,0],[5,1],[6,0]]   
[[1,2,3],[2,4,4],[5,6,1]]    
buildings=[ [2 ,9, 10], [3, 7, 15], [5 ,12, 12], [15, 20, 10], [19, 24 ,8] ]
if __name__ == "__main__":
    print(Solution().buildingOutline( buildings))    
    
#132. Word Search II    
class Solution:
    """
    @param board: A list of lists of character
    @param words: A list of string
    @return: A list of string
    """
    def wordSearchII(self, board, words):
        # write your code here
        tries={}
        m=len(board)
        n=len(board[0])
        for word in words:
            curDict=tries
            for c in word:
                curDict=curDict.setdefault(c,{})
            curDict['#']='#'
                    
        def find(board,i,j,path,res,tries):
            if '#' in tries:
               res.add(path)
               
               
            if  not (0<=i<m  and  0<=j<n)  or board[i][j] not in tries:
                return 
            
            temp=board[i][j]
            board[i][j]='@'
            find(board,i+1,j,path+temp,res,tries[temp])
            find(board,i-1,j,path+temp,res,tries[temp])
            find(board,i,j+1,path+temp,res,tries[temp])
            find(board,i,j-1,path+temp,res,tries[temp])
            board[i][j]=temp
        res=set()
        
        
        for i in range(m):
            for j in range(n):
                find(board,i,j,'',res,tries)
        return list(res)
                 
            
words = ["oath","pea","eat","rain"]            
board =[
  ['o','a','a','n'],
  ['e','t','a','e'],
  ['i','h','k','r'],
  ['i','f','l','v']
]
board =[['d','o','a','f'],
['a','g','a','i'],
['d','c','a','n' ]]  
words =["dog", "dad", "dgdg", "can", "again"]      
if __name__ == "__main__":
    print(Solution().wordSearchII( board, words))        
        
#133. Longest Word
class Solution:
    """
    @param: dictionary: an array of strings
    @return: an arraylist of strings
    """
    def longestWords(self, dictionary):
        # write your code here
        curlen=0
        res=[]
        for word in dictionary:
            if len(word)>curlen:
                res=[word ]
                curlen=len(word)
            elif len(word)==curlen:
                res.append(word)
        return res
dictionary=[
  "dog",
  "google",
  "facebook",
  "internationalization",
  "blabla"
]
dictionary=[
  "like",
  "love",
  "hate",
  "yes"
]
if __name__ == "__main__":
    print(Solution().longestWords(dictionary))                 
                
#134. LRU Cache        
class LRUCache:
    """
    @param: capacity: An integer
    """
    def __init__(self, capacity):
        # do intialization if necessary
        from collections import  OrderedDict
        self.cap=capacity
        self.array=OrderedDict()

    """
    @param: key: An integer
    @return: An integer
    """
    def get(self, key):
        # write your code here
        if key in self.array:
            temp=self.array[key]
            del self.array[key]
            self.array[key]=temp
            return temp
        else:
            return -1
        
        

    """
    @param: key: An integer
    @param: value: An integer
    @return: nothing
    """
    def set(self, key, value):
        # write your code here 
        if key in self.array:
            del self.array[key]
        elif self.cap==len(self.array):
             self.array.popitem(last=False)
        self.array[key]=value
        
#135. Combination Sum
class Solution:
    """
    @param candidates: A list of integers
    @param target: An integer
    @return: A list of lists of integers
    """
    def combinationSum(self, candidates, target):
        # write your code here\
        
        def search(target,candidates,path,res,start):
            if target==0:
                
                   res.append(path[:])
                   return 
            else:
                for i in range(start,len(candidates)):
                    if (i==0 or candidates[i]!=candidates[i-1]) and target-candidates[i]>=0:
                        search(target-candidates[i],candidates,path+[candidates[i]],res,i)
                
            
        
        candidates.sort()
        res=[]
        search(target,candidates,[],res,0)
        return res
candidates=    [2,3,6,7]    
target =7        
[7]
[2, 2, 3]        
if __name__ == "__main__":
    print(Solution().combinationSum( candidates, target))               
        
#136. Palindrome Partitioning        
class Solution:
    """
    @param: s: A string
    @return: A list of lists of string
    """
    def partition(self, s):
        # write your code here
        def isPalindrome(string):
            n=len(string)
            if len(string)==1:
                return True
            for i in range(n//2):
                if string[i]!=string[n-1-i]:
                    return False
            return True
            
            
        def cut(s,res,path):
            if not s:
                res.append(path[:])
            else:
                for i in range(1,len(s)+1):
                    if isPalindrome(s[:i]):
                        cut(s[i:],res,path+[s[:i]])
        res=[]
        cut(s,res,[])
        return res
s='aab'
if __name__ == "__main__":
    print(Solution().partition( s))     
                
                        
#137. Clone Graph                
"""
Definition for a undirected graph node
class UndirectedGraphNode:
    def __init__(self, x):
        self.label = x
        self.neighbors = []
"""


class Solution:
    """
    @param: node: A undirected graph node
    @return: A undirected graph node
    """
    def cloneGraph(self, node):
        # write your code here
        if not node:
            return node
        
        #get all nodes
        from collections import deque
        mapping={}
        
        q=deque([node])
        
        while q:
            onenode=q.popleft()
            mapping[onenode]=UndirectedGraphNode(onenode.label)
            for nei in onenode.neighbors:
                if nei not in mapping:
                    q.append(nei)
        
        for anode in mapping:
            for nei in anode.neighbors:
                mapping[anode].neighbors.append(mapping[nei])
        return mapping[node]
        
            
if __name__ == "__main__":
    print(Solution().partition( s))                 
#138. Subarray Sum    
class Solution:
    """
    @param nums: A list of integers
    @return: A list of integers includes the index of the first number and the index of the last number
    """
    def subarraySum(self, nums):
        # write your code here
      
#        def search(nums,path,res,target,start):
#            if target==0 and path:
#                res.append(path[:])
#                return 
#            for i in range(start,len(nums)):
#                search(nums,path+[i],res,target+nums[i],i+1)
#        res=[]
#        search(nums,[],res,0,0)
#        print(res)
#        summ=0
#        for i in res[0]:
#            summ+=nums[i]
#        print(summ)
#        return [res[0][0],res[0][-1]]
        sumdict={0:-1}
        if nums[0]==0:
            return [0,0]
       
        summ=0
        for i in range(len(nums)):
            summ+=nums[i]
            if summ in sumdict:
                return [sumdict[summ]+1,i]
            sumdict[summ]=i
            
      
nums=[-3, 1, 2, -3, 4]
nums=[-5,10,5,-3,1,1,1,-2,3,-4]
#return [0, 2] or [1, 3]
if __name__ == "__main__":
    print(Solution().subarraySum(nums))       
    
#139. Subarray Sum Closest
class Node:
    def __init__(self,_value,_pos):
        self.value=_value
        self.pos=_pos
#    def __cmp__(self,other):
#        if self.value==other.value:
#            return self.pos-other.pos
#        else:
#            return self.value-other.value
    def __lt__(self, other):
        if self.value == other.value:
            return self.pos < other.pos
        else:
            return self.value < other.value
        
        
class Solution:
    """
    @param: nums: A list of integers
    @return: A list of integers includes the index of the first number and the index of the last number
    """
    def subarraySumClosest(self, nums):
        # write your code here   
        summ=0
        s=[]
        s.append(Node(0,-1))
        
        
        for i in range(len(nums)):
            summ+=nums[i]
            s.append(Node(summ,i))
        
        s.sort()
        
        res=[0,0]
        ans=float('inf')
        for i in range(len(nums)-1):
            if s[i+1].value-s[i].value<ans or s[i+1].value-s[i].value==ans and min(s[i+1].pos,s[i].pos)+1<res[0]:
                ans=s[i+1].value-s[i].value
                res[0]=min(s[i+1].pos,s[i].pos)+1
                res[1]=max(s[i+1].pos,s[i].pos)
        return res        
nums=[6,-4,-8,3,1,7]    
if __name__ == "__main__":
    print(Solution().subarraySumClosest( nums))                     
        
#140. Fast Power        
class Solution:
    """
    @param a: A 32bit integer
    @param b: A 32bit integer
    @param n: A 32bit integer
    @return: An integer
    """
    def fastPower(self, a, b, n):
        # write your code here
        
        if n==0:
            return 1%b
        if n==1:
            return a%b
        if n%2==0:
            return (self.fastPower(a,b,n//2) **2)%b
        else:
            return (self.fastPower(a,b,n//2) **2*a)%b

a=2
b=3
n=31

if __name__ == "__main__":
    print(Solution().fastPower(a, b, n)) 


#141. Sqrt(x)     
class Solution:
    """
    @param x: An integer
    @return: The sqrt of x
    """
    def sqrt(self, x):
        # write your code here
        
        if x==1 or x==0:
            return x

        for i in range(x):
           if i*i>x:
               return i-1
x=10
if __name__ == "__main__":
    print(Solution().sqrt( x)) 
    
#142. O(1) Check Power of 2
class Solution:
    """
    @param n: An integer
    @return: True or false
    """
    def checkPowerOf2(self, n):
        # write your code here
        if n<=0:
            return False
        return n&(n-1)==0
if __name__ == "__main__":
    print(Solution(). checkPowerOf2( n))


#143. Sort Colors II
class Solution:
    """
    @param colors: A list of integer
    @param k: An integer
    @return: nothing
    """
    def sortColors2(self, colors, k):
        # write your code here
        n=len(colors)
        def rainbowsort(colors,left,right,lowNum,highNum):
            if lowNum==highNum:
                return 
            if left>=right:
                return 
            l=left
            r=right
            midNum=(lowNum+highNum)/2
            while l <=r:
                while l<=r and colors[l]<= midNum:
                    l+=1
                while l<=r and colors[r]> midNum:
                    r-=1
                if l<=r:
                    colors[l],colors[r]=colors[r],colors[l]
                
            rainbowsort(colors,left,r,lowNum,midNum)
            rainbowsort(colors,l,right,midNum+1,highNum)
        rainbowsort(colors,0,n-1,1,k)
        print(colors)
colors=[3, 2, 2, 1, 4]
k=4
if __name__ == "__main__":
    print(Solution().sortColors2(colors, k))

#144. Interleaving Positive and Negative Numbers
class Solution:
    """
    @param: A: An integer array.
    @return: nothing
    """
    def rerange(self, A):
        # write your code here
        
        n=len(A)
        
        hi=n-1
        lo=0
        
        while lo<=hi:
            while lo<=hi and A[lo]<0:
                lo+=1
            while lo<=hi and A[hi]>0:
                hi-=1
            if lo<=hi:
                A[lo],A[hi] = A[hi] , A[lo]
                lo+=1
                hi-=1
        negCount=lo
        posCount=n-hi-1
        print(A)
        
        lo=1        if negCount>=posCount  else 0
        
        hi=n-2        if   posCount >=negCount else n-1
        
        
        while lo<hi:
            A[lo],A[hi] = A[hi] , A[lo]
            lo+=2
            hi-=2
        print(A)
A=[-1, -2, -3, 4, 5, 6,-9]             
if __name__ == "__main__":
    print(Solution().rerange( A))        
        
#145. Lowercase to Uppercase    
class Solution:
    """
    @param character: a character
    @return: a character
    """
    def lowercaseToUppercase(self, character):
        # write your code here
        x=ord('A')-ord('a')
        return chr(x+ord(character))

#148. Sort Colors
class Solution:
    """
    @param nums: A list of integer which is 0, 1 or 2 
    @return: nothing
    """
    def sortColors(self, nums):
        # write your code here
        n=len(nums)
        i=0
        left=0
        right=n-1
        print(nums) 
        while i<=right:
            while i <=right and nums[i]==0:
                nums[left],nums[i]=nums[i],nums[left]
                left+=1
                i+=1
            print(nums,i,left,right)    
            while i <=right and nums[i]==1:
                i+=1
            print(nums,i,left,right)
            
            while i <=right and nums[i]==2:
                nums[right],nums[i]=nums[i],nums[right]
                right-=1
            print(nums,i,left,right) 
            
                
        
nums=[2,1,0,1,2,0,2]
if __name__ == "__main__":
    print(Solution().sortColors( nums))        
            
#149. Best Time to Buy and Sell Stock                
class Solution:
    """
    @param prices: Given an integer array
    @return: Maximum profit
    """
    def maxProfit(self, prices):
        # write your code here
        low=float('inf')
        
        total=0
        
        for x in prices:
            if x-low>total:
                total=x-low
            if x<low:
                low=x
        return total
prices=[3,2,3,1,2]
if __name__ == "__main__":
    print(Solution().maxProfit( prices))    
            
#150. Best Time to Buy and Sell Stock II
class Solution:
    """
    @param prices: Given an integer array
    @return: Maximum profit
    """
    def maxProfit(self, prices):
        # write your code here
        
        low=float('inf')
        profit=0
        for x in prices:
            if x>low:
                
               profit+=x-low
               low=x
            else:
                 
               low=x
        return profit
            
prices= [2,1,2,0,1]
prices= [1,2,4]
if __name__ == "__main__":
    print(Solution().maxProfit( prices)) 
          
[2,1,2,0,1], return 2        
        
#151. Best Time to Buy and Sell Stock III        
class Solution:
    """
    @param prices: Given an integer array
    @return: Maximum profit
    """
    def maxProfit(self, prices):
        # write your code here
        
#https://blog.csdn.net/fightforyourdream/article/details/14503469 
#这里我们先解释最多可以进行k次交易的算法，然后最多进行两次我们只需要把k取成2即可。我们还是使用“局部最优和全局最优解法”。我们维护两种量，一个是当前到达第i天可以最多进行j次交易，最好的利润是多少（global[i][j]），另一个是当前到达第i天，最多可进行j次交易，并且最后一次交易在当天卖出的最好的利润是多少（local[i][j]）。下面我们来看递推式，全局的比较简单，

#global[i][j]=max(local[i][j],global[i-1][j])，
#也就是去当前局部最好的，和过往全局最好的中大的那个（因为最后一次交易如果包含当前天一定在局部最好的里面，否则一定在过往全局最优的里面）。

#全局（到达第i天进行j次交易的最大收益） = max{局部（在第i天交易后，恰好满足j次交易），全局（到达第i-1天时已经满足j次交易）}
        n=len(prices)
        if n==0:
            return 0
        
        def profit(prices,k):
            
            globalmax=[[0 for _ in range(k+1)]for _ in range(n)]
            
            localmax=[[0 for _ in range(k+1)]for _ in range(n)]
            
            for i in range(1,n):
                for j in range(1,k+1):
                    dif=prices[i]-prices[i-1]
                    localmax[i][j]=max(globalmax[i-1][j-1]+max(0,dif),localmax[i-1][j]+dif)
                    globalmax[i][j]=max(localmax[i][j], globalmax[i-1][j])
            return globalmax[n-1][k]
        return profit(prices,2)
prices=[4,4,6,1,1,4,2,5]# return 6.        
    
if __name__ == "__main__":
    print(Solution().maxProfit( prices)) 
                    
#152. Combinations
class Solution:
    """
    @param n: Given the range of numbers
    @param k: Given the numbers of combinations
    @return: All the combinations of k numbers out of 1..n
    """
    def combine(self, n, k):
        # write your code here
        def add(k,path,res,index):
            if len(path)==k:
                res.append(path[:])
                return 
            for i in range(index,n+1):
                path.append(i)
                add(k,path,res,i+1)
                path.pop()
        res=[]
        add(k,[],res,1)
        return res
n = 4
k=2    
if __name__ == "__main__":
    print(Solution(). combine( n, k))  
        
Given n = 4 and k = 2, a solution is:

[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4]
]        
        
        
#153. Combination Sum II
class Solution:
    """
    @param num: Given the candidate numbers
    @param target: Given the target number
    @return: All the combinations that sum to target
    """
    def combinationSum2(self, num, target):
        # write your code here
        def search(num,target,path,res,index):
            if target==0:
                res.append(path[:])
            for i in range(index,len(num)):
                if (i==index or num[i]!=num[i-1] )  and target-num[i]>=0:
                     
                
                    search(num,target-num[i],path+[num[i]],res,i+1)
        res=[]
        num.sort()
        search(num,target,[],res,0)
        return res
num=        [10,1,6,7,2,1,5]
target=8
if __name__ == "__main__":
    print(Solution().combinationSum2( num, target))        
        
[10,1,6,7,2,1,5] and target 8        
        
 [
  [1,7],
  [1,2,5],
  [2,6],
  [1,1,6]
]       
        
#154. Regular Expression Matching        
class Solution:
    """
    @param s: A string 
    @param p: A string includes "." and "*"
    @return: A boolean
    """
    def isMatch(self, s, p):
        # write your code here
#https://leetcode.com/problems/regular-expression-matching/discuss/5723/My-DP-approach-in-Python-with-comments-and-unittest        
        m=len(p)
        n=len(s)
        dp=[[False for _ in range(n+1)] for _ in range(m+1)]
        
        dp[0][0]=True
     
        for i in range(2,m+1):
            if p[i-1]=='*':
               dp[i][0]=dp[i-2][0]
        
        
        for i in range(1,m+1):
            for j in range(1,n+1):
                if p[i-1]!='*':
                    if  p[i-1]=='.'  or  p[i-1]==s[j-1]:
                        dp[i][j]=dp[i-1][j-1]
                else:
                    dp[i][j]=dp[i-2][j]  or dp[i-1][j]
                    if p[i-2]==s[j-1] or p[i-2]=='.':
                        dp[i][j]=dp[i][j] or dp[i][j-1]
        return dp[-1][-1]

s="aa"
p="a" 
s="aab"
p="c*a*b"                       
if __name__ == "__main__":
    print(Solution().isMatch( s, p))        
                                
#155. Minimum Depth of Binary Tree                    
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""

class Solution:
    """
    @param root: The root of binary tree
    @return: An integer
    """
    def minDepth(self, root):
        # write your code here
        
        if not root:
            return 0
        
        from collections import deque
        q=deque([root])
        
        step=1
        while q:
            tempq=deque()
            for _ in range(len(q)):
                
                node=q.popleft()
                if not node.left and not node.right:
                    return step
                else:
                    if node.left:
                        tempq.append(node.left)
                    if node.right:
                        tempq.append(node.right)
            q=tempq
            step+=1
        return step
                
            
  1
 / \ 
2   3
   / \
  4   5              
                        
root=TreeNode(1)                   
root.left=TreeNode(2)   
root.right=TreeNode(3)   
root.right.left=TreeNode(4)   
root.right.right=TreeNode(5)   
if __name__ == "__main__":
    print(Solution().minDepth( root))   

#156. Merge Intervals
"""
Definition of Interval.
class Interval(object):
    def __init__(self, start, end):
        self.start = start
        self.end = end
"""

class Solution:
    """
    @param intervals: interval list.
    @return: A new interval list.
    """
    def merge(self, intervals):
        # write your code here
        res=[]
        intervals.sort(key=lambda x:x.start)
        a='@'
        
#        for x in intervals:
#            print(x.start,x.end)
        for i in range(len(intervals)-1):
            if a=='@':
                a=intervals[i].start
                b=intervals[i].end
            b=max(b,intervals[i].end)
            if intervals[i+1].start>b:
                res.append(Interval(a,b))
                a='@'
            
        if a=='@':
            res.append(intervals[-1])
        else:
            res.append(Interval(a,max(b,intervals[-1].end)))
        for x in res:
            print(x.start,x.end)
        return res
            
intervals=[Interval(1,4),Interval(0,2),Interval(3,5)]
intervals=[                     
  Interval(1, 3),              
  Interval(2, 6),       Interval(8, 10),           
  Interval(15, 18)            ]
intervals=[                     
  (1, 3),              
  (2, 6),       (8, 10),           
  (10, 18)]

intervals=[Interval(2,3),Interval(4,5),Interval(6,7),Interval(8,9),Interval(1,10)]

intervals=[(0,2),(1,4),(3,5)]
intervals=[(2,3),(4,5),(6,7),(8,9),(1,10)]
       
if __name__ == "__main__":
    print(Solution().merge(intervals))
    
#157. Unique Characters
class Solution:
    """
    @param: str: A string
    @return: a boolean
    """
    def isUnique(self, str):
        # write your code here
        
        dic={}
        for s in str:
            if s in dic:
                return False
            dic[s]=1
        return True
    
    
    
    
#158. Valid Anagram
class Solution:
    """
    @param s: The first string
    @param t: The second string
    @return: true or false
    """
    def anagram(self, s, t):
        # write your code here
        if not s and not t:
            return True
        if not s or not t:
            return False
        n=len(s)
        m=len(t)
        if n!=m:
            return False
        
        from collections import Counter
        return Counter(s)==Counter(t)
            
s="abcd"
t="dcab"           
if __name__ == "__main__":
    print(Solution().anagram(s, t))             
            
            
#159. Find Minimum in Rotated Sorted Array
class Solution:
    """
    @param nums: a rotated sorted array
    @return: the minimum number in the array
    """
    def findMin(self, nums):
        # write your code here
        
        n=len(nums)
        if n==1:
            return nums[0]
        if n==2:
            return min(nums)
        
        l=0
        r=n-1
        
        while l+1<r:
            mid=(l+r)//2
            #print(l,r,mid)
            if nums[mid]>nums[l] and nums[r]<nums[l]:#left part is sorted min is in the right part
               l=mid+1
            else:
                r=mid
        print(nums[mid],nums[l],nums[r])
        return min(nums[mid],nums[l],nums[r])
 
nums=[2, 4, 5, 6, 7, 0, 1]
nums=[4, 5, 6, 7, 0, 1, 2] 
nums=[5, 6, 7, 0, 1, 2, 4]
nums=[6, 7, 0, 1, 2, 4, 5]
if __name__ == "__main__":
    print(Solution().findMin( nums))  

#160. Find Minimum in Rotated Sorted Array II
class Solution:
    """
    @param nums: a rotated sorted array
    @return: the minimum number in the array
    """
    def findMin(self, nums):
        # write your code here
        n=len(nums)
        if n==1:
            return nums[0]
        if n==2:
            return min(nums)
        
        l=0
        r=n-1
        while l+1<r:
            
            mid=(l+r)//2
            #print(l,r,mid)
            if nums[mid]>=nums[l] and nums[r]<=nums[l]:#left part is sorted min is in the right part
               l=mid+1
            else:
                r=mid
        print(nums[mid],nums[l],nums[r])
        return min(nums[mid],nums[l],nums[r])
nums=[4,4,4,4,4,0,1,3]
nums=[4,4,4,4,0,0,0,0]

nums=[4,4,0,1,3,3,3,3]
if __name__ == "__main__":
    print(Solution().findMin( nums)) 

#161. Rotate Image
class Solution:
    """
    @param matrix: a lists of integers
    @return: nothing
    """
    def rotate(self, matrix):
        # write your code here
        n=len(matrix)
        
        
        for i in range(n):
            for j in range(i+1,n):
              matrix[i][j] ,  matrix[j][i] = matrix[j][i]m, matrix[i][j]
              
        for i in range(n):
            matrix[i].reverse()
            
#162. Set Matrix Zeroes        
class Solution:
    """
    @param matrix: A lsit of lists of integersa
    @return: nothing
    """
    def setZeroes(self, matrix):
        # write your code here
        m=len(matrix)
        n=len(matrix[0])
        
        
        row=set()
        col=set()
        
        for i in range(m):
            for j in range(n):
                if matrix[i][j]==0:
                    row.add(i)
                    col.add(j)
                    continue
            if i in row:
                continue
            
        for  i in range(m):
            for j in range(n):
                if i in row or j in col:
                    matrix[i][j]=0
                
#163. Unique Binary Search Trees                    
class Solution:
    """
    @param n: An integer
    @return: An integer
    """
    def numTrees(self, n):
        # write your code here
#一棵树由根节点，左子树和右子树构成。
#对于目标n，根节点可以是1, 2, ..., n中的任意一个，假设根节点为k，那么左子树的可能性就是numTrees(k-1)种，
#右子树的可能性就是numTrees(n-k)种，他们的乘积就根节点为k时整个树的可能性。把所有k的可能性累加就是
#最终结果        
        hashtable={0:1,1:1,2:2}
        
        def dfs(hashtable,n):
            if n in hashtable:
                return hashtable[n]
            res=0
            for i in range(1,n+1):
                res+=dfs(hashtable,i-1)*dfs(hashtable,n-i)
            hashtable[n]=res
            return res
        return dfs(hashtable,n)
n=3
if __name__ == "__main__":
    print(Solution().numTrees( n)) 
                
#164. Unique Binary Search Trees II
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""
class Solution:
    # @paramn n: An integer
    # @return: A list of root
    def generateTrees(self, n):
        # write your code here     
        def dfs(start,end):
            if start>end:
                return [None]
            res=[]
            
            for rootval in range(start,end+1):
                leftTree=dfs(start,rootval-1)
                rightTree=dfs(rootval+1,end)
                for i in leftTree:
                   for j in rightTree:
                      
                     root=TreeNode(rootval)
                     root.left=i
                     root.right=j
                     res.append(root)
            return res
        return dfs(1,n)
n=3
if __name__ == "__main__":
    print(Solution().generateTrees( n))         
        
#165. Merge Two Sorted Lists   
"""
Definition of ListNode
class ListNode(object):
    def __init__(self, val, next=None):
        self.val = val
        self.next = next
"""

class Solution:
    """
    @param l1: ListNode l1 is the head of the linked list
    @param l2: ListNode l2 is the head of the linked list
    @return: ListNode head of linked list
    """
    def mergeTwoLists(self, l1, l2):
        # write your code here
        if not l1 :
            return l2
        if not l2:
            return l1
        
        dummy=ListNode(-1)
        cur=dummy
        while l1 and l2:
              if l1.val<l2.val:
                  cur.next=l1
                  l1=l1.next
              else:
                  cur.next=l2
                  l2=l2.next
              cur=cur.next
        if l1:
            cur.next=l1
        if l2:
            cur.next=l2
        return dummy.next
            
#166. Nth to Last Node in List
"""
Definition of ListNode
class ListNode(object):

    def __init__(self, val, next=None):
        self.val = val
        self.next = next
"""
class Solution:
    """
    @param: head: The first node of linked list.
    @param: n: An integer
    @return: Nth to last node of a singly linked list. 
    """
    def nthToLast(self, head, n):
        # write your code here
        if not head:
            return None
        
        length=0
        cur=head
        while cur:
            cur=cur.next
            length+=1
        cur=head
        for _ in range(length-n):
            cur=cur.next
            
        return cur
            
        
        
            
root=      ListNode(3)
root.next=      ListNode(2)
root.next.next=      ListNode(1) 
root.next.next.next=      ListNode(5)      
head=root
n=2        
if __name__ == "__main__":
    print(Solution().nthToLast( head, n))           
#Given a List  3->2->1->5->null and n = 2, return node  whose value is 1        
        
#167. Add Two Numbers        
"""
Definition of ListNode
class ListNode(object):
    def __init__(self, val, next=None):
        self.val = val
        self.next = next
"""

class Solution:
    """
    @param l1: the first list
    @param l2: the second list
    @return: the sum list of l1 and l2 
    """
    def addLists(self, l1, l2):
        # write your code here
        if not l1 :
            return l2
        if not l2:
            return l1
        
        dummy=ListNode(-1)
        carry=0
        cur=dummy
        while l1 and l2:
            cur.next=ListNode((l1.val+l2.val+carry)%10)
            carry=(l1.val+l2.val+carry)//10
            
            l1=l1.next
            l2=l2.next
            cur=cur.next
        while l1:
            cur.next=ListNode((l1.val+carry)%10)
            carry=(l1.val+carry)//10
            
            l1=l1.next
            
            cur=cur.next
        while l2:
            cur.next=ListNode((l2.val+carry)%10)
            carry=(l2.val+carry)//10
            
           
            l2=l2.next
            cur=cur.next
        if carry:
            
           cur.next=ListNode(carry)
        cur=dummy.next
        while cur:
            print(cur.val)
            cur=cur.next
        return dummy.next
            
l1=      ListNode(7)
l1.next=      ListNode(1)
l1.next.next=      ListNode(6) 
l2=      ListNode(5)
l2.next=      ListNode(9)
l2.next.next=      ListNode(2) 

l1=      ListNode(3)
l1.next=      ListNode(1)
l1.next.next=      ListNode(5) 
l2=      ListNode(5)
l2.next=      ListNode(9)
l2.next.next=      ListNode(2) 

l1=      ListNode(1)
l1.next=      ListNode(1)
l1.next.next=      ListNode(1) 
l1.next.next.next=      ListNode(1)
l1.next.next.next.next=      ListNode(1)

l2=      ListNode(9)
l2.next=      ListNode(8)
l2.next.next=      ListNode(8) 
l2.next.next.next=      ListNode(8)
l2.next.next.next.next=      ListNode(8)

if __name__ == "__main__":
    print(Solution().addLists(l1, l2))           
             
            
  
        
#Given 7->1->6 + 5->9->2. That is, 617 + 295.
#
#Return 2->1->9. That is 912.
#1->1->1->1->1->null
#9->8->8->8->8->null
#Given 3->1->5 and 5->9->2, return 8->0->8.        
        
#168. Burst Balloons        
class Solution:
    """
    @param nums: A list of integer
    @return: An integer, maximum coins
    """
    def maxCoins(self, nums):
        # write your code here
        
#        def burst(nums,memo):
#            if tuple(nums) in memo:
#                return memo[tuple(nums)]
#            n=len(nums)
#            if len(nums)==3:
#                memo[tuple(nums)]=nums[1]
#                return nums[1]
#            
#            maxcoins=0
#            for i in range(1,n-1):
#                maxcoins=max(maxcoins,nums[i-1]*nums[i]*nums[i+1]+burst(nums[:i]+nums[i+1:],memo))
#            memo[tuple(nums)]=maxcoins
#            return maxcoins
#                
#        memo={}
#        return burst([1]+nums+[1],memo)
        
#        @dharmendra2 This dp works in this way: we scan the array from len 2 to len n with 
#        all possible start points and end points. For each combination, we will find the 
#        best way to burst balloons. dp[i][j] means we are looking at a combination with
#        start point at index i and end point at index j with len of j - i. In this combination,
#        we use the third loop to find the best way to burst.
#        “nums[left] * nums[i] * nums[right]” means we burst all balloons from left to i
#        and all ballons from i to right. So only balloons left, i and right exits in current 
#        combination therefore we can do this operation. “+ dp[left][i] + dp[i][right]” means 
#        add the value from best burst in range(left, i) and range(i, right).
        n=len(nums)
        
        dp=[[0 for _ in range(n)]  for _ in range(n)]
        
        for length in range(n):
            for i in range(0,n-length):
                j=i+length
                for k in range(i,j+1):
                    if i==k:
                        leftdp=0
                    else:
                        leftdp=dp[i][k-1]
                    if k==j:
                        rightdp=0
                    else:
                        rightdp=dp[k+1][j]
                    
                    if i==0:
                        left=1
                    else:
                        left=nums[i-1]
                    if j==n-1:
                        right=1
                        
                    else:
                        right=nums[j+1]
                    dp[i][j]=max(dp[i][j],leftdp+rightdp+left*nums[k]*right)
        return dp[0][n-1]
        
        
        
        
        
nums=[4, 1, 5, 10]
nums=[35,16,83,87,84,59,48,41,20,54]
nums=[8,2,6,8,9,8,1,4,1,5,3,0,7,7,0,4,2,2,5,5]    
if __name__ == "__main__":
    print(Solution().maxCoins(nums))    
        
#Given [4, 1, 5, 10]
#Return 270
#
#nums = [4, 1, 5, 10] burst 1, get coins 4 * 1 * 5 = 20
#nums = [4, 5, 10]    burst 5, get coins 4 * 5 * 10 = 200 
#nums = [4, 10]       burst 4, get coins 1 * 4 * 10 = 40
#nums = [10]          burst 10, get coins 1 * 10 * 1 = 10
#
#Total coins 20 + 200 + 40 + 10 = 270

        
#169. Tower of Hanoi
class Solution:
    """
    @param n: the number of disks
    @return: the order of moves
    """
    def towerOfHanoi(self, n):
        # write your code here
        
#        res=[]
#        
#        def move(n,fromDisk,toDisk,auxiliary):
#            if n==1:
#                res.append('Disk 1 move from '+ fromDisk+ ' to ' + toDisk)
#                return 
#            move(n-1,fromDisk,auxiliary,toDisk)
#            res.append('disk '+str(n)+' move from '+ fromDisk+ ' to ' + toDisk)
#            move(n-1,auxiliary,toDisk,fromDisk)
#        move(n,'A','C','B')
#        return res
#    
        res=[]
        
        def move(n,fromDisk,toDisk,auxiliary):
            if n==1:
                res.append('from '+ fromDisk+ ' to ' + toDisk)
                return 
            move(n-1,fromDisk,auxiliary,toDisk)
            res.append('from '+ fromDisk+ ' to ' + toDisk)
            move(n-1,auxiliary,toDisk,fromDisk)
        move(n,'A','C','B')
        return res
n=3
if __name__ == "__main__":
    print(Solution().towerOfHanoi( n))                    
        
#170. Rotate List
"""
Definition of ListNode
class ListNode(object):
    def __init__(self, val, next=None):
        self.val = val
        self.next = next
"""

class Solution:
    """
    @param head: the List
    @param k: rotate to the right k places
    @return: the list after rotation
    """
    def rotateRight(self, head, k):
        # write your code here
        
        if not head:
            return None
        
        if k==0:
            return head
        
        if not head.next:
            return head
        
        cur=head
        
        length=0
        
        while cur:
            length+=1
            cur=cur.next
            
        k=k%length 
        
        if k==0:
            return head
        
        
        cur=head
        
        for _ in range(length-k-1):
            cur=cur.next
        
        newhead=cur.next
        cur.next=None
        
        cur=newhead
        while cur.next:
            cur=cur.next
        cur.next=head
        
        
        cur=newhead
        
        while cur:
            print(cur.val)
            cur=cur.next
        return newhead
k = 2
head=ListNode(1)
head.next=ListNode(2)
head.next.next=ListNode(3)
head.next.next.next=ListNode(4)
head.next.next.next.next=ListNode(5)
            

k = 0
head=ListNode(1)


k=100
head=ListNode(0)
head.next=ListNode(1)

if __name__ == "__main__":
    print(Solution().rotateRight( head, k))                    
                
#171. Anagrams        
class Solution:
    """
    @param strs: A list of strings
    @return: A list of strings
    """
    def anagrams(self, strs):
        # write your code here
        
        from collections import defaultdict
        dic=defaultdict(list)
        
        
        for x in strs:
            sortedword=''.join(sorted(x))
            dic[sortedword]+=[x]
        
        res=[]
        for key,val in dic.items():
            if len(val)>=2:
                res+=val
        return res
                
            
            
strs=["lint", "intl", "inlt", "code"]  
strs=["ab", "ba", "cd", "dc", "e"]  
if __name__ == "__main__":
    print(Solution().anagrams( strs))                 
    
#172. Remove Element
class Solution:
    """
    @param: A: A list of integers
    @param: elem: An integer
    @return: The new length after remove
    """
    def removeElement(self, A, elem):
        # write your code here 
        if not A:
            return 0
        i=0
        j=0
        
        n=len(A)
        while j<n:
            if A[j]!=elem:
                A[i]=A[j]
                i+=1
                j+=1
                
            else:
                j+=1
        return i
            
A= [0,4,4,0,0,2,4,4]     
elem=4          
if __name__ == "__main__":
    print(Solution().removeElement( A, elem))                 
            
    
#173. Insertion Sort List
"""
Definition of ListNode
class ListNode(object):
    def __init__(self, val, next=None):
        self.val = val
        self.next = next
"""

class Solution:
    """
    @param head: The first node of linked list.
    @return: The head of linked list.
    """
    def insertionSortList(self, head):
        # write your code here
#https://leetcode.com/problems/insertion-sort-list/discuss/46420/An-easy-and-clear-way-to-sort-(-O(1)-space-)
        if not head:
            return None
        dummy=ListNode(0)
        pre=dummy#insert node between pre and pre.next
        cur=head#the node will be inserted
        
        while cur:
            next=cur.next
            #find the right place to insert
            while pre.next  and pre.next.val < cur.val:
                pre=pre.next
            #insert between pre and pre.next
            cur.next=pre.next
            pre.next=cur
            cur=next
            pre=dummy
        return dummy.next
        
        
#174. Remove Nth Node From End of List        
"""
Definition of ListNode
class ListNode(object):
    def __init__(self, val, next=None):
        self.val = val
        self.next = next
"""

class Solution:
    """
    @param head: The first node of linked list.
    @param n: An integer
    @return: The head of linked list.
    """
    def removeNthFromEnd(self, head, n):
        # write your code here
        
        if not head:
            return None
        if n==0:
            return head
        
        fast=head
        slow=head
        
        for _ in range(n):
            fast=fast.next
        if not fast:
            return head.next
        while fast.next:
            fast=fast.next
            slow=slow.next
        slow.next=slow.next.next
        cur=head
        while cur:
            print(cur.val)
            cur=cur.next
        return head
       
#Given linked list: 1->2->3->4->5->null, and n = 2.
#
#After removing the second node from the end, the linked list becomes 1->2->3->5->null.        
        
head=ListNode(1)
head.next=ListNode(2)
head.next.next=ListNode(3)
head.next.next.next=ListNode(4)
head.next.next.next.next=ListNode(5)            
n=1       
if __name__ == "__main__":
    print(Solution().removeNthFromEnd(head, n))         
        
        
#175. Invert Binary Tree
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""

class Solution:
    """
    @param root: a TreeNode, the root of the binary tree
    @return: nothing
    """
    def invertBinaryTree(self, root):
        # write your code here
        
        if not root:
            return None
        
        def invert(node):
            
            if not node:
                return None
            right=invert(node.left)
            left=invert(node.right)
            node.left=left
            node.right=right
            return node
        return invert(root)
        
        
#176. Route Between Two Nodes in Graph
"""
Definition for a Directed graph node
class DirectedGraphNode:
    def __init__(self, x):
        self.label = x
        self.neighbors = []
"""


class Solution:
    """
    @param: graph: A list of Directed graph node
    @param: s: the starting Directed graph node
    @param: t: the terminal Directed graph node
    @return: a boolean value
    """

    def hasRoute(self, graph, s, t):
        # write your code here
        visited={}
        for x in graph:
            visited[x]=0
        
        def dfs(visited,cur,t):
            if visited[cur]==1:
                return False
            if cur==t:
                return True
            visited[cur]=1
            for nextcur in cur.neighbors:
                if visited[nextcur]==0 and dfs(visited,nextcur,t):
                    return True
            return False
        
        return dfs(visited,s,t)
            
#177. Convert Sorted Array to Binary Search Tree With Minimal Height
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""


class Solution:
    """
    @param: A: an integer array
    @return: A tree node
    """
    def sortedArrayToBST(self, A):
        # write your code here
        def convert(l):
            n=len(l)
            if n==0:
                return None
            if n==1:
                return TreeNode(l[0])
            mid=(0+n-1)//2
            root=TreeNode(l[mid])
            
            root.left=convert(l[:mid])
            root.right=convert(l[mid+1:])
            return root
        return convert(A)
            
#178. Graph Valid Tree
class Solution:
    """
    @param n: An integer
    @param edges: a list of undirected edges
    @return: true if it's a valid tree, or false
    """
    def validTree(self, n, edges):
        # write your code here
#思路：判断一个图是不是一棵树①首先应该有n-1条边　②边没有形成环        
#vertex和edge的validation，|E| = |V| - 1，
#也就是要验证 edges.length == n-1，如果该条件不满足，则Graph一定不是valid tree。  
        if len(edges)!=n-1:
           return False    
        
        from    collections import defaultdict 
        neighbors  =    defaultdict (list) 
        for k,v in edges:
            neighbors[k]+=[v]
            neighbors[v]+=[k]
        self.visited=set()
        def dfs(i,parent):
            self.visited.add(i)
            
            for nei in neighbors[i]:
                if nei not in self.visited :
                    if not dfs(nei,i):
                        return False
                elif nei!=parent:
                    return False
            return True
        
        res=dfs(0,-1)
        print(self.visited)
        print(res)
        return res  and len(self.visited)==n
n = 5 
edges = [[0, 1], [0, 2], [0, 3], [1, 4]]  
edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]  ]
if __name__ == "__main__":
    print(Solution().validTree( n, edges))                
            
#179. Update Bits
class Solution:
    """
    @param n: An integer
    @param m: An integer
    @param i: A bit position
    @param j: A bit position
    @return: An integer
    """
    def updateBits(self, n, m, i, j):
        # write your code here
#http://www.chenguanghe.com/lintcode-update-bits/ 
#python deal with 32th bit differs from Java
        
#        for k in range(i,j+1):
#            n=n & ~(1<<k) #set kth bit in n to 0
#            n = n|((m& (1<<(k-i)))<<i)#set kth bit in n to m's kth bit
#        
#        if n>(1<<31):
#            return n-(1<<32)
        a=[]
        for _ in range(32):
            a.append(n%2)
            n=n//2
        
        for k in range(i,j+1):
            a[k]=m%2
            m=m//2
        
        n=0
        for i in range(31):
            if a[i]>0:
                n|=(a[i]<<i)
#If the sign bit is “1”, then the number is negative in value  

        if a[31]==1:
            n-=1<<31 
            n=~n+1
            # ~n+1
        return n
            
#Two's Complement binary for Negative Integers:
#
#Negative numbers are written with a leading one instead of a leading zero.
# So if you are using only 8 bits for your twos-complement numbers, 
# then you treat patterns from "00000000" to "01111111" as the whole numbers from 0 to 127, 
# and reserve "1xxxxxxx" for writing negative numbers. A negative number, -x, 
# is written using the bit pattern for (x-1) with all of the bits complemented 
# (switched from 1 to 0 or 0 to 1). So -1 is
# complement(1 - 1) = complement(0) = "11111111", and -10 is complement(10 - 1) =
# complement(9) = complement("00001001") = "11110110". This means that negative numbers
# go all the way down to -128 ("10000000").
#
#Of course, Python doesn't use 8-bit numbers. It USED to use however many bits were 
#native to your machine, but since that was non-portable, it has recently switched to
# using an INFINITE number of bits. Thus the number -5 is treated by bitwise operators
# as if it were written "...1111111111111111111011".                        
############################################################            
# Negative numbers to binary system with Python            #
#                                                          #
#                                                          #
#Just need to add 2**32 (or 1 << 32) to the negative value # 
#bin(-1+(1<<32))                                           #
# or Bitwise AND (&) with 0xffffffff (2**32 - 1) first:    #
#    0xffffffff used as mask                               #
#'0b11111111111111111111111111111111'                      #         
            
        
            
#m & (1<<(k-i)) 是从m的第一个bit开始扫描.因为已知j-i = size of (m)2
#((m & (1<<(k-i)))<<i) 扫描后, 往左shift i位对准n上的i位.
#n = n | ((m & (1<<(k-i)))<<i) 把n的第i位到j位设为m的0~(j-i)位 
        
n=int('10000000000',2)        
m=int('10101',2)  
i=2
j=6 

n=1
m=-1
i=0
j=31  
n= -521
m=0
i=31
j=31       
if __name__ == "__main__":
    print(Solution().updateBits(n, m, i, j))  
        
#180. Binary Representation
class Solution:
    """
    @param n: Given a decimal number that is passed in as a string
    @return: A string
    """
    def binaryRepresentation(self, n):
        # write your code here
        
        [a,b]=n.split('.')
        a='{:b}'.format(int(a))
        #print(a,b)
        
        
        def frac_to_binary( num):
            if num==''  or int(num)==0:
                return ''
            if int(num)%10!=5:
                return None
            from decimal import Decimal 
            num=Decimal('0.'+num)
            res=''
            while num:
                num*=2
                if num>=1:
                    res+='1'
                    num-=1
                else:
                    res+='0'
                num=num.normalize()
                if num and str(num)[-1]!='5':
                    return None
            #print(res)
            return res
        b=frac_to_binary( b)
        print(b)
        if b  is None:
            return 'ERROR'
        elif b=='':
            return a
        else:
            return a+'.'+b
n="3.72" 
n="3.5" 
n="3.0" 
n='3.'                 
if __name__ == "__main__":
    print(Solution().binaryRepresentation( n))              
        
        
#181. Flip Bits
class Solution:
    """
    @param a: An integer
    @param b: An integer
    @return: An integer
    """
    def bitSwapRequired(self, a, b):
        # write your code here
        c=a^b
        cnt=0
        print('{:b}'.format(c))
        for i in range(32):
          if ( c & (1<<i) )!=0:
              cnt+=1
        return cnt
a=14
b=31
if __name__ == "__main__":
    print(Solution().bitSwapRequired(a, b) )  
            
class Solution:
    """
    @param a, b: Two integer
    return: An integer
    """
    def bitSwapRequired(self, a, b):
        # write your code here
        c = a ^ b
        cnt = 0   
        for i in range(32):
            if c & (1 << i) != 0:
                cnt += 1
        return cnt

#182. Delete Digits
class Solution:
    """
    @param A: A positive integer which has N digits, A is a string
    @param k: Remove k digits
    @return: A string
    """
    def DeleteDigits(self, A, k):
        # write your code here
        n=len(A)
        if k==n:
            return ''
        if k>n:
            return ''
        remain=n-k
        
        A_list=list(A)
        res=[]
        index=-1
        for i in range(k,n):
            minmin=float('inf')
            for j in range(index+1,i+1):
                if int(A[j]) < minmin:
                    minmin=int(A[j])
                    index=j
            res.append(str(minmin))
        return str(int(''.join(res)))

 
A = "178542"
k = 4 
A = "254193"
k=1 
A="123454321"
k=1     
        
if __name__ == "__main__":
    print(Solution().DeleteDigits( A, k))            
                
#183. Wood Cut
class Solution:
    """
    @param L: Given n pieces of wood with length L[i]
    @param k: An integer
    @return: The maximum length of the small pieces
    """
    def woodCut(self, L, k):
        # write your code here
        
        largest=max(L)
        
        if k>sum(L):
            return 0
        
        if k==sum(L):
            return 1
        
        
        l=0
        r=largest
        #print(largest)
        #print(len(L))
        
        while l+1<r:
            mid=(r+l)//2
            
            res=0
            for i in range(len(L)):
                res+=L[i]//mid
            if res==k:
                l=mid
            elif res>k:
                l=mid
            else:
                r=mid
        res_m=0
        res_l=0
        res_r=0
        for i in range(len(L)):
                res_m+=L[i]//mid
                res_l+=L[i]//l
                res_r+=L[i]//r
        dic={res_m:mid,res_l:l,res_r:r}
        print(dic)
        
        
        array=[(key-k,v) for (key,v) in dic.items() if key-k >=0]
        
        
        array.sort(key=lambda x: ( x[0] ,-x[1]))
       
        return array[0][1]
        
           
L=[232, 124, 456]
k=7# return 114.       
if __name__ == "__main__":
    print(Solution().woodCut(L, k))              
                
#184. Largest Number
class Solution:
    """
    @param nums: A list of non negative integers
    @return: A string
    """
    def largestNumber(self, nums):
        # write your code here
        
#        # works in Python 2 only 
#        # pythno remove cmp
#        
#        nums=sorted(nums,cmp=lambda x ,y: 1 if str(x)+str(y) < str(y)+str(x)  else -1)
#        #print nums
#       
#        largest=''.join([str(x) for x in nums])
        class comparekey(str):
            def __lt__(x,y):
                return x+y>y+x
        s=[str(x) for x in nums]
        
        s.sort(key=comparekey)
        
        return ''.join(s) if s[0]!='0'  else '0' 


nums=[1, 20, 23, 4, 8]        
nums= [  11, 10, 1 ] 
    
if __name__ == "__main__":
    print(Solution().largestNumber(nums))

#185. Matrix Zigzag Traversal         
class Solution:
    """
    @param matrix: An array of integers
    @return: An array of integers
    """
    def printZMatrix(self, matrix):
        # write your code here
        
        m=len(matrix)
        if m==0:
            return []
        n=len(matrix[0])
        
        from collections import defaultdict
        dd=defaultdict(list)
        
        for i in range(m):
            for j in range(n):
                dd[i+j+1].append(matrix[i][j])
        
        res=[]
        for key in dd:
            if key%2==1:
                res+=reversed(dd[key])
            else:
                res+=dd[key]
        return  res        
 
matrix=       [
  [1, 2,  3,  4],
  [5, 6,  7,  8],
  [9,10, 11, 12]
]
if __name__ == "__main__":
    print(Solution().printZMatrix( matrix))
        
        
#186. Max Points on a Line
"""
Definition for a point.
class Point:
    def __init__(self, a=0, b=0):
        self.x = a
        self.y = b
"""

class Solution:
    """
    @param points: an array of point
    @return: An integer
    """
    def maxPoints(self, points):
        # write your code here
        n=len(points)
        from collections import defaultdict
        d=defaultdict(int)
        if n<=2:
            return n
        
        def gcd(a,b):
            if b==0:
                return a
            return gcd(b,a%b)
        
        res=0
        for i in range(n):
            d.clear()
            
            curmax=0
            overlap=0
            for j in range(i+1,n):
                dx=points[i].x-points[j].x
                dy=points[i].y-points[j].y
                if dx==0 and dy==0:
                    overlap+=1
                    continue
                
                com=gcd(dx,dy)
                dx=dx//com
                dy=dy//com
                
                d[(dx,dy)]+=1
                curmax=max(curmax, d[(dx,dy)])
            res=max(res,curmax+overlap+1)
        return res

            
if __name__ == "__main__":
    print(Solution().maxPoints( points))        
        
#187. Gas Station
class Solution:
    """
    @param gas: An array of integers
    @param cost: An array of integers
    @return: An integer
    """
    def canCompleteCircuit(self, gas, cost):
        # write your code here
        n=len(gas)
        total=0
        summ=0
        start=0
        if n==0:
            return -1
        if sum(gas)-sum(cost)<0:
            return -1
        for i in range(n):
            summ+=gas[i]-cost[i]
            
            if summ<0:
                summ=0
                start=i+1
        
        return start
gas=[5]
cost=[4] 
gas=[1,1,3,1] 
cost=[2,2,1,1]   
gas=[0,4,1,1]
cost=[1,1,4,1]           
if __name__ == "__main__":
    print(Solution().canCompleteCircuit( gas, cost))              
        
#189. First Missing Positive        
class Solution:
    """
    @param A: An array of integers
    @return: An integer
    """
    def firstMissingPositive(self, A):
        # write your code here
        n=len(A)
        if n==0:
            return 1
        i=0
        while i<n:
            while A[i]>0 and A[i]<=n and A[i]!=i+1 and A[i]!=A[A[i]-1]:
                t=A[i]
                A[i]=A[t-1]
                A[t-1]=t
            i+=1
        print(A)
        for i in range(n):
            if A[i]!=i+1:
                return i+1
        return n+1
A=[1,2,0]
A=[3,4,-1,1]    
A=[-1]   
A=[99,94,96,11,92,5,91,89,57,85,66,63,84,81,79,61,74,78,77,30,64,13,58,18,70,69,51,12,32,34,9,43,39,8,1,38,49,27,21,45,47,44,53,52,48,19,50,59,3,40,31,82,23,56,37,41,16,28,22,33,65,42,54,20,29,25,10,26,4,60,67,83,62,71,24,35,72,55,75,0,2,46,15,80,6,36,14,73,76,86,88,7,17,87,68,90,95,93,97,98]  
if __name__ == "__main__":
    print(Solution().firstMissingPositive( A)) 

#190. Next Permutation II    
class Solution:
    """
    @param nums: An array of integers
    @return: nothing
    """
    def nextPermutation(self, nums):
        # write your code here
        n=len(nums)
        temp=[0]*n
        i=n-1
        while i>0 and nums[i]<=nums[i-1]:
            i-=1
        if i==0:
            for j in range(n):
                temp[j]=nums[j]
            for j in range(n):
                nums[j]=temp[n-1-j]
        #print(i)
        
        
        for k in range(i-1):
            temp[k]=nums[k]
            
        
        p=n-1
        
        while p>i and nums[p]<=nums[i-1]:
            p-=1
        nums[i-1],nums[p]=nums[p],nums[i-1]
        
        temp[i-1]=nums[i-1]
        
        for h in range(n-1,i-1,-1):
            temp[n-1+i-h]=nums[h]
        for h in range(n):
            nums[h]=temp[h]
        print(nums)
        return 
nums=[1,2,3]  #1,3,2
nums=[3,2,1] # 1,2,3
nums=[1,1,5] # 1,5,1
nums=[1,3,2]
if __name__ == "__main__":
    print(Solution().nextPermutation( nums))    
         
#191. Maximum Product Subarray
class Solution:
    """
    @param nums: An array of integers
    @return: An integer
    """
    def maxProduct(self, nums):
        # write your code here   
        n=len(nums)
        if n==0:
           return 0
#确定状态:
#最后一步: 考虑最后一个数A[n], 那么乘积最大的就是前面以n - 1为结尾的最大乘积, 再乘上这个数
#子问题: 如果要求以n为结尾的子数组的最大乘积, 先要求以n - 1为结尾的最大乘积
#在这里要注意, 如果A[n]是个负数, 因为负负得正, 所以我们需要以n - 1为结尾的最小乘积
#转移方程:
#维护两个数组, f[i] 和 g[i], f[i]用于记录最大值, g[i]用于记录最小值.
#A[i]代表数组中的第i个数
#转移方程: f[i] = max(i -> 1...n | f[i - 1] * A[i], g[i - 1] * A[i], A[i])
#g[i] = min(i -> 1...n | f[i - 1] * A[i], g[i - 1] * A[i], A[i])
#初始条件与边界情况:
#f[0] = A[0], g[0] = A[0]
#计算顺序:
#从左往右
#最终结果max(i -> 0...n | f[i])
        
        
        
        f=[0 for _ in range(n)]
        g=[0 for _ in range(n)]
        f[0]=nums[0]
        g[0]=nums[0]
        
        
        for i in range(1,n):
            f[i]=max(nums[i],max(nums[i]*f[i-1],nums[i]*g[i-1]))
            g[i]=min(nums[i],min(nums[i]*f[i-1],nums[i]*g[i-1]))
        return max(f)
nums=[2,3,-2,4]
nums=[-2,0,-1]
if __name__ == "__main__":
    print(Solution().maxProduct( nums))        
        
#192. Wildcard Matching
class Solution:
    """
    @param s: A string 
    @param p: A string includes "?" and "*"
    @return: is Match?
    """
    def isMatch(self, s, p):
        # write your code here
        m=len(s)
        n=len(p)
        dp=[[0 for _ in range(n+1)] for _ in range(m+1)]
        
        dp[0][0]=True
        for i in range(1,m+1):
            dp[i][0]=False
            
        print(dp)
        for j in range(1,n+1):
            if p[j-1]=='*':
               dp[0][j]=dp[0][j-1]
            else:
                dp[0][j]=False
                
        for i in range(1,m+1):
            for j in range(1,n+1):
                if p[j-1]!='*':
                    dp[i][j]=dp[i-1][j-1]  and ( p[j-1]==s[i-1] or p[j-1]=='?')
                else:
                    dp[i][j]=dp[i-1][j]  or dp[i][j-1]
        print(dp)
        return dp[m][n]
s="aa"
p='a'  

s="aa"
p='aa' 
s="aaa"
p='aa'
s="aa"
p='*'
s="aa"
p='a*' 
s="ab"
p='?*'  
s="aab"
p='c*a*b'          
if __name__ == "__main__":
    print(Solution().isMatch( s, p))                
        
#196. Missing Number        
class Solution:
    """
    @param nums: An array of integers
    @return: An integer
    """
    def findMissing(self, nums):
        # write your code here
        
#Xor    
        n=len(nums)
        ans=0
        for i in range(n+1):
            ans^=i
        for i in range(n):
            ans^=nums[i]
        
        return ans 
nums=[0, 1, 3]        
if __name__ == "__main__":
    print(Solution().findMissing(nums))        
        
            
#197. Permutation Index             
class Solution:
    """
    @param A: An array of integers
    @return: A long integer
    """
    def permutationIndex(self, A):
        # write your code here
        #先得了解 康托展开
        #https://zh.wikipedia.org/wiki/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80
        n=len(A)
        
        index=1
        for i in range(n):
            count=0
            factor=1
            
            for j in range(i+1,n):
                if A[j]<A[i]:
                    count+=1
            for k in range(1,n-i):
                factor*=k
            index+=count*factor
        return index
        
        
A=     [1,2,4]   
A=[3 ,5, 7 ,4 ,1, 2 ,9, 6 ,8]
if __name__ == "__main__":
    print(Solution().permutationIndex( A))         
        
        
#198. Permutation Index II
class Solution:
    """
    @param A: An array of integers
    @return: A long integer
    """
    def permutationIndexII(self, A):
        # write your code here
        n=len(A)
        if n==0:
            return 0
        
        
        
        count={}
        factor=1
        index=1
        multi_factor=1
        
        for i in range(n-1,-1,-1):
            rank=0
            if A[i] not in count:
                count[A[i]]=0
            count[A[i]]+=1
            multi_factor*=count[A[i]]
            for j in range(i+1,n):
                if A[j]<A[i]:
                    rank+=1
            index+=factor*rank//multi_factor
            factor*=(n-i)
        return index
            
                
A=     [1,2,4]   
A=[3 ,5, 7 ,4 ,1, 2 ,9, 6 ,8]       
if __name__ == "__main__":
    print(Solution().permutationIndexII( A))        
        
#200. Longest Palindromic Substring
class Solution:
    """
    @param s: input string
    @return: the longest palindromic substring
    """
    def longestPalindrome(self, s):
        # write your code here        
        
#https://www.felix021.com/blog/read.php?2040 
#https://leetcode.com/problems/longest-palindromic-substring/discuss/3337/Manacher-algorithm-in-Python-O(n)
 
        T='#'.join('^{}$'.format(s))
        
        C=0
        R=0
        n=len(T)
        p=[0 for _ in range(n)]
        for i in range(1,n-1):
            if R-i>0:
                p[i]=min(p[C-(i-C)],R - i)
            else:
                p[i]=1
#            p[i] = (R > i) and min(R - i, p[2*C - i]) 
            while T[i-p[i]]==T[i+p[i]]:
                p[i]+=1
            
            if p[i]+i>R:
                R=p[i]+i
                C=i
        maxlen,centerindex=max( (n,i)for i , n in enumerate(p))
        #return s[(centerindex- maxlen)//2:(centerindex+ maxlen)//2]
        return s[(centerindex-maxlen+1)//2:maxlen-1+(centerindex-maxlen+1)//2]
s="abcdzdcab"   
s="aaaabaaa"    
s="ccd" 
if __name__ == "__main__":
    print(Solution().longestPalindrome(s))            
            
#201. Segment Tree Build                
"""
Definition of SegmentTreeNode:
class SegmentTreeNode:
    def __init__(self, start, end):
        self.start, self.end = start, end
        self.left, self.right = None, None
"""
class Solution:
    """
    @param: start: start value.
    @param: end: end value.
    @return: The root of Segment Tree.
    """
    def build(self, start, end):
        # write your code here 
        if start>end:
            return None
        root=SegmentTreeNode(start, end)
        if start==end:
            return root
        
        root.left=self.build(root.start,(root.start + root.end) // 2)
        root.right=self.build((root.start + root.end) // 2+1,root.end)
        return root
            
        

#202. Segment Tree Query        
"""
Definition of SegmentTreeNode:
class SegmentTreeNode:
    def __init__(self, start, end, max):
        self.start, self.end, self.max = start, end, max
        self.left, self.right = None, None
"""

class Solution:
    """
    @param root: The root of segment tree.
    @param start: start value.
    @param end: end value.
    @return: The maximum number in the interval [start, end]
    """
    def query(self, root, start, end):
        # write your code here        
        
#### Segment Tree, Divide and Conquer
#- 根据[start,end]跟 mid of (root.start, root.end) 做比较:
#- 简单的2个case: [start,end]全在mid左, 或者[start, end]全在mid右
#- 稍微复杂的3rd case: [start, end]包含了mid, 那么就break into 2 queries
#- [start, node.left.end], [node.right.start, end]        
        
        if start==root.start and end==root.end:
            return root.max
        
        mid=(root.start+root.end)//2
        if mid>=end:
            return self.query(root.left,start,end)
        if start>mid:
            return self.query(root.right,start,end)
        #start <= mid && end > mid
        leftmax=self.query(root.left,start,root.left.end)
        rightmax=self.query(root.right,root.right.start,end)
        return max(leftmax,rightmax)
            
        

#203. Segment Tree Modify
"""
Definition of SegmentTreeNode:
class SegmentTreeNode:
    def __init__(self, start, end, max):
        self.start, self.end, self.max = start, end, max
        self.left, self.right = None, None
"""

class Solution:
    """
    @param root: The root of segment tree.
    @param index: index.
    @param value: value
    @return: nothing
    """
    def modify(self, root, index, value):
        # write your code here
        if root.start==index and root.end==index:
            root.max=value
            return 
        
        
        mid=(root.start+root.end)//2
        if mid >=index and index>=root.start:
            self.modify(root.left,index,value)
        if mid<index and root.end>=index:
            self.modify(root.right,index,value)
        root.max=max(root.left.max,root.right.max)

#204. Singleton
class Solution:
    # @return: The same instance of this class every time
    instance=None
    @classmethod
    def getInstance(cls):
        # write your code here
        if cls.instance is None:
            cls.instance=Solution()
        return cls.instance
        
        
        

#205. Interval Minimum Number
"""
Definition of Interval.
class Interval(object):
    def __init__(self, start, end):
        self.start = start
        self.end = end
"""



class SegmentTree(object):
    def __init__(self,start,end,min=0):
        self.start=start
        self.end=end
        self.min=min
        self.left,self.right=None,None
#Always use self for the first argument to instance methods.

#Always use cls for the first argument to class methods.              
    @classmethod
    def build(cls,start,end,a):
        if start>end:
            return None
        if start==end:
            return SegmentTree(start,end,a[start])
        root=SegmentTree(start,end,a[start])
        mid=(start+end)//2
        root.left=cls.build(start,mid,a)
        root.right=cls.build(mid+1,end,a)
        root.min=min(root.left.min,root.right.min)
        return root
    @classmethod
    def query(self,root,start,end):
        if root.start>end or root.end<start:
            return float('inf')#make it big so that this one is not select
        if root.start>=start and root.end<=end:
            return root.min
        return min(self.query(root.left,start,end),self.query(root.right,start,end))

class Solution:
    """
    @param A: An integer array
    @param queries: An query list
    @return: The result list
    """
    def intervalMinNumber(self, A, queries):
        # write your code here 
        root=SegmentTree.build(0,len(A)-1,A)
        res=[]
        
        for x in queries:
            #res.append(SegmentTree.query(root,x.start,x.end))
            res.append(SegmentTree.query(root,x[0],x[1]))
        return res

A= [1,2,7,8,5]
queries=[(1,2),(0,4),(2,4)]
if __name__ == "__main__":
    print(Solution().intervalMinNumber(A, queries))            
                   
#206. Interval Sum
"""
Definition of Interval.
class Interval(object):
    def __init__(self, start, end):
        self.start = start
        self.end = end
"""

class SegmentTree(object):
    def __init__(self,start,end,sum=0):
        self.start=start
        self.end=end
        self.sum=sum
        self.left,self.right=None,None
#Always use self for the first argument to instance methods.

#Always use cls for the first argument to class methods.              
    @classmethod
    def build(cls,start,end,a):
        if start>end:
            return None
        if start==end:
            return SegmentTree(start,end,a[start])
        root=SegmentTree(start,end,a[start])
        mid=(start+end)//2
        root.left=cls.build(start,mid,a)
        root.right=cls.build(mid+1,end,a)
        root.sum=root.left.sum+root.right.sum
        return root
    @classmethod
    def query(self,root,start,end):
        if root.start>end or root.end<start:
            return 0#make it big so that this one is not select
        if root.start>=start and root.end<=end:
            return root.sum
        return self.query(root.left,start,end)+self.query(root.right,start,end)
class Solution:
    """
    @param A: An integer list
    @param queries: An query list
    @return: The result list
    """
    def intervalSum(self, A, queries):
        # write your code here
        def intervalMinNumber(self, A, queries):
        # write your code here 
        root=SegmentTree.build(0,len(A)-1,A)
        res=[]
        
        for x in queries:
            #res.append(SegmentTree.query(root,x.start,x.end))
            res.append(SegmentTree.query(root,x[0],x[1]))
        return res

A= [1,2,7,8,5]
queries=[(0,4),(1,2),(2,4)]
if __name__ == "__main__":
    print(Solution().intervalMinNumber(A, queries))   

#207. Interval Sum II
class SegmentTree(object):
    def __init__(self,start,end,sum=0):
        self.start=start
        self.end=end
        self.sum=sum
        self.left,self.right=None,None
#Always use self for the first argument to instance methods.

#Always use cls for the first argument to class methods.              
    @classmethod
    def build(cls,start,end,a):
        if start>end:
            return None
        if start==end:
            return SegmentTree(start,end,a[start])
        root=SegmentTree(start,end,a[start])
        mid=(start+end)//2
        root.left=cls.build(start,mid,a)
        root.right=cls.build(mid+1,end,a)
        root.sum=root.left.sum+root.right.sum
        return root
    @classmethod
    def query(cls,root,start,end):
        if root.start>end or root.end<start:
            return 0#make it big so that this one is not select
        if root.start>=start and root.end<=end:
            return root.sum
        return cls.query(root.left,start,end)+cls.query(root.right,start,end)
    @classmethod
    def modify(cls,root, index, value):
        if root.start==index and root.end==index:
            root.sum=value
            return 
        mid=(root.start+root.end)//2
        if mid>=index and root.start<=index:
            cls.modify(root.left,index,value)
        if mid<index and root.end >=index:
            cls.modify(root.right,index,value)
        root.sum=root.left.sum+root.right.sum
            
class Solution:
    """
    @param: A: An integer array
    """
    def __init__(self, A):
        # do intialization if necessary
        self.root=SegmentTree.build(0,len(A)-1,A)

    """
    @param: start: An integer
    @param: end: An integer
    @return: The sum from start to end
    """
    def query(self, start, end):
        
        # write your code here
        return SegmentTree.query(self.root,start,end)
        

    """
    @param: index: An integer
    @param: value: An integer
    @return: nothing
    """
    def modify(self, index, value):
        # write your code here
         SegmentTree.modify(self.root,index, value)
        
        
        
A= [1,2,7,8,5]
#query(0, 2), return 10.
start=0
end=2
if __name__ == "__main__":
    print(Solution().query(start, end))         
        
#209. First Unique Character in a String        
class Solution:
    """
    @param str: str: the given string
    @return: char: the first unique character in a given string
    """
    def firstUniqChar(self, str):
        # Write your code here
        d=[0 for _ in range(256)]
        
        for x in str:
            d[ord(x)]+=1
        for i,x in enumerate(d):
            if  x==1:
                return chr(i)
        
str=     "abaccdeff" #b   
str= "aabc"   
if __name__ == "__main__":
    print(Solution().firstUniqChar( str))   


#211. String Permutation
class Solution:
    """
    @param A: a string
    @param B: a string
    @return: a boolean
    """
    def Permutation(self, A, B):
        # write your code here
        from collections import Counter
        return Counter(A)==Counter(B)



     
        
#212. Space Replacement
class Solution:
    """
    @param: string: An array of Char
    @param: length: The true length of the string
    @return: The true length of new string
    """
    def replaceBlank(self, string, length):
        # write your code here 
        if string is None:
            return length
            
        spaces = 0
        for c in string:
            if c == ' ':
                spaces += 1
        
        L = length + spaces * 2
        index = L - 1
        for i in range(length - 1, -1, -1):
            if string[i] == ' ':
                string[index] = '0'
                string[index - 1] = '2'
                string[index - 2] = '%'
                index -= 3
            else:
                string[index] = string[i]
                index -= 1
        return L
                
string="Mr John Smith" 
length=13               
if __name__ == "__main__":
    print(Solution().replaceBlank(string, length))         
        
        
        
#213. String Compression
class Solution:
    """
    @param str: a string
    @return: a compressed string
    """
    def compress(self, s):
        # write your code here
        if not s:
            return s
        
        res=''
        i=1
        count=1
        s+='#'
        while i<len(s):
            
            
            if i<len(s) and s[i]==s[i-1] :
                count+=1
                
                
            else:
                               
                res+=s[i-count]+str(count)
                count=1
            
            i+=1
        return res if len(res)<len(s)-1 else s[:-1]
            
s='aabcccccaaa' #return a2b1c5a3
s='aabbcc' #return aabbcc
s='aaaa' #return a4        
if __name__ == "__main__":
    print(Solution().compress(s))        
        
        
#221. Add Two Numbers II
"""
Definition of ListNode
class ListNode(object):
    def __init__(self, val, next=None):
        self.val = val
        self.next = next
"""

class Solution:
    """
    @param l1: The first list.
    @param l2: The second list.
    @return: the sum list of l1 and l2.
    """
    def addLists2(self, l1, l2):
        # write your code here
        
        if not l1:
            return l2
        if not l2 :
            return l1
        
        s1=[]
        s2=[]
        
        while l1:
            s1.append(l1.val)
            l1=l1.next
        while l2:
            s2.append(l2.val)
            l2=l2.next
        sm=0
        pre=None
        while s1 or s2:
            if s1:
                sm+=s1.pop()
            if s2:
                sm+=s2.pop()
            
            cur=ListNode(sm%10)
            sm//=10
            cur.next=pre
            pre=cur
            
       
         
        if sm==0:
#           while cur:
#              print(cur.val)
#              cur=cur.next   
           return cur
        else:
           head=ListNode(sm%10)
           head.next=cur
           
#           while head:
#              print(head.val)
#              head=head.next
           
           
           return head
#6->1->7 + 2->9->5
l1=ListNode(6)
l1.next=ListNode(1)
l1.next.next=ListNode(7)

l2=ListNode(3)
l2.next=ListNode(8)
l2.next.next=ListNode(3)
#l2.next.next.next=ListNode(1)



if __name__ == "__main__":
    print(Solution().addLists2(l1, l2))           
             
#222. Setter and Getter
class School:
    def __init__(self):
        
        self.name=None
    '''
     * Declare a setter method `setName` which expect a parameter *name*.
     
    '''   
    # write your code here
    def setName(self,A):
        self.name=A  
        

    '''
     * Declare a getter method `getName` which expect no parameter and return
     * the name of this school
    '''
    # write your code here
    def getName(self):
        return self.name
        

    '''
     * Declare a getter method `getName` which expect no parameter and return
     * the name of this school
    '''
    # write your code here
        

    '''
     * Declare a getter method `getName` which expect no parameter and return
     * the name of this school
    '''
    # write your code here      
#223. Palindrome Linked List
"""
Definition of ListNode
class ListNode(object):
    def __init__(self, val, next=None):
        self.val = val
        self.next = next
"""

class Solution:
    """
    @param head: A ListNode.
    @return: A boolean.
    """
    def isPalindrome(self, head):
        # write your code here
        if not head:
            return True
        
        fast=head
        slow=head
        while fast and fast.next:
            fast=fast.next.next
            slow=slow.next
        
        pre=None
        cur=slow
        
        while cur:
            temp=cur.next
            cur.next=pre
            pre=cur
            cur=temp
            
        p1=head
        p2=pre
        
        while p1 and p2:
            if p1.val!=p2.val:
                return False
            p1=p1.next
            p2=p2.next
        return True
    
    
#227. Mock Hanoi Tower by Stacks
class Tower:
    """
    @param: i: An integer from 0 to 2
    """
    def __init__(self, i):
        # create three towers
        self.disks=[]
        

    """
    @param: d: An integer
    @return: nothing
    """
    def add(self, d):
        # Add a disk into this tower
        if len(self.disks)>0 and self.disks[-1]<=d:
            print('eror adding disks')
        else:
            self.disks.append(d)

    """
    @param: t: a tower
    @return: nothing
    """
    def moveTopTo(self, t):
        # Move the top disk of this tower to the top of t.
        t.add(self.disks.pop())

    """
    @param: n: An integer
    @param: destination: a tower
    @param: buffer: a tower
    @return: nothing
    """
    def move_disks(self, n, destination, buffer):
        # Move n Disks from this tower to destination by buffer tower
        if n>0:
           self.move_disks(n-1,buffer,destination)
           self.moveTopTo(destination)
           buffer.move_disks(n-1,destination,self)
        

    """
    @return: Disks
    """
    def get_disks(self):
        # write your code here
        return self.disks
        

"""
Your Tower object will be instantiated and called as such:
towers = [Tower(0), Tower(1), Tower(2)]
for i in xrange(n - 1, -1, -1): towers[0].add(i)
towers[0].move_disks(n, towers[2], towers[1])
print towers[0], towers[1], towers[2]
"""
            

#245. Subtree        
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""

class Solution:
    """
    @param T1: The roots of binary tree T1.
    @param T2: The roots of binary tree T2.
    @return: True if T2 is a subtree of T1, or false.
    """
    def isSubtree(self, T1, T2):
        # write your code here
        def isEqualTree(h1,h2):
            if not h1 and not h2:
                return True
            if not h1 and h2:
                return False
            if not h2 and h1:
                return False
            
            if h1.val!=h2.val:
                return False
            return isEqualTree( h1.left, h2.left)  and isEqualTree( h1.right, h2.right)
        
        
        def hasSubtree(T1, T2):
            
           if  not T2:
               return True
           if not T1 and  T2:
               return False
           if isEqualTree(T1, T2):
              return True
           else:
               
               if hasSubtree(T1.left, T2):
                   return True
               if hasSubtree(T1.right, T2):
                   return True
           return False
               
        return hasSubtree(T1, T2)
            
        
#247. Segment Tree Query II
"""
Definition of SegmentTreeNode:
class SegmentTreeNode:
    def __init__(self, start, end, count):
        self.start, self.end, self.count = start, end, count
        self.left, self.right = None, None
"""


class Solution:
    """
    @param: root: The root of segment tree.
    @param: start: start value.
    @param: end: end value.
    @return: The count number in the interval [start, end]
    """
    def query(self, root, start, end):
        # write your code here  
        if not root:
            return 0
        if root.start>end or root.end<start:
            return 0#make it big so that this one is not select
        if root.start>=start and root.end<=end:
            return root.count
        return self.query(root.left,start,end)+self.query(root.right,start,end)
        
        
        

#248. Count of Smaller Number        
class Solution:
    """
    @param A: An integer array
    @param queries: The query list
    @return: The number of element in the array that are smaller that the given integer
    """
    def countOfSmallerNumber(self, A, queries):
        # write your code here
        
        def bisearch(start,end,target):
            if start>end:
                return 0
            
            while start<=end:
                mid=(start+end)//2
                
                if A[mid]<target:
                    start=mid+1
                    
                else:
                    end=mid-1
                    res=mid
            return res
        
        
        ans=[]
        A.sort()
        for query in queries:
            ans.append(bisearch(0,len(A)-1,query))
        return ans
A=[1,2,7,8,5]   
queries=[1,8,5]         
if __name__ == "__main__":
    print(Solution().countOfSmallerNumber( A, queries))                  
        
#248. Count of Smaller Number        

class SegmentTree(object):
    def __init__(self,start,end,count=0):
        self.start=start
        self.end=end
        self.count=count
        self.left,self.right=None,None

    
        
        
        
class Solution:
    """
    @param A: An integer array
    @param queries: The query list
    @return: The number of element in the array that are smaller that the given integer
    """
    def countOfSmallerNumber(self, A, queries):
        root=self.build(0, 10000)
        res=[]
        
        for x in A:
            self.modify(root,x, 1)
        
        for i in queries:
            count=0
            if i>0:
                count=self.query(root,0,i-1)
            res.append(count)
        return res
        
        
    def build(self,start,end):
        if start>=end:
            return SegmentTree(start,end,0)
       
        root=SegmentTree(start,end,0)
        mid=(start+end)//2
        root.left=self.build(start,mid)
        root.right=self.build(mid+1,end)
        
        return root
    def modify(self,root, index, value):
        if root.start==index and root.end==index:
            root.count+=value
            return 
        mid=(root.start+root.end)//2
        if mid>=index and root.start<=index:
            self.modify(root.left,index,value)
        if mid<index and root.end >=index:
            self.modify(root.right,index,value)
        root.count=root.left.count+root.right.count
    def query(self,root,start,end):
        if root.start>end or root.end<start:
            return 0#make it big so that this one is not select
        if root.start>=start and root.end<=end:
            return root.count
        return self.query(root.left,start,end)+self.query(root.right,start,end)
        
A=[1,2,7,8,5]   
queries=[1,8,5]    
A=[1,2,3,4,5,6]
queries=[1,2,3,4]     
if __name__ == "__main__":
    print(Solution().countOfSmallerNumber( A, queries)) 


         
        
#249. Count of Smaller Number before itself
        

       
class SegmentTree(object):
    def __init__(self,start,end,count=0):
        self.start=start
        self.end=end
        self.count=count
        self.left,self.right=None,None
class Solution:
    """
    @param A: an integer array
    @return: A list of integers includes the index of the first number and the index of the last number
    """
    def countOfSmallerNumberII(self, A):
        # write your code here
        if not A:
            return []
        root=self.build(0, max(A))
        res=[]
        for i in A:
            count=0
            if i>0:
                count=self.query(root,0,i-1)
            res.append(count)
            self.modify(root,i,1)
        return res
        
        
    def build(self,start,end):
        if start>=end:
            return SegmentTree(start,end,0)
       
        root=SegmentTree(start,end,0)
        mid=(start+end)//2
        root.left=self.build(start,mid)
        root.right=self.build(mid+1,end)
        
        return root
    def modify(self,root, index, value):
        if root.start==index and root.end==index:
            root.count+=value
            return 
        mid=(root.start+root.end)//2
        if mid>=index and root.start<=index:
            self.modify(root.left,index,value)
        if mid<index and root.end >=index:
            self.modify(root.right,index,value)
        root.count=root.left.count+root.right.count
    def query(self,root,start,end):
        if root.start>end or root.end<start:
            return 0#make it big so that this one is not select
        if root.start>=start and root.end<=end:
            return root.count
        return self.query(root.left,start,end)+self.query(root.right,start,end)        
        
        
A=[1,2,7,8,5]   
if __name__ == "__main__":
    print(Solution().countOfSmallerNumberII(A))          
                       
            
#249. Count of Smaller Number before itself           
class Solution:
    """
    @param A: an integer array
    @return: A list of integers includes the index of the first number and the index of the last number
    """
    def countOfSmallerNumberII(self, A):
        # write your code here
        if not A:
            return []
        import bisect
        
        s=[]
        res=[]
        
        for a in A:
            i=bisect.bisect_left(s,a)
            res.append(i)
            bisect.insort(s,a)
        return res
A=[1,2,7,8,5]  
if __name__ == "__main__":
    print(Solution().countOfSmallerNumberII(A))   



#254. Drop Eggs
class Solution:
    """
    @param n: An integer
    @return: The sum of a and b
    """
    def dropEggs(self, n):
        # write your code here
#https://www.quora.com/You-have-2-eggs-You-are-on-a-100-floor-building-You-drop-the-egg-from-a-particular-floor-It-breaks-or-survives-If-it-survives-you-can-throw-the-same-egg-from-a-higher-floor-How-many-attempts-do-you-need-to-identify-the-max-floor-at-which-the-egg-doesnt-break-when-thrown-down
        for i in range(2*n):
            if i*i+i>=2*n:
                return i
n=100           
if __name__ == "__main__":
    print(Solution().dropEggs( n))          
                        
#360. Sliding Window Median        
class Solution:
    """
    @param nums: A list of integers
    @param k: An integer
    @return: The median of the element inside the window at each moving
    """
    def medianSlidingWindow(self, nums, k):
        # write your code here
        win=nums[:k]
        win.sort()
        median=[]
        import bisect
        for a,b in zip(nums,nums[k:]+[0]):
            print(a,b)
            median.append(win[(k-1)//2])
            #win.remove(a)   TLE   用  POP 比remove 快
            win.pop(bisect.bisect_left(win,a))
            bisect.insort(win,b)
        return median
       
nums=[1,2,7,8,5]  
k = 3        
if __name__ == "__main__":
    print(Solution().medianSlidingWindow(nums, k))         
        
        
#360. Sliding Window Median        
class Solution:
    """
    @param nums: A list of integers
    @param k: An integer
    @return: The median of the element inside the window at each moving
    """
    def medianSlidingWindow(self, nums, k):
        lh=[]
        rh=[]
        rv=[]
        if not nums:
            return []
            
        if k==1:
            return nums
        import heapq
        n=len(nums)
        for i,x in enumerate(nums[:k]):
            heapq.heappush(lh,(-x,i))
        
        for _ in range(k//2):
            heapq.heappush(rh,(-lh[0][0],lh[0][1]))
            heapq.heappop(lh)
        
        
        for i,x in enumerate(nums[k:]):
            rv.append(-lh[0][0])
            if  x>=rh[0][0]:
                heapq.heappush(rh,(x,i+k))
                if nums[i]<=rh[0][0]:
                   
                   heapq.heappush(lh,(-rh[0][0],rh[0][1]))
                   heapq.heappop(rh)
                else:
                    pass
            else:
                heapq.heappush(lh,(-x,i+k))
                if nums[i]>=rh[0][0]:
                   heapq.heappush(rh,(-lh[0][0],lh[0][1]))
                   heapq.heappop(lh)
                else:
                    pass
            while lh and lh[0][1]<=i:
                heapq.heappop(lh)
            while rh and rh[0][1]<=i:
                heapq.heappop(rh)
        rv.append(-lh[0][0])
        return rv

nums=[1,2,7,7,2]
k=1
nums=[1,3,-1,-3,5,3,6,7] 
k = 3     
if __name__ == "__main__":
    print(Solution().medianSlidingWindow(nums, k))             
        

#362. Sliding Window Maximum 
class Solution:
    """
    @param: nums: A list of integers
    @param: k: An integer
    @return: The maximum number inside the window at each moving
    """
    def maxSlidingWindow(self, nums, k):
        # write your code here  
        wh=[]
        
        res=[]
        if not nums:
            return []
            
        if k==1:
            return nums
        import heapq
        n=len(nums)
        for i,x in enumerate(nums[:k]):
            heapq.heappush(wh,(-x,i))
        
        for i, x in enumerate(nums[k:]):
            res.append(-wh[0][0])
            heapq.heappush(wh,(-x,i+k))
            while wh and wh[0][1]<=i:
                heapq.heappop(wh)
        #print(wh)
        res.append(-wh[0][0])
        return res        
            
nums=[1,2,7,7,8]
k=3
if __name__ == "__main__":
    print(Solution().maxSlidingWindow( nums, k))  


#362. Sliding Window Maximum 
class Solution:
    """
    @param: nums: A list of integers
    @param: k: An integer
    @return: The maximum number inside the window at each moving
    """
    def maxSlidingWindow(self, nums, k):
        # write your code here  
        
        
        res=[]
        if not nums:
            return []
            
        if k==1:
            return nums
        from collections import deque
        dq=deque()
        
        for i in range(len(nums)):
            if dq and dq[0]<i-k+1:
                dq.popleft()
            while dq and nums[dq[-1]]<nums[i]:
                dq.pop()
            dq.append(i)
            
            if i>k-2:
                res.append(nums[dq[0]])
        return res
                
nums=[1,2,7,7,8]
k=3
if __name__ == "__main__":
    print(Solution().maxSlidingWindow( nums, k))                        
                    
#363. Trapping Rain Water
class Solution:
    """
    @param heights: a list of integers
    @return: a integer
    """
    def trapRainWater(self, heights):
        # write your code here
#https://leetcode.com/problems/trapping-rain-water/discuss/17395/A-different-O(n)-approach-easy-to-understand-and-simple-code        


#scan A both from left to right and right to left, record the largest seen during the scan; then for each position the water level should be the min of the 2 large value.        
        
        n=len(heights)
        if n==0:
            return 0
        ltr=[0 for _ in range(n)]
        rtl=[0 for _ in range(n)]
        ltr[0]=heights[0]
        rtl[-1]=heights[-1]
        res=0
        for i in range(1,n):
            ltr[i]=max(ltr[i-1],heights[i])
        for i in range(n-2,-1,-1):
            rtl[i]=max(rtl[i+1],heights[i])
        for i in range(1,n-1):
            res+=min(ltr[i],rtl[i])-heights[i]
        return res
heights=[0,1,0,2,1,0,1,3,2,1,2,1]
if __name__ == "__main__":
    print(Solution().trapRainWater(heights))             
        

#364. Trapping Rain Water II
class Solution:
    """
    @param heights: a matrix of integers
    @return: an integer
    """
    def trapRainWater(self, heights):
        # write your code here
#https://leetcode.com/problems/trapping-rain-water-ii/discuss/89466/python-solution-with-heap        
#https://leetcode.com/problems/trapping-rain-water-ii/discuss/89472/Visualization-No-Code
        m=len(heights)     
        n=len(heights[0])
        
        import heapq
        heap=[]
        
        visited=[[0 for _ in range(n)] for _ in range(m)]
        
        for i in range(m):
            for j in range(n):
                if i==0 or i==m-1 or j==0 or j==n-1:
                    heapq.heappush(heap,(heights[i][j],i,j))
                    visited[i][j]=1
        res=0
        
        while heap:
            height,i,j=heapq.heappop(heap)
            
            for x,y in ((i-1,j) ,(i+1,j),(i,j-1),(i,j+1)):
                if 0<=x<m  and 0<=y<n and visited[x][y]==0:
                    res+= max(0,height-heights[x][y])
                    heapq.heappush(heap,(     max(heights[x][y],height), x,y))
                    visited[x][y]=1
        return res
heights=[[12,13,0,12],[13,4,13,12],[13,8,10,12],[12,13,12,12],[13,13,13,13]]
heights=[
  [1,4,3,1,3,2],
  [3,2,1,3,2,4],
  [2,3,3,2,3,1]
]                    
if __name__ == "__main__":
    print(Solution().trapRainWater(heights))               
        
#365. Count 1 in Binary
class Solution:
    """
    @param: num: An integer
    @return: An integer
    """
    def countOnes(self, num):
        # write your code here  
        #n & (n - 1) drops the lowest set bit. It's a neat little bit trick.
        #Let's use n = 00101100 as an example. This binary representation has three 1s.

        #If n = 00101100, then n - 1 = 00101011, so n & (n - 1) = 00101100 & 00101011 = 00101000. Count = 1.

        #If n = 00101000, then n - 1 = 00100111, so n & (n - 1) = 00101000 & 00100111 = 00100000. Count = 2.

        #If n = 00100000, then n - 1 = 00011111, so n & (n - 1) = 00100000 & 00011111 = 00000000. Count = 3.

        #n is now zero, so the while loop ends, and the final count (the numbers of set bits) is returned.
#        count=0
#        while num !=0:
#            num=num&(num-1)
#            count+=1
#        return count 在 Python里不能，因为Python不止32位，在JAVA 里可以
        
        count=0
        mask=1
        for _ in range(32):
            if num&mask !=0:
                count+=1
            mask=mask<<1
        return count
        
            
#366. Fibonacci
class Solution:
    """
    @param n: an integer
    @return: an ineger f(n)
    """
    def fibonacci(self, n):
        # write your code here
        #0, 1, 1, 2, 3, 5, 8, 13, 21, 34 ...
#        Given 1, return 0
#Given 2, return 1
#Given 10, return 34
        a=0
        b=1
        if n==1:
            return 0
        if n==2 or n==3:
            return 1
        for _ in range(n-2):
            a,b=b,a+b
            print(a,b)
        return b

n=9          
if __name__ == "__main__":
    print(Solution().fibonacci( n))   

#367. Expression Tree Build            
"""
Definition of ExpressionTreeNode:
class ExpressionTreeNode:
    def __init__(self, symbol):
        self.symbol = symbol
        self.left, self.right = None, None
"""

class myTreeNode():
      def __init__(self,val,s):
          self.left=None
          self.right=None
          self.val=val
          self.exp_node=ExpressionTreeNode(s)
          
      def __str__(self):
        return str(self.val) + '  '+ self.exp_node.symbol
class Solution:
    """
    @param: expression: A string array
    @return: The root of expression tree
    """
    def build(self, expression):
        # write your code here
        root=self.create_tree(expression)
        return self.copy_tree(root)
        
#https://zhengyang2015.gitbooks.io/lintcode/expression_tree_build_367.html        
#观察example，可以看出所有叶节点都为数字。如果给每个元素赋予一个优先级， 和 ／ 为2， ＋ 和 － 为1，
#数字为极大值，然后规定优先级越大的越在下，越小的越在上。这样，这道题就转化为构建*Min Tree，
#和之前的Max Tree做法类似，只是这里维持的是一个递增栈。同时，当遇见“（”时，提高优先级，遇见“）”时，
#降低优先级。
#遍历数组，给每个新来的元素赋予一个val值用以比较优先级。 * 和 ／ 为2， ＋ 和 － 为1， 数字为极大值。
#此时看栈顶元素（若栈为空则直接加入）。为了维持一个递增栈，若栈顶元素比新来元素val大（或相等），则出栈；
#若栈顶元素比新来元素val小，则break。
#若2中栈顶元素出栈，此时若栈为空，则将出栈元素作为新来元素的左节点，并将新来元素加入栈中；若不为空，
#看新栈顶元素，若新栈顶元素比新来元素val小，则将出栈元素作为新来元素的左孩子，并将新来元素加入栈中；
#若新栈顶元素比新来元素val大（或相等），则将出栈元素作为新栈顶元素的右节点，重复2-3，直到栈为空或者栈顶元素
#比新来元素要小，将新来元素加入栈中。
#
#tips：在遍历万整个数组后，多加一个值，将其val赋值为极小，这样所有元素都会出栈并构建成完整的树。  
    def get_val(self,a,base):
        if a=='+' or a=='-':
            if base==float('inf'):
                return base
            return base+1
        elif a=='/' or a=='*':
            if base==float('inf'):
                return base
            return base+2
        return float('inf')
    
    def create_tree(self,expression):
        stack=[]
        base=0
        for i in range(len(expression)):
            if expression[i]=='(':
                if base!=float('inf'):
                    base+=10
                continue
            elif expression[i]==')':
                if base!=float('inf'):
                    base-=10
                continue
            val=self.get_val(expression[i],base)
            node= myTreeNode(val,expression[i])
            print( 'val-->', val,'expression[i]-->', expression[i])
            while stack and node.val <= stack[-1].val:
                print('starting********')
                for i in range(len(stack)):
                      print(stack[i],'   ',stack[i].left,'   ',stack[i].right)
                print('ending********')
                node.left=stack.pop()
                
            if stack:
                stack[-1].right=node
            stack.append(node)
        if not stack:
            return None
        
        return stack[0]
    
    def  copy_tree(self,root):
        if not root:
            return None
        root.exp_node.left=self.copy_tree(root.left)
        root.exp_node.right=self.copy_tree(root.right)
        return root.exp_node
    #def myprint(self,node):
        
  
    
expression=["2","*","6","-","(","23","+","7",")","/","(","1","+","2",")"]          
if __name__ == "__main__":
    print(Solution().build( expression))               
                        

#368. Expression Evaluation
class ExpressionTreeNode:
    def __init__(self, symbol):
        self.symbol = symbol
        self.left, self.right = None, None

class myTreeNode():
    def __init__(self,val,s):
          self.left=None
          self.right=None
          self.val=val
          self.exp_node=ExpressionTreeNode(s)

class Solution:
    """
    @param expression: a list of strings
    @return: an integer
    """
    def build(self, expression):
        # write your code here
        root=self.create_tree(expression)
        return self.copy_tree(root)
    def get_val(self,a,base):
        if a=='+' or a=='-':
            if base==float('inf'):
                return base
            return base+1
        elif a=='/' or a=='*':
            if base==float('inf'):
                return base
            return base+2
        return float('inf')
    
    def create_tree(self,expression):
        stack=[]
        base=0
        for i in range(len(expression)):
            if expression[i]=='(':
                if base!=float('inf'):
                    base+=10
                continue
            elif expression[i]==')':
                if base!=float('inf'):
                    base-=10
                continue
            val=self.get_val(expression[i],base)
            node= myTreeNode(val,expression[i])
            
            while stack and node.val <= stack[-1].val:
                node.left=stack.pop()
            if stack:
                stack[-1].right=node
            stack.append(node)
        if not stack:
            return None
        
        return stack[0]
    
    def  copy_tree(self,root):
        if not root:
            return None
        root.exp_node.left=self.copy_tree(root.left)
        root.exp_node.right=self.copy_tree(root.right)
        return root.exp_node
    
    
    
    def evaluateExpression(self, expression):
        if not  expression:
            return 0
        root=self.build( expression)
        if not root:
            return 0
        def calculate(root):
            if root.symbol not in ('+','-','*','/'):
                return int(root.symbol)
            else:
                if root.symbol=='+':
                    return calculate(root.left)+calculate(root.right)
                if root.symbol=='-':
                    return calculate(root.left)-calculate(root.right)
                if root.symbol=='*':
                    return calculate(root.left)*calculate(root.right)
                if root.symbol=='/':
                    return calculate(root.left)//calculate(root.right)
        return calculate(root)
expression=["2","*","6","-","(","23","+","7",")","/","(","1","+","2",")"]  
expression=[]  
expression=["(","(","(","(","(",")",")",")",")",")"]     
if __name__ == "__main__":
    print(Solution().evaluateExpression( expression))              
        
        

#368. Expression Evaluation
class Solution:
#https://www.jiuzhang.com/solution/expression-evaluation/#tag-other-lang-python
    P={'+':1,'-':1,'*':2,'/':2}
    """
    @param expression: a list of strings
    @return: an integer
    """
    def evaluateExpression(self, expression):
        
        new_e=self.dal2rpn(expression)
        if not new_e:
            return 0
        res=self.eval_rpn(new_e)
        return res

#先将对人友好的中缀表达式 (即 1 + 2)，转为对计算机友好的后缀表达式 (即 1 2 +)
#在用栈做运算
#
#REF: Reverse Polish Notation
    def dal2rpn(self,expression):
        stack=[]
        res=[]
        
        for char in expression:
            if char.isdigit():
                res.append(char)
                continue
            elif char in self.P:
                while stack and stack[-1] in self.P and self.P[stack[-1]]>=self.P[char]:
                    res.append(stack.pop())
                stack.append(char)
            elif char=='(':
                stack.append(char)
            elif char==')':
                while stack and stack[-1]!='(':
                      res.append(stack.pop())
                stack.pop()
        while stack:
            res.append(stack.pop())
        return res
   
        
        
    def eval_rpn(self, expression):
        stack=[]
        
        for char in expression:
            if char.isdigit():
                stack.append(int(char))
                continue
            
            
            b=stack.pop()
            a=stack.pop()
            if char =='+':
                stack.append(a+b)
            elif char =='-':
                stack.append(a-b)
            elif char =='*':
                stack.append(a*b)
            elif char =='/':
                stack.append(a//b)
        return stack[0]
expression=["2","*","6","-","(","23","+","7",")","/","(","1","+","2",")"]  
expression=[]  
expression=["(","(","(","(","(",")",")",")",")",")"]     
if __name__ == "__main__":
    print(Solution().evaluateExpression( expression))              
                        
        
#370. Convert Expression to Reverse Polish Notation        
class Solution:
    P={'+':1,'-':1,'*':2,'/':2}
    """
    @param expression: A string array
    @return: The Reverse Polish notation of this expression
    """
    def convertToRPN(self, expression):
        # write your code here
        stack=[]
        res=[]
        
        for char in expression:
            if char.isdigit():
                res.append(char)
                continue
            elif char in self.P:
                while stack and stack[-1] in self.P and self.P[stack[-1]]>=self.P[char]:
                    res.append(stack.pop())
                stack.append(char)
            elif char=='(':
                stack.append(char)
            elif char==')':
                while stack and stack[-1]!='(':
                      res.append(stack.pop())
                stack.pop()
        while stack:
            res.append(stack.pop())
        return res
expression=["3","-","4","+","5"]
if __name__ == "__main__":
    print(Solution().convertToRPN( expression))


#371. Print Numbers by Recursion
class Solution:
    """
    @param n: An integer
    @return: An array storing 1 to the largest number with n digits.
    """
    def numbersByRecursion(self, n):
        # write your code here
        res=[]
        def myprint(n,res):
            
            if n<1:
                return []
            
            myprint(n-1,res)
     
            begin=10**(n-1)
            end=10**n
            for i in range(begin,end):
                res.append(i)
                
            
        myprint(n,res)
                
        return res
#Given N = 1, return [1,2,3,4,5,6,7,8,9].
#
#Given N = 2, return [1,2,3,4,5,6,7,8,9,10,11,12,...,99]




n=1  
n=2
n=3   
n=5     
if __name__ == "__main__":
    print(Solution().numbersByRecursion( n))

#372. Delete Node in a Linked List
"""
Definition of ListNode
class ListNode(object):

    def __init__(self, val, next=None):
        self.val = val
        self.next = next
"""


class Solution:
    """
    @param: node: the node in the list should be deletedt
    @return: nothing
    """
    def deleteNode(self, node):
        # write your code here
       
        if node.next==None:
               node=None    
       
        node.val=node.next.val
        node.next=node.next.next
            
        
#Linked list is 1->2->3->4, and given node 3, delete the node in place 1->2->4

head= ListNode(1)
head.next=ListNode(2)
head.next.next=ListNode(3)
head.next.next.next=ListNode(4)
node=head.next.next
#1->2->3->4
if __name__ == "__main__":
    print(Solution().deleteNode(node))        


    
    
#373. Partition Array by Odd and Even
class Solution:
    """
    @param: nums: an array of integers
    @return: nothing
    """
    def partitionArray(self, nums):
        # write your code here
        n=len(nums)
        
        l=0
        r=n-1
        while l<r:
            while l<r and nums[l]%2==1:
                l+=1
            while l<r and nums[r]%2==0:
                r-=1
            
            nums[l],nums[r]=nums[r],nums[l]
        print(nums)
nums=[1, 2, 3, 4]   

nums=[] 
nums=[2]
nums=[2,4,6,8]
if __name__ == "__main__":
    print(Solution().partitionArray( nums))        
    
    
#374. Spiral Matrix
class Solution:
    """
    @param matrix: a matrix of m x n elements
    @return: an integer list
    """
    def spiralOrder(self, matrix):
        # write your code here
        
#https://www.jiuzhang.com/solution/spiral-matrix/#tag-highlight
        
        m=len(matrix)
        if m==0:
            return []
        n=len(matrix[0])
        
        res=[]
        
        dr=[0,1,0,-1]
        dc=[1,0,-1,0]
      
        d=0
        
        x=0
        y=0
        for _ in range(m*n):
                res.append(matrix[x][y])
                matrix[x][y]=-1
                nx=x+dr[d]
                ny=y+dc[d]
                if nx<0 or nx>=m or  ny<0 or ny>=n or  matrix[nx][ny]  ==-1:
                    d=(d+1)%4
                    nx=x+dr[d]
                    ny=y+dc[d]
                x=nx
                y=ny
        return res

 
matrix=[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]

[1,2,3,6,9,8,7,4,5]    
if __name__ == "__main__":
    print(Solution().spiralOrder( matrix))            
    
    
#375. Clone Binary Tree
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""

class Solution:
    """
    @param root: The root of binary tree
    @return: root of new tree
    """
    def cloneTree(self, root):
        # write your code here
        if not root:
            return root
        
        new_root=TreeNode(root.val)
        if root.left:
            new_root.left=self.cloneTree(root.left)
        if root.right:
            new_root.right=self.cloneTree(root.right)
        return new_root
        
#376. Binary Tree Path Sum
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""


class Solution:
    """
    @param: root: the root of binary tree
    @param: target: An integer
    @return: all valid paths
    """
    def binaryTreePathSum(self, root, target):
        # write your code here
        if not root:
            return []
        
        def search(target,path,res,node):
            if target==0 and not node.left and not node.right:
                print(path)
                res.append(path[:])
                return 

            if node.left:
               search(target-node.left.val,path+[node.left.val],res,node.left)
            if node.right:
               search(target-node.right.val,path+[node.right.val],res,node.right)
      
            
        res=[]
        search(target-root.val,[root.val],res,root)
        return res

#      
#    
#     1
#    / \
#   2   4
#  / \
# 2   3    
#    
#[
#  [1, 2, 2],
#  [1, 4]
#]    
    
                  
root=    TreeNode(1)  
root.left= TreeNode(2)  
root.right= TreeNode(4)  
root.left.left= TreeNode(2)
root.left.right= TreeNode(3)
target=5                
if __name__ == "__main__":
    print(Solution().binaryTreePathSum(root, target)) 

#378. Convert Binary Search Tree to Doubly Linked List
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
Definition of Doubly-ListNode
class DoublyListNode(object):

    def __init__(self, val, next=None):
        self.val = val
        self.next = self.prev = next
"""


class Solution:
    """
    @param: root: The root of tree
    @return: the head of doubly list node
    """
    def bstToDoublyList(self, root):
        # write your code here
        if not root:
            return  root
        res=[]
        def inOrder(node,res):
            if not node:
                return 
            inOrder(node.left,res)
            res.append(node.val)
            inOrder(node.right,res)
        inOrder(root,res)
        
        root=DoublyListNode(res[0])
        cur=root
        prev=None
        i=1
        while i<len(res):
             cur.next=DoublyListNode(res[i])
             cur.prev=prev
             
             i+=1
             prev=cur
             cur=cur.next
        cur.prev=prev
        return root
    
root=    TreeNode(1)  
root.left= TreeNode(2)  
root.right= TreeNode(4)  
root.left.left= TreeNode(2)
root.left.right= TreeNode(3)  
# 1<->2<->3<->4<->5      
if __name__ == "__main__":
    print(Solution().bstToDoublyList( root)) 
        
            
#379. Reorder array to construct the minimum number

class Solution:
    """
    @param nums: n non-negative integer array
    @return: A string
    """
    def minNumber(self, nums):
        # write your code here
#        n=len(nums)
#        if n<2:
#            return nums
#        nums=[str(x) for x in nums]
#        class compare(str):
#            def __lt__(x,y):
#              return x+y<y+x
#        
#        nums.sort(key=compare)
#        
#        return ''.join(nums)
        
        #Python 2
        nums.sort(cmp=self.cmp)
        res=''.join([str(x) for x in nums])
        i=0
        while i+1<len(res):
            if res[i]!='0':
                break
            i+=1
        return res[i:]
            
        
        
        
        
    def cmp(self,x,y) :
        if str(x)+str(y)<str(y)+str(x):
            return -1
        elif str(x)+str(y)==str(y)+str(x):
            return 0
        else:
            return 1
        
nums=[3, 32, 321]                
if __name__ == "__main__":
    print(Solution().minNumber( nums)) 

#380. Intersection of Two Linked Lists
"""
Definition for singly-linked list.
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None
"""


class Solution:
    """
    @param: headA: the first list
    @param: headB: the second list
    @return: a ListNode
    """
    def getIntersectionNode(self, headA, headB):
        # write your code here
        
        curA=headA
        curB=headB
        
        while curA and curB:
            curA=curA.next
            curB=curB.next
        if curA:
            curB=headA
            while curA  and curB:
                curA=curA.next
                curB=curB.next
            curA=headB
            while curA  and curB:
                  if curA == curB:                      
                      return curA
                  curA=curA.next
                  curB=curB.next
        if curB:
            curA=headB
            while curA  and curB:
                curA=curA.next
                curB=curB.next
            curB=headA
            while curA  and curB:
                  if curA == curB:                      
                      return curA
                  curA=curA.next
                  curB=curB.next
                
            
#381. Spiral Matrix II
class Solution:
    """
    @param n: An integer
    @return: a square matrix
    """
    def generateMatrix(self, n):
        # write your code here
        
        
        dr=[0,1,0,-1]
        dc=[1,0,-1,0]
        x=0
        y=0
        d=0
        
       
        
        res=[[-1 for _ in range(n)]  for _ in range(n)]
        
        for i in range(n*n):
            res[x][y]=i+1
            nx=x+dr[d]
            ny=y+dc[d]
            if nx<0 or nx>=n or ny<0 or ny>=n or res[nx][ny]!=-1:
                d=(d+1)%4
                nx=x+dr[d]
                ny=y+dc[d]
            x=nx
            y=ny
        return res
        
#[
#  [ 1, 2, 3 ],
#  [ 8, 9, 4 ],
#  [ 7, 6, 5 ]
#] 

n=9       
if __name__ == "__main__":
    print(Solution(). generateMatrix( n))        
        
        
        
        
        
#382. Triangle Count        
class Solution:
    """
    @param S: A list of integers
    @return: An integer
    """
    def triangleCount(self, S):
        # write your code here
        
        n=len(S)
        if n<3:
            return []
#        def dfs(S,res,path):
#            if len(path)==3:
#                if path[0]+path[1]>path[2]:
#                    self.res+=1
#                    return 
#            elif len(path)<3:
#                for i in range(len(S)):
#                    
#                    dfs(S[i+1:],self.res,path+[S[i]])
#        self.res=0
#        S.sort()
#        dfs(S,self.res,[])
#        return self.res
        S.sort()
        count=0
        for i in range(2,n):
            left=0
            right=i-1
            
            while left < right:
                if S[left]+S[right]>S[i]:
                    count+=right-left
                    right-=1
                else:
                    left+=1
        return count
                
                
                
S = [3,4,6,7]     
S = [4,4,4,4] 

if __name__ == "__main__":
    print(Solution().triangleCount( S))         
        
#383. Container With Most Water        
class Solution:
    """
    @param heights: a vector of integers
    @return: an integer
    """
    def maxArea(self, heights):
        # write your code here
        if not heights:
            return 0
        n=len(heights)
        
        l=0
        r=n-1
        ans=0
        while l<r:
            
            if heights[l]<heights[r]:
                area=heights[l]*(r-l)
                l+=1
            else:
                area=heights[r]*(r-l)
                r-=1
            ans=max(ans,area)
        return ans
heights=[1,3,2]    
if __name__ == "__main__":
    print(Solution().maxArea(heights))                   
        
        
#384. Longest Substring Without Repeating Characters
class Solution:
    """
    @param s: a string
    @return: an integer
    """
    def lengthOfLongestSubstring(self, s):
        # write your code here
        if not s:
            return 0
        
        left=0
        last={}
        
        ans=0
        
        for i in range(len(s)):
            if s[i] in last and last[s[i]]>=left:
               
                left=last[s[i]]+1
            last[s[i]]=i
            ans=max(ans,i-left+1)
        return ans
s='abcabcbb'
s='ggggg'
if __name__ == "__main__":
    print(Solution().lengthOfLongestSubstring( s)) 
    
    
    
#385. ArrayList
class ArrayListManager:
    '''
     * @param n: You should generate an array list of n elements.
     * @return: The array list your just created.
    '''
    def create(self, n):
        # Write your code here
        list1=[]
        for i in range(n):
            list1.append(i)
        return list1       
    
    
    '''
     * @param list: The list you need to clone
     * @return: A deep copyed array list from the given list
    '''
    def clone(self, l):
        # Write your code here
        clist=[]
        for i in l:
            clist.append(i)
        return clist
            
    
    
    '''
     * @param list: The array list to find the kth element
     * @param k: Find the kth element
     * @return: The kth element
    '''
    def get(self, l, k):
        # Write your code here
        return l[k]
    
    
    '''
     * @param list: The array list
     * @param k: Find the kth element, set it to val
     * @param val: Find the kth element, set it to val
    '''
    def set(self, l, k, val):
        # write your code here
        l[k]=val
    
    
    '''
     * @param list: The array list to remove the kth element
     * @param k: Remove the kth element
    '''
    def remove(self, l, k):
        # write tour code here
        l.remove(k)
        
   
    
    '''
     * @param list: The array list.
     * @param val: Get the index of the first element that equals to val
     * @return: Return the index of that element
    '''
    def indexOf(self, l, val):
        # Write your code here
        if not l:
            return -1
        
        try:
            ans=l.index(val)
        except   ValueError:
                ans=-1
        return ans
    
       
#386. Longest Substring with At Most K Distinct Characters
class Solution:
    """
    @param s: A string
    @param k: An integer
    @return: An integer
    """
    def lengthOfLongestSubstringKDistinct(self, s, k):
        # write your code here
        left=0
        n=len(s)
        if n==0:
            return 0
        
        count=[0 for _ in range(256)]
        ans=0
        distinct=0
        for i in range(n):
            if count[ord(s[i])]==0:
                distinct+=1
            count[ord(s[i])]+=1
            while distinct>k:
                count[ord(s[left])]-=1
                if  count[ord(s[left])]==0:
                    distinct-=1
                left+=1
            ans=max(ans,i-left+1)
        return ans
                    
                
            
#        from collections import Counter
#        res=0
#        for i in range(n):
#            
#            WC=Counter(s[left:i+1])
#            
#            while len(WC)>k:                
#                
#                WC[s[left]]-=1
#                
#                if WC[s[left]]==0:
#                    del WC[s[left]]
#                left+=1
#            
#            res=max(res,i-left+1)
#        return res
s = "ecccebba"
k = 3
if __name__ == "__main__":
    print(Solution().lengthOfLongestSubstringKDistinct( s, k))            
                 
#387. The Smallest Difference
class Solution:
    """
    @param A: An integer array
    @param B: An integer array
    @return: Their smallest difference.
    """
    def smallestDifference(self, A, B):
        # write your code here
        AA=[(a,0) for a in A]
        BB=[(b,1) for b in B]
        
        AABB= sorted(AA+BB)
        
        n=len(AABB)
        
        
        
        
        i=1
        ans=float('inf')
        while i<n:
            if AABB[i][1]!=AABB[i-1][1]:
                ans=min(ans, abs(AABB[i][0]-AABB[i-1][0]))
            i+=1
        return ans
      
        
A = [3,6,7,4]
B = [2,8,9]        
            
if __name__ == "__main__":
    print(Solution().smallestDifference(A, B))                  
                
  
#388. Permutation Sequence        
class Solution:
    """
    @param n: n
    @param k: the k th permutation
    @return: return the k-th permutation
    """
    def getPermutation(self, n, k):
        # write your code here
        s=[ i for i in range(1,n+1)]
        per=[]
        
        fac=[1]
        for i in range(2,n+1):
            fac.append(fac[-1]*i)
            
        kindex=k-1
            
        for i in range(n):
            
           index=  kindex//fac[n-2-i]
           per.append(s[index])
           s.pop(index)
           kindex=kindex%fac[n-2-i]
        return ''.join([str(x) for x in per])
           
        
n=3
k=4
"123"
"132"
"213"
"231"
"312"
"321"      
if __name__ == "__main__":
    print(Solution().getPermutation( n, k))          
        
  
#389. Valid Sudoku
class Solution:
    """
    @param board: the board
    @return: whether the Sudoku is valid
    """
    def isValidSudoku(self, board):
        # write your code here
        
        m=len(board)
        n=len(board[0])
        sumB=[]
        for i,r in enumerate(board):
            for j,c in enumerate(r):
                if c!='.':
                    sumB+=[(i,c),(c,j),(i//3,j//3,c)]
        return len(sumB)==len(set(sumB))
                    
    
#391. Number of Airplanes in the Sky    
"""
Definition of Interval.
class Interval(object):
    def __init__(self, start, end):
        self.start = start
        self.end = end
"""

class Solution:
    """
    @param airplanes: An interval array
    @return: Count of airplanes are in the sky.
    """
    def countOfAirplanes(self, airplanes):
        # write your code here
        if not airplanes:
            return 0
        events=[]
        for interval in airplanes:
            events+=[(interval.start,'OPEN') , (interval.end,'END')]
        events.sort()
        
        
        res=0
        n=0
        for  x,status in events:
            if status =='OPEN':
                n+=1
                res=max(res,n)
            else:
                n-=1
        return res
            
 
airplanes=[
  (1,10),
  (2,3),
  (5,8),
  (4,7)
] 

#392. House Robber
class Solution:
    """
    @param A: An array of non-negative integers
    @return: The maximum amount of money you can rob tonight
    """
    def houseRobber(self, A):
        # write your code here
        n=len(A)
        if n==0:
            return 0
        if n==1:
            return A[0]
        if n==2:
            return max(A)
        dp=[0 for _ in range(n)]
        dp[0]=A[0]
        dp[1]=max(A[0],A[1])
        
        for i in range(2,n):
            dp[i]=max(dp[i-1],dp[i-2]+A[i])
        return dp[n-1]
A=[3, 8, 4]
if __name__ == "__main__":
    print(Solution().houseRobber( A))         


#393. Best Time to Buy and Sell Stock IV
class Solution:
    """
    @param K: An integer
    @param prices: An integer array
    @return: Maximum profit
    """
    def maxProfit(self, K, prices):
        # write your code here

#Given prices = [4,4,6,1,1,4,2,5], and k = 2, return 6
#https://soulmachine.gitbooks.io/algorithm-essentials/java/dp/best-time-to-buy-and-sell-stock-iv.html        
#设两个状态，global[i][j] 表示i天前最多可以进行j次交易的最大利润，local[i][j]表示i天前最多
#可以进行j次交易，且在第i天进行了第j次交易的最大利润。状态转移方程如下：
#local[i][j] = max(global[i-1][j-1] + max(diff,0), local[i-1][j]+diff)
#global[i][j] = max(local[i][j], global[i-1][j])
#关于global的状态转移方程比较简单，不断地和已经计算出的local进行比较，把大的保存在global中。
#关于local的状态转移方程，取下面二者中较大的一个：
#全局前i-1天进行了j-1次交易，然后然后加上今天的交易产生的利润（如果赚钱就交易，不赚钱就不交易
#，什么也不发生，利润是0）
#局部前i-1天进行了j次交易，然后加上今天的差价（local[i-1][j]是第i-1天卖出的交易，它加
#上diff后变成第i天卖出，并不会增加交易次数。无论diff是正还是负都要加上，否则就不满足
#local[i][j]必须在最后一天卖出的条件了）
#注意，当k大于数组的大小时，上述算法将变得低效，此时可以改为不限交易次数的方式解决，
#即等价于 "Best Time to Buy and Sell Stock II"。        

        n=len(prices)
        if K<1 or n<2:
            return 0
        profit=0
        if K>=n//2:
            
            for i in range(1,n):
                profit+=max(0,prices[i]-prices[i-1])
            return profit
                
        
        localmax=[[0 for _ in range(K+1)] for _ in range(n)]
        globalmax=[[0 for _ in range(K+1)] for _ in range(n)]
        
        for i in range(1,n):
            diff=prices[i]-prices[i-1]
            for j in range(1,K+1):
                
                localmax[i][j]= max(globalmax[i-1][j-1]+max(0,diff),localmax[i-1][j]+diff)
                globalmax[i][j]=max(globalmax[i-1][j],localmax[i][j])
        return globalmax[n-1][K]
    
class Solution:
    """
    @param K: An integer
    @param prices: An integer array
    @return: Maximum profit
    """
    def maxProfit(self, K, prices):
        # write your code here
        n=len(prices)
        if K<1 or n<2:
            return 0
        profit=0
        if K>=n//2:
            
            for i in range(1,n):
                profit+=max(0,prices[i]-prices[i-1])
            return profit
                
        
        localmax=[[0 for _ in range(n)] for _ in range(K+1)]
        globalmax=[[0 for _ in range(n)] for _ in range(K+1)]
        
        for i in range(1,K+1):
            for j in range(1,n):
                diff=prices[j]-prices[j-1]
                localmax[i][j]= max(globalmax[i-1][j-1]+max(0,diff),localmax[i][j-1]+diff)
                globalmax[i][j]=max(globalmax[i][j-1],localmax[i][j])
        return globalmax[K][n-1]    
    
    
    
prices = [4,4,6,1,1,4,2,5]
K= 2        
if __name__ == "__main__":
    print(Solution().maxProfit( K, prices))           
        
#394. Coins in a Line
class Solution:
    """
    @param n: An integer
    @return: A boolean which equals to true if the first player will win
    """
    def firstWillWin(self, n):
        # write your code here
        return n%3!=0
        
#395. Coins in a Line II
class Solution:
    """
    @param values: a vector of integers
    @return: a boolean which equals to true if the first player will win
    """
    def firstWillWin(self, values):
        # write your code here

#http://www.cnblogs.com/grandyang/p/5864323.html
#这道题是之前那道Coins in a Line的延伸，由于每个硬币的面值不同，所以那道题的数学解法就不行了，
#这里我们需要使用一种方法叫做极小化极大算法Minimax，这是博弈论中比较经典的一种思想
#，LeetCode上有一道需要用这种思路解的题Guess Number Higher or Lower II。
#这道题如果没有接触过相类似的题，感觉还是蛮有难度的。我们需要用DP来解，
#我们定义一个一维数组dp，其中dp[i]表示从i到end可取的最大钱数，
#大小比values数组多出一位，若n为values的长度，那么dp[n]先初始化为0。
#我们是从后往前推，我们想如果是values数组的最后一位，及i = n-1时，
#此时dp[n-1]应该初始化为values[n-1]，因为拿了肯定比不拿大，
#钱又没有负面额；那么继续往前推，当i=n-2时，dp[n-2]
#应该初始化为values[n-2]+values[n-1]，应为最多可以拿两个，
#所以最大值肯定是两个都拿；当i=n-3时，dp[n-3]
#应该初始化为values[n-3]+values[n-2]，
#因为此时还剩三个硬币，你若只拿一个，那么就会给对手留两个，
#当然不行，所以自己要拿两个，只能给对手留一个，
#那么到目前位置初始化的步骤就完成了，下面就需要找递推式了：
#
#当我们处在i处时，我们有两种选择，拿一个还是拿两个硬币，我们现在分情况讨论：
#
#1. 当我们只拿一个硬币values[i]时，那么对手有两种选择，拿一个硬币values[i+1]，
#或者拿两个硬币values[i+1] + values[i+2]
#a) 当对手只拿一个硬币values[i+1]时，我们只能从i+2到end之间来取硬币，
#                    所以我们能拿到的最大硬币数为dp[i+2]
#b) 当对手拿两个硬币values[i+1] + values[i+2]时，我们只能从i+3到end之间来取硬币，
#                    所以我们能拿到的最大硬币数为dp[i+3]
#由于对手的目的是让我们拿较小的硬币，所以我们只能拿dp[i+2]和dp[i+3]中较小的一个，
#所以对于我们只拿一个硬币的情况，我们能拿到的最大钱数为values[i] + min(dp[i+2], dp[i+3])
#
#2. 当我们拿两个硬币values[i] + values[i + 1]时，那么对手有两种选择，
#拿一个硬币values[i+2]，或者拿两个硬币values[i+2] + values[i+3]
#a) 当对手只拿一个硬币values[i+2]时，我们只能从i+3到end之间来取硬币，
#                    所以我们能拿到的最大硬币数为dp[i+3]
#b) 当对手拿两个硬币values[i+2] + values[i+3]时，我们只能从i+4到end之间来取硬币，
#                    所以我们能拿到的最大硬币数为dp[i+4]
#由于对手的目的是让我们拿较小的硬币，所以我们只能拿dp[i+3]和dp[i+4]中较小的一个，
#所以对于我们只拿一个硬币的情况，我们能拿到的最大钱数为
#values[i] + values[i + 1] + min(dp[i+3], dp[i+4])
#
#综上所述，递推式就有了
# dp[i] = max(values[i] + min(dp[i+2], dp[i+3]), values[i] + values[i + 1] + min(dp[i+3], dp[i+4]))
#这样当我们算出了dp[0]，知道了第一个玩家能取出的最大钱数，我们只需要算出总钱数，
#然后就能计算出另一个玩家能取出的钱数，二者比较就知道第一个玩家能否赢了，参见代码如下：

        n=len(values)
        if n<=2:
            return True
        dp=[0 for _ in range(n+1)]
        #dp[n] initialized as 0
        
        dp[n-1]=values[n-1]
        dp[n-2]=values[n-1]+values[n-2]
        dp[n-3]=values[n-3]+values[n-2]
        
        for i in range(n-4,-1,-1):
            dp[i]=max( values[i]+min(dp[i+2],dp[i+3]),values[i]+values[i+1] + min(dp[i+4],dp[i+3]))
        
        sumv=sum(values)
        print(dp)
        print(dp[0],sumv-dp[0])
        return dp[0]>sumv-dp[0]
values= [1,2,4]        
if __name__ == "__main__":
    print(Solution().firstWillWin( values))         
        
#396. Coins in a Line III
class Solution:
    """
    @param values: a vector of integers
    @return: a boolean which equals to true if the first player will win
    """
    def firstWillWin(self, values):
        # write your code here
        
#        def get(A):
#            n=len(A)
#            if n==0:
#                return 0
#            if n==1:
#                return A[0]
#            if n==2:
#                return max(A[0],A[1])
#            if n==3:
#                iget=max(A[0],A[-1])
#                if iget==A[0]:
#                    iget+=min(A[1],A[2])
#                else:
#                    iget+=min(A[1],A[0])
#                return iget
#            
#            return max(sum(A[:-1])-get(A[:-1])+A[-1]  ,  sum(A[1:])-get(A[1:])+A[0])
#        return get(values) >sum(values)-get(values)
        A=values
        n=len(values)
        dp=[[0 for _ in range(n+1)] for _ in range(n+1)]
        # dp[0][10] A[0:10] 第一个人能拿到的最大值
        for i in range(n+1):
            dp[i][i]=0
            if i+1<n+1:
              dp[i][i+1]=A[i]
            if i+2<n+1:
                dp[i][i+2]=max(A[i],A[i+1])
        sumV=[0 for _ in range(n+1)]
       
        
        for i in range(1,n+1):
            sumV[i]=A[i-1]+sumV[i-1]
            
        #sum(A[i+1:j])  sumV[j]-sumV[i+1]
        #sum(A[i:j-1])  sumV[j-1]-sumV[i]
        for i in range(n-2,-1,-1):
            for j in range(i+2,n+1):
                dp[i][j]=max(A[i]+sumV[j]-sumV[i+1]-dp[i+1][j],A[j-1]+sumV[j-1]-sumV[i]-dp[i][j-1])
                #dp[i][j]=max(A[i]+sum(A[i+1:j])-dp[i+1][j],A[j-1]+sum(A[i:j-1])-dp[i][j-1])
        return dp[0][n]>sum(A)- dp[0][n]
                
                
values=[1,20,4]
values=[3,2,2]
values=[1,2,4,9,1,2,1,2,2]
values=[1,9999999,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,200,1,1,1,1,1,1,1,1,800,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
values=[1,2,3,4,5,6,7,8,13,11,10,9]
if __name__ == "__main__":
    print(Solution().firstWillWin( values))        
        
        
        
        
        
        
        
        
#397. Longest Continuous Increasing Subsequence        
class Solution:
    """
    @param A: An array of Integer
    @return: an integer
    """
    def longestIncreasingContinuousSubsequence(self, A):
        # write your code here
#For [5, 4, 2, 1, 3], the LICS is [5, 4, 2, 1], return 4.
#
#For [5, 1, 2, 3, 4], the LICS is [1, 2, 3, 4], return 4. 
        n=len(A)
        res=0
        l=1
        r=1
        for i in range(1,n):
            if A[i]>A[i-1]:
                l+=1
                res=max(res,l)
            else:
                l=1
            if A[i]<A[i-1]:
                r+=1
                res=max(res,r)
            else:
                r=1
        return res
A=[5, 4, 2, 1, 3]        
if __name__ == "__main__":
    print(Solution().longestIncreasingContinuousSubsequence( A))         
        
#399. Nuts & Bolts Problem
"""
class Comparator:
    def cmp(self, a, b)
You can use Compare.cmp(a, b) to compare nuts "a" and bolts "b",
if "a" is bigger than "b", it will return 1, else if they are equal,
it will return 0, else if "a" is smaller than "b", it will return -1.
When "a" is not a nut or "b" is not a bolt, it will return 2, which is not valid.
"""


class Solution:
    # @param nuts: a list of integers
    # @param bolts: a list of integers
    # @param compare: a instance of Comparator
    # @return: nothing
    def sortNutsAndBolts(self, nuts, bolts, compare):
        # write your code here 
        if not nuts or not bolts or not compare :
            return 
        if len(nuts)!=len(bolts):
            return 
        
        self.compare=compare
        
        self.quickSort(nuts, bolts,0,len(bolts)-1)
        

    def quickSort(self,nuts, bolts,left,right):
        if left>=right:
            return 
        
        nuts_split_pos= self.partition(nuts,bolts[left],left,right)
        bolts_split_pos= self.partition(bolts,nuts[nuts_split_pos],left,right)
        self.quickSort(nuts, bolts,left,bolts_split_pos-1)
        self.quickSort(nuts, bolts,bolts_split_pos+1,right)
    
    
    def partition(self,items,pivot,left,right):
        if not items or not pivot:
            return 
        
        for i in range(left,right+1):
            if self.compare.cmp(pivot,items[i])==0 or self.compare.cmp(items[i],pivot)==0:
                 items[left],items[i]=items[i],items[left]
                 break
        
        partner_pivot=items[left]
        while left<right:
            while left<right and (self.compare.cmp(items[right],pivot)==1 or self.compare.cmp(pivot,items[right])==-1):
                right-=1
            items[left]=items[right]
            while left<right and (self.compare.cmp(items[left],pivot)==-1 or self.compare.cmp(pivot,items[left])==1):
                left+=1
            items[right]=items[left]
        
        items[left]   =partner_pivot
        return left
    
#400. Maximum Gap
class Solution:
    """
    @param nums: an array of integers
    @return: the maximun difference
    """
    def maximumGap(self, nums):
        # write your code here
        
        n=len(nums)
        
        if n<2:
            return 0
        if n==2:
            return abs(nums[0]-nums[1])
        
        
        imax=max(nums)
        imin=min(nums)
        
        if imin==imax:
            return 0
        
        import math
        gap=math.ceil((imax-imin)/(n-1))
        numbuck=int(math.ceil((imax-imin)/gap))
        
        buckmax=[0 for _ in range(numbuck)]
        buckmin=[float('inf') for _ in range(numbuck)]
        
        maxgap=0
        
        for num in nums:
            if num==imax or num==imin:
                continue
            
            index=int((num-imin)//gap)
            buckmax[index]=max(buckmax[index],num)
            buckmin[index]=min(buckmin[index],num)
         
        prev=imin
        for i in range(numbuck):
            if buckmin[i]==float('inf')  and buckmax[i]==0:
                continue
            maxgap=max(maxgap,buckmin[i]-prev)
            prev=buckmax[i]
            
        maxgap=max(imax-prev,maxgap)
        return maxgap
            
            
nums=[1, 9, 2, 5]       
if __name__ == "__main__":
    print(Solution().maximumGap( nums))               
        
        
#401. Kth Smallest Number in Sorted Matrix        
class Solution:
    """
    @param matrix: a matrix of integers
    @param k: An integer
    @return: the kth smallest number in the matrix
    """
    def kthSmallest(self, matrix, k):
        # write your code here
        m=len(matrix)
        n=len(matrix[0])
        
        
        import heapq
        
        hq=[(matrix[0][0],0,0)]
        
        visited=[[0 for _ in range(n)] for _ in range(m)]
        visited[0][0]=1
        
        for _ in range(k):
            res,x,y=heapq.heappop(hq)
           
            if x+1<m and visited[x+1][y]==0:
                
                 heapq.heappush(hq,(matrix[x+1][y],x+1,y))
                 visited[x+1][y]=1
            if y+1<n and visited[x][y+1]==0:
                
                 heapq.heappush(hq,(matrix[x][y+1],x,y+1))
                 visited[x][y+1]=1
        return res
        
matrix=[
  [1 ,5 ,7],
  [3 ,7 ,8],
  [4 ,8 ,9],
]    
k=4  
if __name__ == "__main__":
    print(Solution().kthSmallest(matrix, k))          
        
#402. Continuous Subarray Sum  
class Solution:
    """
    @param: A: An integer array
    @return: A list of integers includes the index of the first number and the index of the last number
    """
    def continuousSubarraySum(self, A):
        # write your code here
        if not A:
            return []
        
        res=[]
        start=0
        end=-1
        ans=float('-inf')
        
        sm=0
        
        for x in A:
            if sm<0:
                start=end+1
                end=start
                sm=x
            else:
                sm+=x
                end+=1
            if ans<sm:
                ans=sm
                res=[start,end]
        return res
A=[-3, 1, 3, -3, 4]      
if __name__ == "__main__":
    print(Solution().continuousSubarraySum( A)) 


#403. Continuous Subarray Sum II
class Solution:
    """
    @param: A: An integer array
    @return: A list of integers includes the index of the first number and the index of the last number
    """
    def continuousSubarraySumII(self, A):
        # write your code here
        
       
        
#按I的方法求出的结果
#从整个array中减去中间最小的subarray，需要rotate的array
#思路是这样的，像楼上说的两种情况，不rotate的 和rorate的。不rotate的和Continuous Subarray Sum I做法一样，
#不说了。rotate的，可以这样想，rotate的结果其实相当于是把原来的array中间挖了一段连续的array，那么挖哪一段呢？
#肯定是和最小的一段连续array。这样解法就出来了。
#
#类似Continuous Subarray Sum I，在I里面是找到连续和最大的一段subarray，在这里，不仅找到和最大的一段连续array
#，并且也找到和最小的一段连续array，然后用整个array的sum减去这个最小的和，如果大于不rotate的最大和，
#那么解就是挖去的这段array的（尾+1， 头-1）
#有一个edge case就是当array全部为负时，要挖去的array就是整个array，这个要注意一下。        
                
        
#        sumAA=[0 for _ in range(2*n+1)]
#        
#        
#        for i in range(1,2*n+1):
#            sumAA[i]=sumAA[i-1]+AA[i-1]
#        #print(AA)
#        #print(sumAA)
#            
#        res=float('-inf')
#        start=-1
#        end=-1
#        for i in range(0,2*n+1):
#            for j in range(i,2*n+1):
#                if j-i<n:
#                    if sumAA[j]-sumAA[i]>res:
#                        res=sumAA[j]-sumAA[i]
#                        start=i
#                        end=j-1
        if not A:
            return []
        n=len(A)
        if n==1:
            return [0,0]
        
        totalsum=0
        maxsum=float('-inf')
        curmaxsum=0
        maxstart=0
        maxend=0
        mastart=0
        
        minsum=float('inf')
        curminsum=0
        minstart=0
        minend=0
        mistart=0
        
        for i in range(n):
            totalsum+=A[i]
            
            if curmaxsum<0:
                curmaxsum=A[i]
                mastart=i
            else:
                curmaxsum+=A[i]
            
            if curmaxsum>maxsum:
                maxsum=curmaxsum
                maxstart=mastart
                maxend=i
            
            
            if curminsum>0:
                curminsum=A[i]
                mistart=i
            else:
                curminsum+=A[i]
            
            if curminsum<minsum:
                minsum=curminsum
                minstart=mistart
                minend=i
        print(mastart,maxend)
        if totalsum-minsum>=maxsum  and minstart!=0 and   minend!=n-1:
            start=minend+1
            end=minstart-1
        else:
            start=maxstart
            end=maxend
        return [start,end]
#A=[3, 1, -100, -3, 4]
#A=[3, 1, -1, 3, 4]
#A=[-3, 1, 3, -3, 4]      
if __name__ == "__main__":
    print(Solution().continuousSubarraySumII( A))            
        
#405. Submatrix Sum        
class Solution:
    """
    @param: matrix: an integer matrix
    @return: the coordinate of the left-up and right-down number
    """
    def submatrixSum(self, matrix):
        # write your code here
        
        m=len(matrix)
        n=len(matrix[0])
        if m==0:
            return []
        sum_m=[[0 for _ in range(n+1)] for _ in range(m+1)]
        
        
        for i in range(m+1):
            sum_m[i][0]=0
        for j in range(n+1):
            sum_m[0][j]=0
            
        for i in range(0,m):
            for j in range(0,n):
                sum_m[i+1][j+1]=sum_m[i][j+1]+sum_m[i+1][j]+matrix[i][j]-sum_m[i][j]
                
        res=[]    
        for l in range(0,m):
            for h in range(l+1,m+1):
                dic={}
                for j in range(n+1):
                    diff=sum_m[h][j]-sum_m[l][j]
                    if diff in dic:
                        res.append([l,dic[diff]])
                        res.append(([h-1,j-1]))
                        return res
                    else:
                        dic[diff]=j
                    
      
matrix=[
  [1 ,5 ,7],
  [3 ,7 ,-8],
  [4 ,-8 ,9],
]

matrix=[[0,4],[-4,0]]   
if __name__ == "__main__":
    print(Solution().submatrixSum(matrix))                 
                
            
#406. Minimum Size Subarray Sum        
class Solution:
    """
    @param nums: an array of integers
    @param s: An integer
    @return: an integer representing the minimum size of subarray
    """
    def minimumSize(self, nums, s):
        # write your code here
        if not nums:
            return 0
        
        n=len(nums)
        l=0
        r=0
        ans=n+1
        total=0
        
        while r<n:
            while r<n and total<s:
                total+=nums[r]
                r+=1
            if total<s:
                break
            while l<=r and total>=s:
                #print(l,r)
                
                total-=nums[l]
                l+=1
            ans=min(ans,r-l+1)
        if ans==n+1:
            return -1
        return ans
nums=[2,3,1,2,4,3] 
s = 7        
if __name__ == "__main__":
    print(Solution().minimumSize( nums, s))                 
                
        
#407. Plus One        
class Solution:
    """
    @param digits: a number represented as an array of digits
    @return: the result
    """
    def plusOne(self, digits):
        # write your code here
        res=[]
        n=len(digits)  
        if n==0:
            return []
        carry=1
        for x in digits[::-1]:
            n=x+carry
            carry=n//10
            res.append(n%10)
        if carry==1:
            res.append(carry)
        return res[::-1]
digits=[1,2,3]
digits=[9,9,9]
if __name__ == "__main__":
    print(Solution().plusOne(digits))     
            
#408. Add Binary
class Solution:
    """
    @param a: a number
    @param b: a number
    @return: the result
    """
    def addBinary(self, a, b):
        # write your code here
        la=len(a)
        lb=len(b)
        
        a=list(a)[::-1]
        b=list(b)[::-1]
        carry=0
        
        i=0
        
        res=[]
        while i<la  or i<lb:
            sm=0
            if i<la:
                sm+=int(a[i])
            if i<lb:
                sm+=int(b[i])
            
            sm+=carry
            res.append(sm%2)
            carry=sm//2
            i+=1
        
        if carry==1:
            res.append(carry)
        
        return ''.join(str(x) for x in res[::-1])
a = '11'

b = '1'            
if __name__ == "__main__":
    print(Solution().addBinary( a, b))        
                
#411. Gray Code
class Solution:
    """
    @param n: a number
    @return: Gray code
    """
    def grayCode(self, n):
        # write your code here
        if n==0:
            return [0]
        if n==1:
            return [0,1]
        
        def neighbor(s):
            n=len(s)
            res=[]
            for i in range(n)[::-1]:
                if s[i]=='0':
                   x='1'
                else:
                    x='0'
                res.append(s[:i]+x+s[i+1:])
            return res
                
        def dfs(s,res):
             if len(res)==2**n:
                 return True
             if len(res)>2**n:
                 return False
             for nei in neighbor(s):
                 if nei not in res:
                     res.append(nei)
                     if dfs(nei,res):
                         return True
             return False
        res=[]
        s=''.join(['0'  for _ in range(n)])
        res.append(s)
        dfs(s,res)
        res2=[int(s, 2) for s in res]
        
            
        return res
n=3
if __name__ == "__main__":
    print(Solution().grayCode(n))                    
             
             
                    
#412. Candy
class Solution:
    """
    @param ratings: Children's ratings
    @return: the minimum candies you must give
    """
    def candy(self, ratings):
        # write your code here
        n=len(ratings)
        if n==0:
            return 0
        if n==1:
            return 1
        ratings=[0]+ratings+[0]
        
        res=[1 for _ in range(n+2)]
        res[0]=0
        res[-1]=0
        print(ratings)
        for i in range(1,n+1):
            if ratings[i]>ratings[i-1]:
                 #print(i,res)
                 while res[i]<=res[i-1]:
                       res[i]+=1
            if ratings[i]>ratings[i+1]:
                 #print(res)
                 while res[i]<=res[i+1]:
                       res[i]+=1
        for i in range(n,0,-1):
            if ratings[i]>ratings[i-1]:
                 #print(i,res)
                 while res[i]<=res[i-1]:
                       res[i]+=1
            if ratings[i]>ratings[i+1]:
                 #print(res)
                 while res[i]<=res[i+1]:
                       res[i]+=1               
        #print(res)
        return sum(res)
ratings=  [1, 2, 2]  
ratings=  [1, 1, 1]
ratings=  [1, 2]  
ratings= [5,3,1]                     
if __name__ == "__main__":
    print(Solution().candy( ratings))                       

        
#413. Reverse Integer
class Solution:
    """
    @param n: the integer to be reversed
    @return: the reversed integer
    """
    def reverseInteger(self, n):
        # write your code here
        if n==0:
            return 0
        neg=1
        if n<0:
            n=0-n
            neg=-1
        reverse=0
        while n>0:
            reverse=reverse*10+n%10
            n=n//10
            
        reverse=reverse* neg
        
        if reverse<-(1<<31) or reverse>(1<<31-1):
            return 0
        return reverse
            
#414. Divide Two Integers        
class Solution:
    """
    @param dividend: the dividend
    @param divisor: the divisor
    @return: the result
    """
    def divide(self, dividend, divisor):
        # write your code here
        intmax=2147483647
        if divisor==0:
            return intmax
        
        neg=1
        if (dividend <0 and divisor>0) or  (dividend >0 and divisor<0):
            neg=-1
        
        a=abs(dividend)
        b=abs(divisor)
        
        ans=0
        shift=31
        while shift>=0:
            if a>=b<<shift:
                a-=b<<shift
                ans+=1<<shift
            shift-=1
        if neg==-1:
            ans=0-ans
            
        if ans>intmax or ans <-(intmax+1) :
            return intmax
        
        
        return ans

dividend = 100 
divisor = 9            
if __name__ == "__main__":
    print(Solution().divide( dividend, divisor))                       
        
#415. Valid Palindrome        
class Solution:
    """
    @param s: A string
    @return: Whether the string is a valid palindrome
    """
    def isPalindrome(self, s):
        # write your code here
        n=len(s)
        if n==0 or n==1:
            return True
        l=0
        r=n-1
        while l<r:
            while l<r and not s[l].isalnum():
                l+=1
            while l<r and not s[r].isalnum():
                r-=1
            
            if s[l].lower()!=s[r].lower():
                return False
            l+=1
            r-=1
        return True
        
        
#"A man, a plan, a canal: Panama" is a palindrome.
s='A man, a plan, a canal: Panama' 
s="race a car"        
if __name__ == "__main__":
    print(Solution().isPalindrome( s))  

                        
#417. Valid Number
class Solution:
    """
    @param s: the string that represents a number
    @return: whether the string is a valid number
    """
    def isNumber(self, s):
        # write your code here
        s=s.strip()
        n=len(s)
        if n==0:
            return False
        
        i=0
        
        hasDigit=False
        Eflag=False
        DotFlag=False
        sign=False
        
        
        while i<n:
            
            if s[i].isdigit():
                hasDigit=True
                sign=True
                i+=1
            elif  s[i]=='.'  and not DotFlag:
                DotFlag=True
                sign=True
                i+=1
            elif (s[i]=='e' or s[i]=='E') and not Eflag  and hasDigit:
                i+=1
                Eflag=True
                DotFlag=True
                hasDigit=False
                sign=False
            elif (s[i]=='+' or s[i]=='-')  and not hasDigit and not sign:
                i+=1
                sign=True
            else:
                return False
        if hasDigit:
                return True
        else:
                return False
#\s*[+-]?(\d+\.\d*|\.?\d+)(e[+-]?\d+)?\s*                
s ="0"
s =" 0.1 " 
s ="abc"
s ="1 a"   
s ="2e10"           
if __name__ == "__main__":
    print(Solution().isNumber( s))                   
                
#418. Integer to Roman
class Solution:
    """
    @param n: The integer
    @return: Roman representation
    """
    def intToRoman(self, n):
        # write your code here
#I             1
#V             5
#X             10
#L             50
#C             100
#D             500
#M             1000
        
        nums = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]
        strs=['M', 'CM',  'D', 'CD',  'C', 'XC', 'L', 'XL', 'X', 'IX', 'V' ,'IV', 'I']
        res=''
        for i ,num  in enumerate(nums):
            while n>=num:
                res+=strs[i]
                n-=num
            if n==0:
                return res
        
n=99 -> XCIX               
if __name__ == "__main__":
    print(Solution().intToRoman( n))                  
            
#419. Roman to Integer                
class Solution:
    """
    @param s: Roman representation
    @return: an integer
    """
    def romanToInt(self, s):
        # write your code here
        #nums = [1000, 900, 500,   400,  100,  90,  50,   40,  10,   9,    5,   4,   1]
        #strs=  ['M', 'CM',  'D', 'CD',  'C', 'XC', 'L', 'XL', 'X', 'IX', 'V' ,'IV', 'I'] 
        def decompse(s):
            if len(s)==1:
                if s=='M':
                    return 1000
                elif s=='D':
                    return 500
                elif s=='C':
                    return 100
                elif s=='L':
                    return 50
                elif s=='X':
                    return 10
                elif s=='V':
                    return 5
                elif s=='I':
                    return 1
            if len(s)==2:
                if s=='CM':
                    return 900
                elif s=='CD':
                    return 400
                elif s=='XC':
                    return 90
                elif s=='XL':
                    return 40
                elif s=='IX':
                    return 9
                elif s=='IV':
                    return 4
                else:
                    return decompse(s[0])+decompse(s[1])
            else:
                if s[:2]  in ('CM',  'CD',  'XC',  'XL', 'IX', 'IV'):
                    return decompse(s[:2])+decompse(s[2:])
                else:
                    return decompse(s[0])+decompse(s[1:])
        return decompse(s)
s='IV'
s='XII'
s='XXI' 
s='XCIX'
if __name__ == "__main__":
    print(Solution().romanToInt( s))                  
                
#420. Count and Say
class Solution:
    """
    @param n: the nth
    @return: the nth sequence
    """
    def countAndSay(self, n):
        # write your code here
        if n==0:
            return ''
        s='1'
        def cal(s):
            count=1
            length=len(s)
            ans=''
            for i,c in enumerate(s):
                if i+1<length and s[i]!=s[i+1]:
                    ans=ans+str(count)+c
                    count=1
                elif i+1<length  and s[i]==s[i+1]:
                    count+=1
            return ans+str(count)+c
                
                
        for _ in range(1,n):
            s=cal(s)
        return s
n=1

n=2               
if __name__ == "__main__":
    print(Solution().countAndSay( n))                  
            
        
#421. Simplify Path       
class Solution:
    """
    @param path: the original path
    @return: the simplified path
    """
    def simplifyPath(self, path):
        # write your code here
        stack=[]
        
        places=[p for p in path.split('/') if p != '' and p!='.']
        
        for p in places:
            if p=='..':
                while stack:
                    stack.pop() 
            else:
                stack.append(p)
        return '/'+'/'.join(stack)
                
#422. Length of Last Word
class Solution:
    """
    @param s: A string
    @return: the length of last word
    """
    def lengthOfLastWord(self, s):
        # write your code here
        if not s:
            return 0
        
        slist=s.strip().split(' ')
        return len(slist[-1])
            
        
        
#423. Valid Parentheses        
class Solution:
    """
    @param s: A string
    @return: whether the string is a valid parentheses
    """
    def isValidParentheses(self, s):
        # write your code here
        if not s:
            return True
        
        n=len(s)
        if n%2:
            return False
        
        stack=[]
        for x in s:
            if x in ('{','[','('):
                stack.append(x)
            else:
                if stack:
                   y=stack.pop()
                   if y=='{'  and x !='}':
                       return False
                   elif y=='['  and x !=']':
                       return False
                   elif y=='('  and x !=')':
                       return False
                   
                else:
                     return False
        return not stack
s="([)]"
if __name__ == "__main__":
    print(Solution().isValidParentheses( s)) 





#424. Evaluate Reverse Polish Notation        
class Solution:
    """
    @param tokens: The Reverse Polish Notation
    @return: the value
    """
    def evalRPN(self, tokens):
        # write your code here
        if not tokens:
            return 0
        stack=[]
        for x in tokens:
            
            if x in ('+','-','*','/' ):
                a=stack.pop()
                b=stack.pop()
                
                if x=='+':
                    stack.append(  str(int(a)+int(b))  )
                elif x=='-':
                    stack.append(  str(-int(a)+int(b))  )
                elif x=='*':
                    stack.append(  str(int(a)*int(b))  )
                elif x=='/':
                    #stack.append(  str(int(b) // int(a) )  )
                    stack.append(  str(  int(int(b) / int(a)) ) )
            else:
                stack.append(x)
            print(stack)
        return int(stack[0])
                
tokens=["2", "1", "+", "3", "*"] -> ((2 + 1) * 3) -> 9
tokens=["4", "13", "5", "/", "+"] -> (4 + (13 / 5)) -> 6                 
tokens=["3","-4","+"]
tokens=["10","6","9","3","+","-11","*","/","*","17","+","5","+"]       
if __name__ == "__main__":
    print(Solution().evalRPN( tokens))         
        

#425. Letter Combinations of a Phone Number
class Solution:
    """
    @param digits: A digital string
    @return: all posible letter combinations
    """
    def letterCombinations(self, digits):
        # write your code here
        if not digits:
            return []
        res=''
        table={
        '2': 'abc',
        '3': 'def',
        '4': 'ghi',
        '5': 'jkl',
        '6': 'mno',
        '7': 'pqrs',
        '8': 'tuv',
        '9': 'wxyz'}
        
        length=len(digits)
        if length==1:
            return list(table[digits])
        
            
        def dfs(path,res,n):
            if len(path)==length:
                res.append(path[:])
                return 
            for letter in table[digits[n]]:
                dfs(path+letter,res,n+1)
                
                
                
        res=[]
        dfs('',res,0)
        return res
digits='23'
if __name__ == "__main__":
    print(Solution().letterCombinations(digits))     
           
            
#426. Restore IP Addresses
class Solution:
    """
    @param s: the IP string
    @return: All possible valid IP addresses
    """
    def restoreIpAddresses(self, s):
        # write your code here
#Every part, if treated as an interger, should be in [0,255]

#Every part must not have any leading zeros        
        
        def validate(s,res,path):
            if not s  and len(path)==4:
                res.append(path[:])
                return 
            if not s:
                return 
            if s and len(path)>=4:
                return 
            if s[0]=='0':
                validate(s[1:],res,path+['0'])
                return 
            for i in range(1,min(4,len(s)+1)):
                 
                if int(s[:i])<256 and int(s[:i])>0:
                    validate(s[i:],res,path+[s[:i]]) 
        res=[]
        validate(s,res,[])
        return ['.'.join(l) for l in res]
s="25525511135" 
s="010010"               
if __name__ == "__main__":
    print(Solution().restoreIpAddresses(s))            
        
        
#427. Generate Parentheses
class Solution:
    """
    @param n: n pairs
    @return: All combinations of well-formed parentheses
    """
    def generateParenthesis(self, n):
        # write your code here
        
        if n==0:
            return []
        if n==1:
            return ['()']
        
        def arrange(l,r,res,path):
            if l>r:
                return 
            if l==0 and r==0:
                res.append(path[:])
                return 
            if l>0:
                arrange(l-1,r,res,path+'(')
            if r>0:
                arrange(l,r-1,res,path+')')
                    
                        
        
        res=[]
        l=n
        r=n
        arrange(l,r,res,'')
        return res 
n=1 
n=2
n=5                    
if __name__ == "__main__":
    print(Solution().generateParenthesis(n))                                    
                    

#428. Pow(x, n) 
class Solution:
    """
    @param: x: the base number
    @param: n: the power number
    @return: the result
    """
    def myPow(self, x, n):
        # write your code here
        
        def cal(x,n):
            if x==0:
                return 0
            if n==0:
                return 1
            if n==1:
                return x
            
            if n%2==1:
                return cal(x*x,n//2)*x
            else:
                return cal(x*x,n//2)
            
        return cal(x,n) if n>=0 else 1/cal(x,-n)
x=8.88023
n=3  
x=2.00000
n=-2147483648              
if __name__ == "__main__":
    print(Solution().myPow(x, n))              
        
#430. Scramble String
class Solution:
    """
    @param s1: A string
    @param s2: Another string
    @return: whether s2 is a scrambled string of s1
    """
    def isScramble(self, s1, s2):
        # write your code here
        if s1==s2:
            return True
        if len(s1)!=len(s2):
            return False
        
        from collections import Counter
        if Counter(s1)!=Counter(s2):
            return False
        n=len(s1)
        for i in range(1,len(s1)):
            if self.isScramble( s1[:i], s2[:i])  and self.isScramble( s1[i:], s2[i:]):
                return True
            if self.isScramble( s1[:i], s2[n-i:])  and self.isScramble( s1[i:], s2[:n-i]):
                return True 
        return False
s1= "a"
s2="a"
s1="great"
s2="rgtae"
if __name__ == "__main__":
    print(Solution().isScramble( s1, s2))              
                        
            
#433. Number of Islands        
class Solution:
    """
    @param grid: a boolean 2D matrix
    @return: an integer
    """
    def numIslands(self, grid):
        # write your code here
        m=len(grid)
        if m==0:
            return 0
        n=len(grid[0])
        def dfs(grid,i,j,color):
          
            for x,y in [(i+1,j),(i-1,j),(i,j+1),(i,j-1)]:
                if x<m and x>=0 and y<n  and y>=0:
                    if grid[x][y]==1  :
                           grid[x][y]=color
                           dfs(grid,x,y,color)
        color=1
        for i in range(m):
            for j in range(n):
                if grid[i][j]==1:
                    color+=1
                    dfs(grid,i,j,color)
        return color-1
grid=[
  [1, 1, 0, 0, 0],
  [0, 1, 0, 0, 1],
  [0, 1, 0, 1, 1],
  [0, 0, 0, 0, 1],
  [0, 0, 0, 0, 1]
] 
grid=[[0]   ]    
if __name__ == "__main__":
    print(Solution().numIslands(grid))         
        
#434. Number of Islands II
"""
Definition for a point.
class Point:
    def __init__(self, a=0, b=0):
        self.x = a
        self.y = b
    def __str__(self):
        return str(self.x) +'   '+str(self.y)
    
"""

class Solution:
    """
    @param n: An integer
    @param m: An integer
    @param operators: an array of point
    @return: an integer array
    """
    def numIslands2(self, m,n ,positions):
        # write your code here
        
        def node_id(node,n):
            return n*node.x+node.y
        def find_set(x):
            if set[x]!=x:
                set[x]=find_set(set[x])
            return set[x]
        def union_set(x,y):
            root_x,root_y=find_set(x),find_set(y)
            
            set[min(root_x,root_y)]=max(root_x,root_y)
            
        set={}
        number=0
        numbers=[]
        
        direction=[(1,0),(-1,0),(0,1),(0,-1)]
        
        for k,node in enumerate(positions):
          
            if node_id(node,n) in set:
                #print('***')
                numbers.append(number)
                continue
                
            set[node_id(node,n)]=node_id(node,n)
            
            number+=1
            
            
            for  d in direction:
                i,j=node.x+d[0],node.y+d[1]
                if i<m  and i>=0 and j<n and j>=0  and node_id(Point(i,j),n) in set:
                    if find_set(node_id(Point(i,j),n))!=find_set(node_id(node,n)):
                        union_set(node_id(Point(i,j),n),node_id(node,n))
                        number-=1
            numbers.append(number)
        return numbers
                        
n=4
m=5
operators=[Point(1,1),Point(0,1),Point(3,3),Point(3,4)] 


n=3
m=3
positions=[Point(0,0),Point(0,1),Point(2,2),Point(2,2)]                     
                
if __name__ == "__main__":
    print(Solution().numIslands2( n, m, positions))             


#436. Maximal Square
class Solution:
    """
    @param matrix: a matrix of 0 and 1
    @return: an integer
    """
    def maxSquare(self, matrix):
        # write your code here
        
        
   #dp(i, j) represents the length of the square 
   #whose lower-right corner is located at (i, j)
   #dp(i, j) = min{ dp(i-1, j-1), dp(i-1, j), dp(i, j-1) }
        m=len(matrix)
        if m==0:
            return 0
        n=len(matrix[0])
        
        dp=[[0 for _ in range(n+1) ] for _ in range(m+1)]
        
#        for i in range(m):
#            if matrix[i][0]==1:
#                dp[i][0]=1
#        for j in range(n):
#            if matrix[0][j]==1:
#                dp[0][j]=1
        res=0        
        for i in range(1,m+1):
            for j in range(1,n+1):
                if matrix[i-1][j-1]==1:
                    
                   dp[i][j]=min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1
                   res=max(dp[i][j],res)
        return res*res
    
    
matrix=[[1, 0, 1, 0, 0],
[1 ,0 ,1 ,1, 1],
[1 ,1, 1, 1, 1],
[1, 0,0 ,1, 0]]


matrix=[[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1]]
if __name__ == "__main__":
    print(Solution().maxSquare( matrix))             
        
        
        

#437. Copy Books
class Solution:
    """
    @param pages: an array of integers
    @param k: An integer
    @return: an integer
    """
    def copyBooks(self, pages, k):
        # write your code here
#https://zhengyang2015.gitbooks.io/lintcode/copy_books_437.html     
#T[i][j]表示前i本书分配给j个人copy
        m=len(pages)
        if m==0:
            return 0
        if k<=0:
            return -1
        
        dp=[[0 for _ in range(k+1)] for  _ in range(m+1)]
        
        summ=0
        for i in range(1,m+1):
            summ+=pages[i-1]
            dp[i][1]=summ
        for j in range(1,k+1):
            dp[1][j]=pages[0]
            
        for i in range(2,m+1):
            for j in range(2,k+1):
                mini=float('inf')
                if j>i:
                    dp[i][j]=dp[i][j-1]
                    continue
                else:
                    for h in range(j-1,i):
                        temp=max(dp[h][j-1],dp[i][1]-dp[h][1])
                        mini=min(mini,temp)
                dp[i][j]=mini
        return dp[i][k]
    
pages = [3,2,4]
k = 2

pages =[8720,1593,4278,1018,9515,5536,8694,869,8423,9920,3425,9689,9908,1404,8371,6019,7531,943,
        9280,8058,1445,7485,9223,5067,736,6065,1724,3269,130,1297,1701,5585,1209,5901,3760,
        3216,5307,8534,9575,7135,1251,3531,5162,7432,8559,2024,9738,2621,7926,3865,9904,4763,
        2031,4561,5870,6033,6442,6405,9886,8455,8970,6746,7923,5222,274,3875,5821,816,3459,9916,
        9447,4252,1871,5784,8272,9526,1531,5647,6676,2416,6281,7878,4382,5376,3618,1158,3717,5573,
        5602,5919,7579,6628,929,6897,8324,8657,8342,8190,7384,2466,8715,2499,9144,7349,3236,2852,
        4613,1917,5345,9288,9205,3363,5008,156,4716,6924,3490,605,3872,577,5393,7941,7390,7042,8242
        ,5376,5939,3910,4727,4053,4850,5531,2658,3876,9379,6157,7544,2845,5499,459,3119,2984,5567,
        5706,1507,5971,8369,8177,5985,1215,8258,2925,9193,7999,334,4761,2586,7770,195,5804,3898,
        7214,6625,2975,4078,5441,9944,4161,9225,7012,6383,4441,4474,7030,7292,6938,48,6253,4707,
        2078,8449,7011,65,7205,4841,2066,5097,3875,6431,2626,6325,789,5047,324,3528,1325,2443,281,
        3094,1908,9686,8720,9310,6817,1856,2137,7718,1180,5988,8766,3408,8439,2555,2214,2678,1991,
        7393,6323,9586,8430,3298,9828,9386,5406,12,7231,8808,3655,208,6314,246,6279,9172,9980,5042,
        5659,7293,5428,2789,6454,2887,5948,6895,847,1443,754,4889,9509,2008,7163,5297,3845,7290,636,
        1900,7035,2718,6348,9216,2577,9852,3935,412,6605,3786,2158,9280,9835,8941,2575,2868,9006,
        6860,8101,3714,7940,268,8199,5597,9898,982,2825,5125,9865,3008,7575,8914,7330,4410,2063,214,
        3625,1588,8894,7882,503,8305,2701,8230,1336,1946,1318,2314,7348,3387,670,3682,7588,9411,
        3812,2509,1106,6148,9162,3716,9041,4980,2057,251,1778,7969,2805,5764,1266,6531,5219,8550,
        1921,9687,8127,826,4642,9398,4097,512,3296,2618,5132,2890,3471,2757,6336,5853,789,980,9109,
        5240,9449,758,8198,3420,4998,4239,995,5805,1997,9124,1265,694,8920,1770,3965,9473,6176,9059,
        6479,3190,8678,7136,9005,6420,1664,8229,8838,6959,8267,3220,8445,7166,7999,6727,4942,8306,
        5704,2005,9106,6139,1954,8219,1707,150,9456,2125,9215,6515,3446,2391,5560,2031,4940,7600,
        5852,6911,6330,571,1691,4217,9403,8555,4183,7995,8398,7931,7509,127,2514,7970,47,7970,2914,
        9730,86,12,723,4736,8464,1108,5422,5102,57,3366,9275,7030,7054,1230,9787,9268,8967,2653,
        1453,5486,7214,3899,9681,315,965,7969,8778,7791,2656,3646,988,261,3800,1317,9497,386,243,
        7713,9333,1563,9973,4759,4799,6150,2865,5293,9948,8505,1550,1240,321,2195,1521,2108,1552,
        3275,6184,2752,9108,3932,1909,5232,2702,3743,1181,7464,1925,4419,8051,796,893,1317,4384,
        8060,4508,4579,5755,6765,1733,117,7343,2719,154,5986,5197,2767,7902,2574,606,2351,558,2739,
        5230,310,3186,9391,6219,8236,6141,668,9697,1218,4273,8812,3986,2631,6865,6216,9427,3287,
        5480,1000,8315,3384,4275,630,9182,8713,9918,3415,3572,9152,6451,8058,9499,1922,1988,1525,
        3348,6806,6996,9026,7077,6816,6489,3395,3714,3595,1134,7325,3761,4924,1157,4308,9439,2307,
        9943,821,4355,5258,5927,9518,6464,3397,942,8028,3266,639,62,2752,5404,2183,2678,8969,7628,
        6666,8509,1246,5546,6889,6537,3432,47,4987,7518,1844,7433,2957,9424,8790,620,6029,7828,8353,
        5974,8560,4415,4788,1794,9941,7061,4465,5854,316,5598,7581,5248,1008,7063,1562,3062,1903,
        7599,3556,3807,7722,7223,1664,8909,4789,1482,9222,2706,1275,3133,5968,588,6682,8964,3264,
        2602,9032,559,7110,974,8997,9697,9367,2028,4764,3815,8957,8214,1710,5591,1100,4609,9684,
        9279,7118,256,5260,633,4223,5345,3597,5404,380,1414,5893,3404,8497,7643,7964,7377,5257,
        1343,5333,9756,8275,9046,3683,3874,6575,4983,1321,9673,8735,624,4445,3940,8732,620,3404,
        3246,6625,4801,3359,8994,7877,2082,1077,8220,8439,3208,362,3282,399,4196,104,2410,9877,9678,
        6326,1443,1647,8627,5171,9869,4092,9068,7882,5249,3254,8011,9659,7355,3520,6863,6891,2744,
        7413,6916,1100,3316,8290,4895,7062,6393,78,8002,3826,8206,1122,2555,2084,5833,6819,9490,
        6316,9488,8609,4711,3897,2446,7384,27,8203,137,5780,1161,9041,8716,3669,3225,1991,9653,
        7780,313,2234,3678,9120,1253,9659,3745,3469,5496,6550,8747,7934,5594,5987,5323,1277,6221,
        6939,9121,4829,331,3666,9932,5244,3512,704,4269,1726,2382,8691,7536,8362,7610,9446,1255,
        2997,7226,1821,1726,7208,6087,3478,5167,1880,4998,5870,9032,3941,7188,1880,8584,179,4042,
        239,3004,2414,4613,8279,6636,2603,9247,3039,7669,2180,7440,3274,5366,2395,2214,3257,4791,
        2081,1631,6292,4254,3733,9828,3644,3522,2550,4424,9989,7654,118,3505,216,5902,4131,2754,
        3333,4072,5624,4975,1160,3900,7783,1200,1361,9290,9284,1251,9817,6255,4832,8680,3667,8141,
        8951,1507,6395,4189,9869,7080,2084,5060,5153,5762,5680,7705,8415,2142,5837,6711,8460,3254,
        5306,869,2364,7737,3892,9618,605,2948,9414,371,4397,3807,1720,9327,961,3598,573,6542,8806,
        3522,2166,3899,9642,8781,1321,6424,7085,5827,3592,9206,8494,9878,8889,8246,3800,7856,4523,
        2859,7029,7764,7891,1825,2165,2544,9758,6080,6399,121,759,1222,5545,2181,9505,7805,6212,
        2743,3059,9952,2826,5660,4951,9826,6066,3340,2614,9186,8971,8866,832,319,4276,1441,5118,
        5409,2587,9550,2542,3995,4005,2197,6265,6070,9324,8711,9977,5444,296,8550,3154,5899,3510,
        1093,6249,8534,4619,1096,3509,5261,6209,1289,8425,3941,4955,3570,5466]
k =165
if __name__ == "__main__":
    print(Solution().copyBooks( pages, k))             
                
                
    
#437. Copy Books
class Solution:
    """
    @param pages: an array of integers
    @param k: An integer
    @return: an integer
    """
    def copyBooks(self, pages, k):
        n=len(pages)
        if n==0:
            return 0
        
        def copierNeed(pages,limit):
            summ=pages[0]
            copiers=1
            for i in range(1,n):
                
                if (summ+pages[i])>limit:
                    copiers+=1
                    summ=0
                summ+=pages[i]
                
            return copiers
        
        maxi=0
        total=0
        for x in pages:
            total+=x
            if x>maxi:
                maxi=x
        start=maxi
        end=total
        
        while start+1<end:
            mid=(start+end)//2
            if copierNeed(pages,mid)<=k:
                end=mid
            else:
                start=mid
        if copierNeed(pages,start)<=k:
                return start
        else:
                return end
        
        
        
#439. Segment Tree Build II
"""
Definition of SegmentTreeNode:
class SegmentTreeNode:
    def __init__(self, start, end, max):
        self.start, self.end, self.max = start, end, max
        self.left, self.right = None, None
"""

class Solution:
    """
    @param A: a list of integer
    @return: The root of Segment Tree
    """
    def build(self, A):
        # write your code here
        
        def building(start,end,A):
            if start>end:
                return None
            node=SegmentTreeNode(start,end,A[start])
             
            if start==end:
                 return node
            
            mid=(start+end)//2
            node.left=building(start,mid,A)
            node.right=building(mid+1,end,A)
            
            if node.left  and node.left.maxi>node.maxi:
                node.maxi=node.left.maxi
            if node.right  and node.right.maxi>node.maxi:
                node.maxi=node.right.maxi
            return node
        return building(0,len(A)-1,A)
            
            

#442. Implement Trie (Prefix Tree) 
class TrieNode:
    def __init__(self):
        self.children={}
        self.hasword=False
    
class Trie:
    
    def __init__(self):
        # do intialization if necessary
        self.root=TrieNode()

    """
    @param: word: a word
    @return: nothing
    """
    def insert(self, word):
        # write your code here
        cur=self.root
        
        for i in range(len(word)):
            if word[i] not in cur.children:
                cur.children[word[i]]=TrieNode()
            cur=cur.children[word[i]]
        cur.hasword=True
                

    """
    @param: word: A string
    @return: if the word is in the trie.
    """
    def search(self, word):
        # write your code here
        cur=self.root
        
        for i in range(len(word)):
            if word[i] not in cur.children:
                return  False
            cur=cur.children[word[i]]
        return cur.hasword

    """
    @param: prefix: A string
    @return: if there is any word in the trie that starts with the given prefix.
    """
    def startsWith(self, prefix):
        # write your code here
        cur=self.root
        
        for i in range(len(prefix)):
            if prefix[i] not in cur.children:
                return  False
            cur=cur.children[prefix[i]]
        return True
        
n5b# -*- coding: utf-8 -*-
"""
Created on Fri Jun 29 01:22:05 2018

@author: cz
"""

#445. Cosine Similarity 
class Solution:
    """
    @param: A: An integer array
    @param: B: An integer array
    @return: Cosine similarity
    """
    def cosineSimilarity(self, A, B):
        # write your code here
        if not A and not B:
            return 2.0000
        top=sum([x*y for x , y in zip(A,B)])
        bottom=(sum([x*x for x in A])* sum([x*x for x in B]))**0.5
        
        if bottom==0:
            return 2.0000
        else:
            return top/bottom
        
        
#448. Inorder Successor in BST
"""
Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
"""


class Solution:
    """
    @param: root: The root of the BST.
    @param: p: You need find the successor node of p.
    @return: Successor of p.
    """
    def inorderSuccessor(self, root, p):
        # write your code here
        
        def inorder(node,res):
            if not node:
                return 
            inorder(node.left)
            res.append(node.val)
            inorder(node.right)
        res=[]
        inorder(root,res)
        for i in range(1,len(res)):
            if res[i-1]==p:
                return res[i]
        
            
        
#450. Reverse Nodes in k-Group        
"""
Definition of ListNode
class ListNode(object):
    def __init__(self, val, next=None):
        self.val = val
        self.next = next
"""

class Solution:
    """
    @param head: a ListNode
    @param k: An integer
    @return: a ListNode
    """
    def reverseKGroup(self, head, k):
        # write your code here
        # D->[1->2->3]->[4->5->6]->7 (k = 3)
        # D->[3->2->1]->[6->5->4]->7
        dummy=ListNode(0)
        dummy.next=head
        prev=dummy
        
        while prev:
            prev=self.reverse_next_k_node(prev,k)
        return dummy.next
    
    def find_kth_node(self,head,k):
        # head -> n1 -> n2 -> ... ->nk
        cur=head
        for _ in range(k):
            if not cur:
                return None
            cur=cur.next
        return cur
    
    def reverse(self,head):
        prev=None
        cur=head
        
        while cur:
            temp=cur.next
            cur.next=prev
            prev=cur
            cur=temp
        return prev
    
            
    def  reverse_next_k_node(self,head,k):
        # head -> n1 -> n2 -> ... ->nk -> nk+1
        # head -> nk -> nk-1 -> ... ->n1 -> nk+1
        n1=head.next
        nk=self.find_kth_node(head,k)
        if not nk:
            return None
        
        nk_plus=nk.next
        nk.next=None# separate the nk and nk+1
        
        nk=self.reverse(n1)
        # Connect head and nk -> nk-1 -> ... ->n1,  n1 and nk+1 -> nk+2 ->..
        head.next=nk
        n1.next=nk_plus
        return n1
        
        
        
#451. Swap Nodes in Pairs        
"""
Definition of ListNode
class ListNode(object):
    def __init__(self, val, next=None):
        self.val = val
        self.next = next
"""

class Solution:
    """
    @param head: a ListNode
    @return: a ListNode
    """
    def swapPairs(self, head):
        # write your code here
        dummy=ListNode(0)
        dummy.next=head
        prev=dummy
        k=2
        
        while prev:
            prev=self.reverse_next_k_node(prev,k)
        return dummy.next
    
    def find_kth_node(self,head,k):
        # head -> n1 -> n2 -> ... ->nk
        cur=head
        for _ in range(k):
            if not cur:
                return None
            cur=cur.next
        return cur
    
    def reverse(self,head):
        prev=None
        cur=head
        
        while cur:
            temp=cur.next
            cur.next=prev
            prev=cur
            cur=temp
        return prev
    
            
    def  reverse_next_k_node(self,head,k):
        # head -> n1 -> n2 -> ... ->nk -> nk+1
        # head -> nk -> nk-1 -> ... ->n1 -> nk+1
        n1=head.next
        nk=self.find_kth_node(head,k)
        if not nk:
            return None
        
        nk_plus=nk.next
        nk.next=None# separate the nk and nk+1
        
        nk=self.reverse(n1)
        # Connect head and nk -> nk-1 -> ... ->n1,  n1 and nk+1 -> nk+2 ->..
        head.next=nk
        n1.next=nk_plus
        return n1
      
        
#452. Remove Linked List Elements
"""
Definition of ListNode
class ListNode(object):
    def __init__(self, val, next=None):
        self.val = val
        self.next = next
"""

class Solution:
    """
    @param head: a ListNode
    @param val: An integer
    @return: a ListNode
    """
    def removeElements(self, head, val):
        # write your code here
#1->2->3->3->4->5->3, val = 3, you should return the list as 1->2->4->5  
        
        dummy=ListNode(-1)
        dummy.next=head
        
        cur=dummy
        while cur:
            while cur.next and cur.next.val==val:
                cur.next=cur.next.next
            cur=cur.next
        return dummy.next
        
        
        
        
#453. Flatten Binary Tree to Linked List        
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""

class Solution:
    """
    @param root: a TreeNode, the root of the binary tree
    @return: nothing
    """
    def flatten(self, root):
        # write your code here
        if not root:
            return None
        
        self.flatten(root.left)
        self.flatten(root.right)
        
        if not root.left:
            return 
        
        p=root
        
        p=p.left
        
        while p.right:
            p=p.right
        p.right=root.right
        root.right=root.left
        root.left=None
        
        
#454. Rectangle Area
class Rectangle:

    '''
     * Define a constructor which expects two parameters width and height here.
    '''
    # write your code here
    
    def __init__(self,length,width):
        self.length=length
        self.width=width
    
    
    '''
     * Define a public method `getArea` which can calculate the area of the
     * rectangle and return.
    '''
    # write your code here
    def getArea(self):
        return self.length*self.width


#457. Classical Binary Search
class Solution:
    """
    @param: nums: An integer array sorted in ascending order
    @param: target: An integer
    @return: An integer
    """
    def findPosition(self, nums, target):
        # write your code here
        if not nums:
            return -1
        n=len(nums)
        
        if n==1:
            if target==nums[0]:
                return 0
            else:
                return -1
        l=0
        r=n-1
        
        while l<=r:
            mid=(l+r)//2
            
            if nums[mid]>target:
                r=mid-1
            elif nums[mid]<target:
                l=mid+1
            else:
                return mid
        if l < len(nums) or l>=0 or nums[l]!=target:
            return -1
        else:
            return 1
          
#Given [1, 2, 2, 4, 5, 5]
#For target = 2, return 1 or 2
#For target = 5, return 4 or 5
#For target = 6, return -1
nums=[1, 2, 2, 4, 5, 5]
target=4
nums=[100,156,189,298,299,300,1001,1002,1003,1004]
target=1000
if __name__ == "__main__":
    print(Solution().findPosition(nums, target))             
                
#455. Student ID
class Student:
    def __init__(self, id):
        self.id = id;

class Class:
     def __init__(self, n):
         self.students=[]
         for i in range(n):
             self.students.append(Student(i))
             

    '''
     * Declare a constructor with a parameter n which is the total number of
     * students in the *class*. The constructor should create n Student
     * instances and initialized with student id from 0 ~ n-1
    '''
    # write your code here


#460. Find K Closest Elements
class Solution:
    """
    @param A: an integer array
    @param target: An integer
    @param k: An integer
    @return: an integer array
    """
    def kClosestNumbers(self, A, target, k):
        # write your code here
        def isLeftCloser(A,left,right,target):
            if left <0:
                return False
            if right>=len(A):
                return True
            
            if abs(A[left]-target) <= abs(A[right]-target):
                return True
            else:
                return False
        
        def findLowerClosest(A,target):
            l=0
            r=len(A)-1
            while l+1<r:
                mid=(l+r)//2
                
                if A[mid]<target:
                    l=mid
                else:
                    r=mid
            if A[r]<target:
                return r
            if A[l]<target:
                return l
            return -1
            
        left=findLowerClosest(A,target)
        right=left+1
        
        res=[]
        for i in range(k):
            if isLeftCloser(A,left,right,target):
                res.append(A[left])
                left-=1
            else:
                res.append(A[right])
                right+=1
        return res
A = [1, 2, 3]
target = 2 
k = 3
A = [1, 4, 6, 8]
target = 3 
k = 3
A =[22,25,100,209,1000,1110,1111]
target =15
k =5
if __name__ == "__main__":
    print(Solution().kClosestNumbers(A, target, k))             
                            


#463. Sort Integers
class Solution:
    """
    @param A: an integer array
    @return: nothing
    """
    def sortIntegers(self, A):
        # write your code here
        
        def partition(A,start,end):
            pivot=A[start]
            left=start+1
            right=end
            
            while left<=right:
                while left<=right  and A[left]<=pivot:
                    left+=1
                while left<=right  and A[right]>=pivot:
                    right-=1
                if left<=right:
                    
                    A[left],A[right]=A[right],A[left]
            A[start],A[right]=A[right],A[start]
            return right
        def quicksort(A,start,end):
            if start>=end:
                return 
            partition_point=partition(A,start,end)
            quicksort(A,start,partition_point-1)
            
            quicksort(A,partition_point+1,end)
        
        quicksort(A,0,len(A)-1)   
        print(A)
A=[3, 1, 1, 4, 4]  
A=[1]          
if __name__ == "__main__":
    print(Solution().sortIntegers(A))                                 
            

#464. Sort Integers II
class Solution:
    """
    @param A: an integer array
    @return: nothing
    """
    def sortIntegers2(self, A):
        # write your code here
        def merge(a,b):
            if not a:
                return b
            if not b:
                return a
            
            na=len(a)
            nb=len(b)
            
            pa=0
            pb=0
            
            res=[]
            while pa<na and pb<nb:
                if a[pa]<b[pb]:
                    res.append(a[pa])
                    pa+=1
                else:
                    res.append(b[pb])
                    pb+=1
            while pa<na:
                res.append(a[pa])
                pa+=1
            while pb<nb:
                res.append(b[pb])
                pb+=1
            return res
        
        def mergeSort(A):
            n=len(A)
            if n==1:
                return A
            
            mid=(0+n)//2
            a=mergeSort(A[:mid])
            b=mergeSort(A[mid:])
            
            return merge(a,b)
        
        res=mergeSort(A)   
        
        for i in range(len(A)):
            A[i]=res[i]
        return res
A=[3,2,1,4,5]  
A=[1,1]     
A=[1,3,7,7,8] 
A=[1,3,7,7,8,4,19,11,3]    
if __name__ == "__main__":
    print(Solution().sortIntegers2(A))            


#466. Count Linked List Nodes
"""
Definition of ListNode
class ListNode(object):
    def __init__(self, val, next=None):
        self.val = val
        self.next = next
"""

class Solution:
    """
    @param head: the first node of linked list.
    @return: An integer
    """
    def countNodes(self, head):
        # write your code here
        if not head:
            return 0
        cur=head
        count=0
        while cur:
            count+=1
            cur=cur.next
        return count
            


#469. Same Tree
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""

class Solution:
    """
    @param a: the root of binary tree a.
    @param b: the root of binary tree b.
    @return: true if they are identical, or false.
    """
    def isIdentical(self, a, b):
        # write your code here
        
        def isSame(x,y):
            if not x and y:
                return False
            elif not y and x:
                return False
            elif x.val !=y.val:
                return False
            else:
                return isSame(x.left,y.left)  and isSame(x.right,y.right)
        return isSame(a,b)



#471. Top K Frequent Words
class Solution:
    """
    @param words: an array of string
    @param k: An integer
    @return: an array of string
    """
    def topKFrequentWords(self, words, k):
        # write your code here
        from collections import Counter
        c=Counter(words)
        print(c)
        res=[]
        for key,v in c.items():
            res.append((v,key))
        
        res.sort(key=lambda x:(-x[0],x[1]))
        print(res)
        ans=[]
        print(len(res))
        print(k)
        for i in range( min(len(res),k)):
            ans.append(res[i][1])
        return ans

words=["yes","lint","code","yes","code","baby","you","baby","chrome","safari",
       "lint","code","body","lint","code"]
k=3
if __name__ == "__main__":
    print(Solution().topKFrequentWords(words, k))              




#473. Add and Search Word - Data structure design
class TrieNode:
    def __init__(self):
        self.children={}
        self.hasword=False
class WordDictionary:
    def __init__(self):
        self.root=TrieNode()
    """
    @param: word: Adds a word into the data structure.
    @return: nothing
    """
    def addWord(self, word):
        # write your code here
        cur=self.root
        for w in  word:
            if w not in cur.children:
                cur.children[w]=TrieNode()
            cur=cur.children[w]
        cur.hasword=True

    """
    @param: word: A word could contain the dot character '.' to represent any one letter.
    @return: if the word is in the data structure.
    """
    def search(self, word):
        # write your code here
        def searchFrom(tries,word):
            cur=tries
            for i,w in enumerate(word):
                if w=='.':
                    for k in cur.children:
                        if searchFrom(cur.children[k],word[i+1:]):
                            return True
                    return False
                elif  w not in cur.children:
                    return False
                cur=cur.children[w]
            return cur.hasword
        
        return searchFrom(self.root,word)
ss = WordDictionary() 
ss.addWord("bad")
ss.addWord("dad")
ss.addWord("mad")
ss.search("pad") 
ss.search("bad")
ss.search(".ad") 
ss.search("b..")
ss.search("b...")

#474. Lowest Common Ancestor II
"""
Definition of ParentTreeNode:
class ParentTreeNode:
    def __init__(self, val):
        self.val = val
        self.parent, self.left, self.right = None, None, None
"""


class Solution:
    """
    @param: root: The root of the tree
    @param: A: node in the tree
    @param: B: node in the tree
    @return: The lowest common ancestor of A and B
    """
    def lowestCommonAncestorII(self, root, A, B):
        # write your code here
        if A==root or B==root:
            return root
        if not root:
            return None
        
        if A==B:
            return A
        
        curA=A
        Aparent=[]
        while curA:
            Aparent.append(curA)
            curA=curA.parent
            
        curB=B
        Bparent=[]
        while curB:
            Bparent.append(curB)
            curB=curB.parent
            
        AL=len(Aparent)
        BL=len(Bparent)
        print(AL,BL)
        if BL>AL:
            AL, BL =  BL ,AL
            Aparent ,Bparent= Bparent, Aparent
            
        gap=AL-BL
        
        Ai=gap
        Bi=0
        
        while Ai<AL and Bi<BL:
            if Aparent[Ai]==Bparent[Bi]:
                return Bparent[Bi].val
            Ai+=1
            Bi+=1
            
            
root=  ParentTreeNode(1)
root.left=   ParentTreeNode(2) 
root.right=   ParentTreeNode(3)   

root.left.parent=root 
root.right.parent=root

root.right.right=   ParentTreeNode(4)  
root.right.right.parent= root.right

A=  root.left
B=root.right.right 
if __name__ == "__main__":
    print(Solution().lowestCommonAncestorII(root, A, B))              
            
#476. Stone Game        
class Solution:
    """
    @param A: An integer array
    @return: An integer
    """
    def stoneGame(self, A):
        # write your code here
#        self.ans=float('inf')
#        def add(B,res,memo):
#            n=len(B)
#            
#            if tuple(B) in memo:
#                return memo[tuple(B)]
#                       
#            if n==2:
#                 temp= res+B[0]+B[1]
#                 memo[tuple(B)]=temp
#                 if temp<self.ans:
#                     self.ans=temp
#                 return 
#                     
#                
#            
#            for i in range(n-1):
#                
#                tmp=B[i] +B[i+1] 
#                re=add(B[:i]+[ B[i] +B[i+1] ] +B[i+2:],res+ tmp)
#                
#                
#                #print(temp,B[i] , B[i+1],B[:i]+[ B[i] +B[i+1] ] +B[i+2:]  )
#               
#        add(A,0)
#        return self.ans if self.ans<float('inf') else 0
        
        
        n=len(A)
        if n==0:
            return 0
        
        sumA=[[0 for _ in range(n)] for _ in range(n)]
        dp=[[0 for _ in range(n)] for _ in range(n)]
        
        
        for i in range(n):
            sumA[i][i]=A[i]
            dp[i][i]=0
            for j in range(i+1,n):
                sumA[i][j]= sumA[i][j-1]+A[j]
                
        
        for length in range(2,n+1):
            for i in range(n):
                j=i+length-1
                if j<n:
                    tempmin=float('inf')
                    for k in range(i,j):
#                        print(dp[i][k])
#                        print(dp[k+1][j])
#                        print(sumA[i][j])
#                        print()
                        tempmin=min(tempmin,dp[i][k]+dp[k+1][j])
                        
                    dp[i][j]=tempmin+sumA[i][j]
        return dp[0][n-1]
A=[4, 1, 1, 4]   
A=[1, 1, 1, 1]
A=[4, 4, 5, 9]             
if __name__ == "__main__":
    print(Solution().stoneGame( A))             
        
        
        







#477. Surrounded Regions
class Solution:
    """
    @param: board: board a 2D board containing 'X' and 'O'
    @return: nothing
    """
    def surroundedRegions(self, board):
        # write your code here
#X X X X
#X O O X
#X X O X
#X O X X        
       
       
#X X X X
#X X X X
#X X X X
#X O X X        
        m=len(board)
        if m==0 or m==1  or m==2:
          return 
        n=len(board[0])
        if n==0 or n==1 or n==2:
          return
        from collections import deque
        def fill(board,i,j):
            if board[i][j]!='O':
                return 
            
            q=deque([(i,j)])
            board[i][j]='W'
            while q:
                a,b=q.popleft()
                
                for x , y in ((a+1,b),(a-1,b),(a,b+1),(a,b-1)):
                    if x>=0 and y>=0 and x<len(board)  and y<len(board[0]) and board[x][y]=='O':
                        q.append((x,y))
                        board[x][y]='W'
        board2=[list(row)  for row in board]
        for i in range(m):
            fill(board2,i,0)
            fill(board2,i,n-1)
        for j in range(n):
            fill(board2,0,j)
            fill(board2,m-1,j)
        
        print(board2)
        for i in range(m):
            for j in range(n):
                if board2[i][j]=='W':
                    board2[i][j]='O'
                elif board2[i][j]=='O':
                    board2[i][j]='X'
        for i in range(m):
            board[i]=''.join(board2[i])
            
        print(board)
 
        
board=["XXXX","XOOX","XXOX","XOXX"] 
board=["XXXX","XOOX","XXOX","XOOO"] 
           
if __name__ == "__main__":
    print(Solution().surroundedRegions( board))              


#478. Simple Calculator
class Calculator:
    """
    @param a: An integer
    @param operator: A character, +, -, *, /.
    @param b: An integer
    @return: The result
    """
    def calculate(self, a, operator, b):
        if operator=='+':
            return a+b
        elif operator=='-':
            return a-b
        elif operator=='*':
            return a*b
        else:
            return a/b
        
              
              
#479. Second Max of Array
class Solution:
    """
    @param nums: An integer array
    @return: The second max number in the array.
    """
    def secondMax(self, nums):
        # write your code here
        n=len(nums)
        if n==0 or n==1:
            return None
        
        if n==2:
            return min(nums)
        max1=float('-inf')
        max2=float('-inf')
        max3=float('-inf')
        
        for x in nums:
            if x >= max1:
                if max1>=max2:
                    max2=max1
                max1=x
            elif x>=max2:
                max2=x
            
                
                
        return max2
nums=    [1, 3, 2, 4]
if __name__ == "__main__":
    print(Solution().secondMax( nums))    
            
            
     
#480. Binary Tree Paths                 
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""

class Solution:
    """
    @param root: the root of the binary tree
    @return: all root-to-leaf paths
    """
    def binaryTreePaths(self, root):
        # write your code here
        if not root:
            return []
        if not root.left and not root.right:
            return [str(root.val)]
        
        res=[]
        def walk(node,res,path):
            if not node.left and not node.right:
                res.append(path[:])
                return 
            if node.left:
                walk(node.left,res,path+'->'+str(node.left.val))
            if node.right:
                walk(node.right,res,path+'->'+str(node.right.val))
        walk(root,res,str(root.val))
        return res

            
#484. Swap Two Integers in Array        
class Solution:
    """
    @param A: An integer array
    @param index1: the first index
    @param index2: the second index
    @return: nothing
    """
    def swapIntegers(self, A, index1, index2):
        # write your code here
        A[index1], A[index2] = A[index2] ,A[index1]
                  
        
        
        
        
#486. Merge K Sorted Arrays 
class Solution:
    """
    @param arrays: k sorted integer arrays
    @return: a sorted array
    """
    def mergekSortedArrays(self, arrays):
        # write your code here
        import heapq
        
        hp=[]
        for ai,array in enumerate(arrays):
            if not array:
                continue
            heapq.heappush(hp,(array[0],ai,0))
        res=[]
        while hp:
            value,ai,vi=heapq.heappop(hp)
            res.append(value)
            if vi+1<len(arrays[ai]):
               heapq.heappush(hp,(arrays[ai][vi+1],ai,vi+1))
        return res
        
arrays=[
  [1, 3, 5, 7],
  [2, 4, 6],
  [0, 8, 9, 10, 11]
]                    
if __name__ == "__main__":
    print(Solution().mergekSortedArrays( arrays))         

        
        
#487. Name Deduplication        
class Solution:
    """
    @param names: a string array
    @return: a string array
    """
    def nameDeduplication(self, names):
        # write your code here  
        if not names:
            return []
        nameset=set()
        for name in names:
            nameset.add(name.lower())
        return list(nameset)
names=["James", "james", "Bill Gates", "bill Gates", "Hello World", "HELLO WORLD", "Helloworld"]             
if __name__ == "__main__":
    print(Solution().nameDeduplication(names))         
        
#488. Happy Number
class Solution:
    """
    @param n: An integer
    @return: true if this is a happy number or false
    """
    def isHappy(self, n):
        # write your code here
        if n==1:
            return False
        
        Nset=set()
        
        def digitSum(n):
            res=0
            while n:
                res+=(n%10)**2
                n=n//10
            return res
        
        
        while True:
              Nsum=digitSum(n)
              #print(Nsum)
              if Nsum ==1:
                  return True
              if Nsum not in Nset:
                  Nset.add(Nsum)
                  n=Nsum
                  
              else:
                  return False
n=19             
if __name__ == "__main__":
    print(Solution().isHappy( n))                  
            
            
#491. Palindrome Number
class Solution:
    """
    @param num: a positive number
    @return: true if it's a palindrome or false
    """
    def isPalindrome(self, num):
        # write your code here
        
        def check(s):
            if not s:
                return True
            n=len(s)
            if n==1:
                return True
            if s[0]!=s[-1]:
                return False
            else:
                return check(s[1:-1])
        return check(str(num))
num=12321        
if __name__ == "__main__":
    print(Solution().isPalindrome( num))        
              
#495. Implement Stack
class Stack:
    """
    @param: x: An integer
    @return: nothing
    """
    def __init__(self):
        self.array=[]
    def push(self, x):
        # write your code here
        self.array.append(x)

    """
    @return: nothing
    """
    def pop(self):
        # write your code here
        if not self.isEmpty():
            val=self.array[-1]
            del self.array[-1]
            
            return  val
        else:
            return None 

    """
    @return: An integer
    """
    def top(self):
        # write your code here
        if not self.isEmpty():
          return  self.array[-1]
        else:
            return None

    """
    @return: True if the stack is empty
    """
    def isEmpty(self):
        # write your code here
        if len(self.array)==0:
            return True
        else:
            return False
    
    
    
        
#496. Toy Factory
class Toy:
    def talk(self):
        raise NotImplementedError('This method should have implemented.')

class Dog(Toy):
    # Write your code here
    def talk(self):
        print('Wow')


class Cat(Toy):
    # Write your code here
    def talk(self):
        print('Meow')


class ToyFactory:
    # @param {string} shapeType a string
    # @return {Toy} Get object of the type
    def getToy(self, type):
        # Write your code here
        if type=='Dog':
            return Dog()
        if type=='Cat':
            return Cat()
        return 
            
            

#499. Word Count (Map Reduce)
class WordCount:

    # @param {str} line a text, for example "Bye Bye see you next"
    def mapper(self, _, line):
        # Write your code here
        # Please use 'yield key, value'

        for x in line.split():
            yield x,1
    # @param key is from mapper
    # @param values is a set of value with the same key
    def reducer(self, key, values):
        # Write your code here
        # Please use 'yield key, value'  
        yield key,sum(values)          
        
        
        
        
        
        
        
#501. Design Twitter        
'''
Definition of Tweet:
class Tweet:
    @classmethod
    def create(cls, user_id, tweet_text):
         # This will create a new tweet object,
         # and auto fill id
'''

from collections import defaultdict
import heapq
class MiniTwitter:
    
    def __init__(self):
        # do intialization if necessary
        self.map=defaultdict(list)
        self.time=0
        self.follow_id=defaultdict(list)
        

    """
    @param: user_id: An integer
    @param: tweet_text: a string
    @return: a tweet
    """
    def postTweet(self, user_id, tweet_text):
        # write your code here
        new_tweet=Tweet.create( user_id, tweet_text)
        self.map[user_id].append(( self.time, new_tweet    ))
        self.time+=1
        return new_tweet
        

    """
    @param: user_id: An integer
    @return: a list of 10 new feeds recently and sort by timeline
    """
    def getNewsFeed(self, user_id):
        # write your code here
        heap=[]
        for follow in self.follow_id[user_id]:
            for time , t in self.map[follow]:
                heapq.heappush(heap,(    -time, t ))
        
        for time , t in self.map[user_id]: 
                heapq.heappush(heap,(    -time, t ))
        n=len(heap)
        
        i=0
        res=[]
        while i < 10 and i < n:
            time,tweet=heapq.heappop(heap)
            res.append(tweet)
            i+=1
        return res

            
            
        
       

    """
    @param: user_id: An integer
    @return: a list of 10 new posts recently and sort by timeline
    """
    def getTimeline(self, user_id):
        # write your code here
        heap=[]
        
        
        for time , t in self.map[user_id]: 
                heapq.heappush(heap,(    -time, t ))
        n=len(heap)
        
        i=0
        res=[]
        while i < 10 and i < n:
            time,tweet=heapq.heappop(heap)
            res.append(tweet)
            i+=1
        return res

        
        
    
        

    """
    @param: from_user_id: An integer
    @param: to_user_id: An integer
    @return: nothing
    """
    def follow(self, from_user_id, to_user_id):
        # write your code here
        if to_user_id not in self.follow_id[from_user_id]:
            
           self.follow_id[from_user_id].append(to_user_id )

    """
    @param: from_user_id: An integer
    @param: to_user_id: An integer
    @return: nothing
    """
    def unfollow(self, from_user_id, to_user_id):
        
        # write your code here   
        if to_user_id  in self.follow_id[from_user_id]:
            self.follow_id[from_user_id].remove(to_user_id )
            
       
        
        
        
postTweet(1, "LintCode is Good!!!")
getNewsFeed(1)

follow(2, 1)
getNewsFeed(2)
unfollow(2, 1)
getNewsFeed(2)
        
        

        
#504. Inverted Index (Map Reduce)
'''
Definition of Document
class Document:
    def __init__(self, id, cotent):
        self.id = id
        self.content = content
'''
class InvertedIndex:

    # @param {Document} value is a document
    def mapper(self, _, value):
        # Write your code here
        # Please use 'yield key, value' here


    # @param key is from mapper
    # @param values is a set of value with the same key
    def reducer(self, key, values):
        # Write your code here
        # Please use 'yield key, value' here        
        
        
        
        
#507. Wiggle Sort II
class Solution:
    """
    @param: nums: A list of integers
    @return: nothing
    """
    def wiggleSort(self, nums):
        # write your code here
        
#https://leetcode.com/problems/wiggle-sort-ii/discuss/125429/Python-solution-with-virtual-indexing        
#https://leetcode.com/problems/wiggle-sort-ii/discuss/77682/Step-by-step-explanation-of-index-mapping-in-Java
        
        def partition(A,start,end):
            import random
            pivot_index=random.randrange(start,end+1)
            pivot=A[pivot_index]
            
            A[pivot_index],A[end]=A[end],A[pivot_index]
            partition_index=start
            for i in range(start,end):
                if A[i]>=pivot:
                    A[partition_index], A[i] =A[i],A[partition_index]
                    partition_index+=1
            A[partition_index],A[end]=A[end],A[partition_index] 
            return partition_index
                
        def quickselct(A,start,end,k):
            if start==end:
                return A[start]
            cur_index=partition(A,start,end)
            
            if cur_index==k:
                return A[k]
            elif cur_index>k:
                return quickselct(A,start,cur_index-1,k)
            else:
                return quickselct(A,cur_index+1,end,k)
        
        n=len(nums)
        if n==1:
            return 
        f=lambda i: (1+2*i)%(n|1)
        
        mid=quickselct(nums,0,n-1,n//2)
        
        k=n-1
        i=0
        j=0
        
        while j<=k:
            if nums[f(j)]>mid:
                nums[f(j)],nums[f(i)]=nums[f(i)],nums[f(j)]
                j+=1
                i+=1
            elif nums[f(j)]<mid:
                nums[f(j)],nums[f(k)]=nums[f(k)],nums[f(j)]
                k-=1
            else:
                j+=1
                
        print(mid)
        print(nums)        
nums=[1, 5, 1, 1, 6, 4]
nums=[1, 3, 2, 2, 3, 1]                
if __name__ == "__main__":
    print(Solution().wiggleSort( nums))                 
                
                
#508. Wiggle Sort
class Solution:
    """
    @param: nums: A list of integers
    @return: nothing
    """
    
    def wiggleSort(self, nums):
        # write your code here
        if not nums:
            return 
        def partition(A,start,end):
            import random
            pivot_index=random.randrange(start,end+1)
            pivot=A[pivot_index]
            
            A[pivot_index],A[end]=A[end],A[pivot_index]
            partition_index=start
            for i in range(start,end):
                if A[i]>=pivot:
                    A[partition_index], A[i] =A[i],A[partition_index]
                    partition_index+=1
            A[partition_index],A[end]=A[end],A[partition_index] 
            return partition_index
                
        def quickselct(A,start,end,k):
            if start==end:
                return A[start]
            cur_index=partition(A,start,end)
            
            if cur_index==k:
                return A[k]
            elif cur_index>k:
                return quickselct(A,start,cur_index-1,k)
            else:
                return quickselct(A,cur_index+1,end,k)
        
        n=len(nums)
        if n==1:
            return 
        f=lambda i: (1+2*i)%(n|1)
        
        mid=quickselct(nums,0,n-1,n//2)
        
        k=n-1
        i=0
        j=0
        
        while j<=k:
            if nums[f(j)]>mid:
                nums[f(j)],nums[f(i)]=nums[f(i)],nums[f(j)]
                j+=1
                i+=1
            elif nums[f(j)]<mid:
                nums[f(j)],nums[f(k)]=nums[f(k)],nums[f(j)]
                k-=1
            else:
                j+=1
                
            
#510. Maximal Rectangle
class Solution:
    """
    @param matrix: a boolean 2D matrix
    @return: an integer
    """
    def maximalRectangle(self, matrix):
        # write your code here
        m=len(matrix)
        if m==0:
            return 0
        n=len(matrix[0])
        if n==0:
            return 0
        heights=[0 for _ in range(n+1)]
        
        ans=0
        for row in matrix:
            for i in range(n):
                heights[i]=heights[i]+row[i] if row[i]==1 else 0
                
                stack=[-1]
            for j in range(n+1):
                while heights[j]< heights[stack[-1]]:
                    h=heights[stack.pop()]
                    w=j-stack[-1]-1
                    ans=max(ans,h*w)
                stack.append(j)
        return ans
matrix=[[1,1,0,0,1],[0,1,0,0,1],[0,0,1,1,1],[0,0,1,1,1],[0,0,0,0,1]]                    
if __name__ == "__main__":
    print(Solution().maximalRectangle( matrix))              
        
        
#511. Swap Two Nodes in Linked List
"""
Definition of ListNode
class ListNode(object):
    def __init__(self, val, next=None):
        self.val = val
        self.next = next
"""

class Solution:
    """
    @param head: a ListNode
    @param v1: An integer
    @param v2: An integer
    @return: a new head of singly-linked list
    """
    def swapNodes(self, head, v1, v2):
        # write your code here
       
        dummy=ListNode(0)
        dummy.next=head
        if not head:
            return None
        if v1==v2:
            return  head
        
        def findPrevs(v1, v2):
            prev1=None
            prev2=None
            cur=dummy
            while cur.next:
                if cur.next.val==v1:
                    prev1=cur
                if cur.next.val==v2:
                    prev2=cur
                cur=cur.next
            return prev1,prev2
        
        # dummy->head->..->prev->node1->node2->post...
        # swap node1 & node2
        def swapAdjcent( prev): 
            node1=prev.next
            node2=node1.next            
            post=node2.next
            
            prev.next=node2
            node2.next=node1
            node1.next=post
        
        
        # dummy->head->..->prev1->node1->post1->...->prev2->node2->post2...
        # swap node1 & node2
        def swapRemote( prev1, prev2):
            node1=prev1.next
            post1=node1.next
            
            node2=prev2.next
            post2=node2.next
            
            prev1.next=node2
            node2.next=post1
            
            prev2.next=node1
            node1.next=post2
        
        prev1,prev2=findPrevs(v1, v2)
        
        if not prev1  or not prev2:
            return head
        
        if prev1.next==prev2:
            swapAdjcent( prev1)
        elif  prev2.next==prev1:
            swapAdjcent( prev2)
        else:
            swapRemote(prev1, prev2)
        return dummy.next
    
    
    
    
    
            
class Solution:
    """
    @param s: a string,  encoded message
    @return: an integer, the number of ways decoding
    """
    def numDecodings(self, s):
        # write your code here
        

#'A' -> 1
#'B' -> 2
#...
#'Z' -> 26        
        n=len(s)
        if  n==0:
            return n  
        if n==1 and s=='0' :
            return 0
        if n==1:
            return n
        dp=[0 for _ in range(n+1)]
        dp[1]=1
        dp[0]=1
        
        for i in range(2,n+1):
            if s[i-1]=='0':
                if s[i-2] in ('3','4','5','6','7','8','9','0'):
                    return 0
                dp[i]=dp[i-2]
            else:
                if s[i-2] in ('0','3','4','5','6','7','8','9'):
                    dp[i]=dp[i-1]
                elif s[i-2]=='1':
                    dp[i]=dp[i-1]+dp[i-2]
                elif s[i-2]=='2':
                    if s[i-1] in ('1','2','3','4','5','6'):
                        dp[i]=dp[i-1]+dp[i-2]
                    elif s[i-1] in ('7','8','9'):
                        dp[i]=dp[i-1]
        return dp[-1]

s='122'
if __name__ == "__main__":
    print(Solution().numDecodings(s))                        
                
                
#513. Perfect Squares            
class Solution:
    """
    @param n: a positive integer
    @return: An integer
    """
    def numSquares(self, n):
        # write your code here
        
        if n==1:
            return 1
        if n==2:
            return 2
        
        dp =[ n for _ in range(n+1)]
        
        i=0
        while i*i<=n:
            dp[i*i]=1
            i+=1
        
        for i in range(1,n+1):
            j=0
            while i+j*j<=n:
                dp[i+j*j]=min(dp[i+j*j],dp[i]+1)
                j+=1
        return dp[n]
            
            
#514. Paint Fence                
class Solution:
    """
    @param n: non-negative integer, n posts
    @param k: non-negative integer, k colors
    @return: an integer, the total number of ways
    """
    def numWays(self, n, k):
        # write your code here
#        根据题意，不能有超过连续两根柱子是一个颜色，也就意味着第三根柱子要么根第一个柱子不是一
#        个颜色，要么跟第二根柱子不是一个颜色。如果不是同一个颜色，计算可能性的时候就要去掉之前的
#        颜色，也就是k-1种可能性。假设dp[1]是第一根柱子及之前涂色的可能性数量，dp[2]是第二根柱子及
#        之前涂色的可能性数量，则dp[3]=(k-1)*dp[1] + (k-1)*dp[2]。
#      post 1,   post 2, post 3
#way1    0         0       1 
#way2    0         1       0
#way3    0         1       1
#way4    1         0       0
#way5    1         0       1
#way6    1         1       0    
        dp=[0,k,k*k]
        
        if n<=2:
            return dp[n]
        if n>2 and k==1:
            return 0
        
        for i in range(3,n+1):
            dp.append((k-1)*(dp[-2]+dp[-1]))
        return dp[n]

n=3
k=2 #return 6
n=0
k=0
if __name__ == "__main__":
    print(Solution().numWays( n, k))                
            
#515. Paint House            
class Solution:
    """
    @param costs: n x 3 cost matrix
    @return: An integer, the minimum cost to paint all houses
    """
    def minCost(self, costs):
        # write your code here
      
        n=len(costs)
        if n==0:
            return 0
        if n==1:
            return min(costs[0]) 
        
        dp=[[0 for _ in range(3)]  for _ in range(n)]
        dp[n-1]=costs[n-1]
        
        for i in range(n-2,-1,-1):
            dp[i][0]=costs[i][0]+min(dp[i+1][1],dp[i+1][2])
            dp[i][1]=costs[i][1]+min(dp[i+1][0],dp[i+1][2])
            dp[i][2]=costs[i][2]+min(dp[i+1][0],dp[i+1][1])
        return min(dp[0])

        
        
costs=[[14,2,11],[11,14,5],[14,3,10]]
costs=[[3,5,3],[6,17,6],[7,13,18],[9,10,18]]
if __name__ == "__main__":
    print(Solution().minCost( costs))                
                               
#516. Paint House II
class Solution:
    """
    @param costs: n x k cost matrix
    @return: an integer, the minimum cost to paint all houses
    """
    def minCostII(self, costs):
        # write your code here
#        n=len(costs)
#        if n==0:
#            return 0
#        if n==1:
#            return min(costs[0]) 
#        
#        k=len(costs[0])
#        
#        dp=[[0 for _ in range(k)]  for _ in range(n)]
#        dp[n-1]=costs[n-1]
#        
#        for i in range(n-2,-1,-1):
#            for j in range(k):
#                dp[i][j]=costs[i][j]+min(dp[i+1][:j]+dp[i+1][j+1:])
#            
#            
#        return min(dp[0])
        n=len(costs)
        if n==0:
            return 0
        if n==1:
            return min(costs[0]) 
        
        K=len(costs[0])
        
        dp=[[0 for _ in range(K)]  for _ in range(n+1)]
       
        
        for i in range(1,n+1):
            a=-1
            b=-1
            
            for k in range(K):
                if a==-1 or dp[i-1][k]<dp[i-1][a]:
                    b=a
                    a=k
                else:
                    if b==-1 or dp[i-1][k]<dp[i-1][b]:
                        b=k
                        
                
            
            
            for j in range(K):
                if a!=j:
                    dp[i][j]=dp[i-1][a]+costs[i-1][j]
                else:
                    dp[i][j]=dp[i-1][b]+costs[i-1][j]
            
            
        return  min(dp[n])
            
costs=[[3,5,3],[6,17,6],[7,13,18],[9,10,18]]        
        
if __name__ == "__main__":
    print(Solution().minCostII( costs))                 
        
        
#517. Ugly Number        
class Solution:
    """
    @param num: An integer
    @return: true if num is an ugly number or false
    """
    def isUgly(self, num):
        # write your code here
        
        if num==1:
            return True
        while num!=1:
            start=num
            if num%2==0:
                num//=2
            if num%3==0:
                num//=3
            if num%5==0:
                num//=5
            end=num
            if start==end  and num!=1:
                return False
            if num==1:
                return True
num=8
num=14
if __name__ == "__main__":
    print(Solution().isUgly( num))                 
                    
            
#518. Super Ugly Number
class Solution:
    """
    @param n: a positive integer
    @param primes: the given prime list
    @return: the nth super ugly number
    """
    def nthSuperUglyNumber(self, n, primes):
        # write your code here
        m=len(primes)
        Pindex=[0 for _ in range(m)]
        import heapq
        ugly=[1]
        
        minlist=[(primes[i]*ugly[Pindex[i]],i) for i in range(m)]
        heapq.heapify(minlist)
        
        while len(ugly)<n:
            value, index=heapq.heappop(minlist)
            Pindex[index]+=1
            if ugly[-1]!=value:
                ugly.append(value)
            heapq.heappush(minlist, (primes[index] * ugly[Pindex[index]],index) )
        return ugly[-1]    
n=6
primes=[2,7,13,19]
n=1
primes=[17,2,3,5,7,97,31]            
if __name__ == "__main__":
    print(Solution().nthSuperUglyNumber( n, primes))

#523. Url Parser
class HtmlParser:
    """
    @param: content: content source code
    @return: a list of links
    """
    def parseUrls(self, content):
        # write your code here
        import re
        links=re.findall(r'\s*(?i)href\s*=\s*("|\')+([^"\'<\s]*)',content,re.I)
        return [link[1] for link in links if  link[1] and not link[1].startswith('#')]
        
content=
if __name__ == "__main__":
    print(Solution().parseUrls(content))                 
                    
#524. Left Pad
class StringUtils:
    """
    @param: originalStr: the string we want to append to
    @param: size: the target length of the string
    @param: padChar: the character to pad to the left side of the string
    @return: A string
    """
    @classmethod
    def leftPad(self, originalStr, size, padChar=' '):
        # write your code here
        n=len(originalStr)
        add=size-n
        if add<0:
            return originalStr
        return padChar*add+originalStr
originalStr="foo"
size= 5
if __name__ == "__main__":
    print(StringUtils().leftPad( originalStr, size, padChar=' '))                 


#526. Load Balancer
class LoadBalancer:
    def __init__(self):
        # do intialization if necessary
        self.stack=[]

    """
    @param: server_id: add a new server to the cluster
    @return: nothing
    """
    def add(self, server_id):
        # write your code here
        self.stack.append(server_id)

    """
    @param: server_id: server_id remove a bad server from the cluster
    @return: nothing
    """
    def remove(self, server_id):
        # write your code here
        if server_id  in self.stack:
            self.stack.remove(server_id)
        else:
            return 
        
        

    """
    @return: pick a server in the cluster randomly with equal probability
    """
    def pick(self):
        # write your code here
        from random import randint
        n=len(self.stack)
        if n==0:
            return 
        
        return self.stack[randint(0,n)]



#528. Flatten Nested List Iterator
"""
This is the interface that allows for creating nested lists.
You should not implement it, or speculate about its implementation

class NestedInteger(object):
    def isInteger(self):
        # @return {boolean} True if this NestedInteger holds a single integer,
        # rather than a nested list.

    def getInteger(self):
        # @return {int} the single integer that this NestedInteger holds,
        # if it holds a single integer
        # Return None if this NestedInteger holds a nested list

    def getList(self):
        # @return {NestedInteger[]} the nested list that this NestedInteger holds,
        # if it holds a nested list
        # Return None if this NestedInteger holds a single integer
"""

class NestedIterator(object):

    def __init__(self, nestedList):
        # Initialize your data structure here.
        
        self.stack=nestedList[::-1]
        
        
    # @return {int} the next element in the iteration
    def next(self):
        # Write your code here
        return self.stack.pop().getInteger()
        
            
            
        
    # @return {boolean} true if the iteration has more element or false
    def hasNext(self):
        # Write your code here
        
        while self.stack:
            top=self.stack[-1]
            if top.isInteger():
                return True
            self.stack=self.stack[:-1]+top.getList()[::-1]
        return False

# Your NestedIterator object will be instantiated and called as such:
# i, v = NestedIterator(nestedList), []
# while i.hasNext(): v.append(i.next())

#532. Reverse Pairs
class Solution:
    """
    @param A: an array
    @return: total of reverse pairs
    """
    def reversePairs(self, A):
        # write your code here
        n=len(A)
        self.tmp=[0 for _ in range(n)]
        
        def mergeSort(A,l,r):
            if l>=r:
                return 0
            mid=(l+r)>>1
            
            ans=mergeSort(A,l,mid)+mergeSort(A,mid+1,r)
            i=l
            j=mid+1
            k=l
            
            while i<=mid and j <=r:
                if A[i]>A[j]:
                    ans+=mid-i+1
                    self.tmp[k]=A[j]
                    j+=1
                else:
                    self.tmp[k]=A[i]
                    i+=1
                k+=1
            while i<=mid:
                self.tmp[k]=A[i]
                k+=1
                i+=1
            while j<=r:
                self.tmp[k]=A[j]
                k+=1
                j+=1
            for x in range(l,r+1):
                A[x]=self.tmp[x]
            return ans
        
                
        return mergeSort(A,0,n-1)
A=[2, 4, 1, 3, 5] 
if __name__ == "__main__":
    print(Solution().reversePairs( A))                 
                
                    
#534. House Robber II
class Solution:
    """
    @param nums: An array of non-negative integers.
    @return: The maximum amount of money you can rob tonight
    """
    def houseRobber2(self, nums):
        # write your code here
        
        m=len(nums)
        if m==0:
            return 0
        if m==1:
            return nums[0]
        if m==2:
            return max(nums[0],nums[1])
        
        def houseRobber(A):
            n=len(A)
            if n==0:
                return 0
            if n==1:
                return A[0]
            if n==2:
                return max(A)
            dp=[0 for _ in range(n)]
            dp[0]=A[0]
            dp[1]=max(A[0],A[1])
            for i in range(2,n):
                dp[i]=max(dp[i-1],dp[i-2]+A[i])
            return dp[-1]
        
        a=houseRobber(nums[0:-1])
        b=houseRobber(nums[1:])
        return max(a,b)
            

nums = [3,6,4]# return 6            
if __name__ == "__main__":
    print(Solution().houseRobber2( nums))             
            
            
#535. House Robber III
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""

class Solution:
    """
    @param root: The root of binary tree.
    @return: The maximum amount of money you can rob tonight
    """
    def houseRobber3(self, root):
        # write your code here
        
#        def houseRobber(node):
#            if not node:
#                return 0
#            if not node.left  and not node.right:
#                return node.val
#            if not node.left and node.right:
#                s1=houseRobber(node.right.left)+houseRobber(node.right.right)+node.val
#                s2=houseRobber(node.right)
#                return max(s1,s2)
#            if node.left and not node.right:
#                s1=houseRobber(node.left.left)+houseRobber(node.left.right)+node.val
#                s2=houseRobber(node.left)
#                return max(s1,s2)
#            if node.left and node.right:
#                s1=houseRobber(node.left.left)+houseRobber(node.left.right)+node.val+houseRobber(node.right.left)+houseRobber(node.right.right)
#                s2=houseRobber(node.left)+houseRobber(node.right)
#                return max(s1,s2)
#        return houseRobber(root)
        
        
        def visit(node):
            if not node:
                return 0,0
            
            left_rob,left_not_rob=visit(node.left)
            right_rob,right_not_rob=visit(node.right)
            
            rob=left_not_rob+right_not_rob+node.val
            not_rob=max(left_rob,left_not_rob)+max(right_rob,right_not_rob)
            return rob,not_rob
        
        yes,no=visit(root)
        return max(yes,no)
            
                

#  3
# / \
#2   3
# \   \ 
#  3   1
#
#3 + 3 + 1 = 7
#
#    3
#   / \
#  4   5
# / \   \ 
#1   3   1
#4 + 5 = 9
root=TreeNode(3)
root.left=TreeNode(2)
root.right=TreeNode(3)

root.left.right=TreeNode(3)
root.right.right=TreeNode(1)


root=TreeNode(3)
root.left=TreeNode(4)
root.right=TreeNode(5)

root.left.left=TreeNode(1)
root.left.right=TreeNode(3)
root.right.right=TreeNode(1)


if __name__ == "__main__":
    print(Solution().houseRobber3( root)) 

#539. Move Zeroes
class Solution:
    """
    @param nums: an integer array
    @return: nothing
    """
    def moveZeroes(self, nums):
        # write your code here
        n=len(nums)
        if n==0:
            return 
        if n==1:
            return 

        i0=0
        i1=0
        
        while i0<n  and i1<n:
            while i0<n  and nums[i0]!=0:
                i0+=1
            i1=i0     
            while i1<n  and nums[i1]==0:
                i1+=1
                
           
            #print(i0,i1)
            if i0<n  and i1<n:
               nums[i0]  , nums[i1] = nums[i1], nums[i0]
               
               
            #break
       
               
        print(nums)
                
nums=[0,1,0,3,12]
nums=[0,1,0,3,0]      
nums=[0,0,0,0,0] 
nums=[1,2,3]           
if __name__ == "__main__":
    print(Solution().moveZeroes( nums))             


#540. Zigzag Iterator        
class ZigzagIterator:
    """
    @param: v1: A 1d vector
    @param: v2: A 1d vector
    """
    def __init__(self, v1, v2):
        # do intialization if necessary
        self.v1=v1
        self.v2=v2
        self.pointer1=True
        self.p1=0
        self.p2=0
        self.n1=len(v1)
        self.n2=len(v2)
        

    """
    @return: An integer
    """
    def next(self):
        # write your code here
        #print(self.p1,self.p2,self.pointer1)
        if self.hasNext():
            
            if self.p1< self.n1  and self.p2<self.n2 :
                 if self.pointer1:
                    print('1')
                    val=self.v1[self.p1]
                    self.p1+=1
                    self.pointer1=False
                    return val
                 else:
                     print('2')
                     val=self.v2[self.p2]
                     self.pointer1=True
                     self.p2+=1
                     return val
            elif self.p1< self.n1  and self.p2==self.n2:
                     print('3')
                     val=self.v1[self.p1]
                     self.p1+=1
                     return val
            elif self.p1== self.n1  and self.p2<self.n2:
                     print('4')
                     val=self.v2[self.p2]
                     self.p2+=1
                     return val
                     
                   

    """
    @return: True if has next
    """
    def hasNext(self):
        # write your code here
        if self.p1< self.n1  or self.p2<self.n2 :
            return True
        if self.p1== self.n1  and self.p2==self.n2 :
            return False
        
        
        
        
        

v1 = [1, 2]
v2 = [3, 4, 5, 6]


# Your ZigzagIterator object will be instantiated and called as such:
# solution, result = ZigzagIterator(v1, v2), []
# while solution.hasNext(): result.append(solution.next())
# Output result   

#541. Zigzag Iterator II
class ZigzagIterator2:
    """
    @param: vecs: a list of 1d vectors
    """
    def __init__(self, vecs):
        # do intialization if necessary
        self.queue=[v for v in vecs if v]
 
    """
    @return: An integer
    """
    def next(self):
        # write your code here
        if self.hasNext():
            row=self.queue.pop(0)
            v=row.pop(0)
            if row:
                self.queue.append(row)
            return v
    """
    @return: True if has next
    """
    def hasNext(self):
        # write your code here
       
        return len(self.queue)>0


vecs=[[1,2,3],[4,5,6,7],[8,9]]


     
        
#544. Top k Largest Numbers 
class Solution:
    """
    @param nums: an integer array
    @param k: An integer
    @return: the top k largest numbers in array
    """
    def topk(self, nums, k):
        # write your code here
        import heapq
        hp=[]
        res=[]
        if not nums:
            return []
        
        n=len(nums)
        
        if k>=n:
            return sorted(nums,reverse=True)
        for x in nums:
            heapq.heappush(hp,-x)
        
        for _ in range(k):
            res.append(0-heapq.heappop(hp))
        return res
 
nums=[3,10,1000,-99,4,100]
k = 6
#Return [1000, 100, 10].        
if __name__ == "__main__":
    print(Solution().topk( nums, k))         
        
#545. Top k Largest Numbers II
class Solution:
    """
    @param: k: An integer
    """
    def __init__(self, k):
        # do intialization if necessary
        self.stack=[]
        self.k=k

    """
    @param: num: Number to be added
    @return: nothing
    """
    def add(self, num):
        # write your code here
        self.stack.append(num)

    """
    @return: Top k element
    """
    def topk(self):
        # write your code here
        import heapq
        hp=[]
        res=[]
        if not self.stack:
            return []
        
        n=len(self.stack)
        
        if self.k>=n:
            return sorted(self.stack,reverse=True)
        for x in self.stack:
            heapq.heappush(hp,-x)
        
        for _ in range(self.k):
            res.append(0-heapq.heappop(hp))
        return res
        
        
#547. Intersection of Two Arrays
class Solution:
    
    """
    @param: nums1: an integer array
    @param: nums2: an integer array
    @return: an integer array
    """
    def intersection(self, nums1, nums2):
        # write your code here   
        
        nums1=set(nums1)
        nums2=set(nums2)
        return list(nums1.intersection(nums2))
nums1 = [1, 2, 2, 1]
nums2 = [2, 2]        
if __name__ == "__main__":
    print(Solution().intersection( nums1, nums2))          
        
#548. Intersection of Two Arrays II
class Solution:
    
    """
    @param: nums1: an integer array
    @param: nums2: an integer array
    @return: an integer array
    """
    def intersection(self, nums1, nums2):
        # write your code here
        from collections import Counter
        counts=Counter(nums1)
        res=[]
        for n2 in nums2:
          if counts[n2]>0:
             res.append(n2)
             counts[n2]-=1
        return res
             
#550. Top K Frequent Words II    
class Entry():
    def __init__(self,word,freq):
        # do intialization if necessary
        self.word=word
        self.freq=freq
        self.inTop=False
    def __lt__(self,other):
        if self.freq==other.freq:
            return self.word>other.word
        return self.freq<other.freq

from bisect import bisect_left
                
class TopK:
    """
    @param: k: An integer
    """
    def __init__(self, k):
        # do intialization if necessary
        self.k=k
        self.top_k=[]
        self.mapping={}
        
    """
    @param: word: A string
    @return: nothing
    """
    def add(self, word):
        # write your code here
        if self.k==0:
            return 
        entry=None
        
        if word in self.mapping:
            entry=self.mapping[word]
            if entry.inTop:
                self.removeFromTop(entry)
            entry.freq+=1
        else:
            self.mapping[word]=Entry(word,1)
            entry=self.mapping[word]
        self.addToTop(entry)
        
        if len(self.top_k)>self.k:
            self.top_k[0].inTop=False
            self.top_k.pop(0)
            
    """
    @return: the current top k frequent words.
    """
    def topk(self):
        # write your code here
        if self.k==0:
            return []
        res=[e.word for e in self.top_k]
        res.reverse()
        return res
        
        
        
        
    
    def addToTop(self, entry):
        idx=bisect_left(self.top_k,entry)
        self.top_k.insert(idx,entry)
        entry.inTop=True
    
    def removeFromTop(self, entry):
        idx=bisect_left(self.top_k,entry)
        self.top_k.pop(idx)
        entry.inTop=False
        
        

#551. Nested List Weight Sum            
"""
This is the interface that allows for creating nested lists.
You should not implement it, or speculate about its implementation

class NestedInteger(object):
    def isInteger(self):
        # @return {boolean} True if this NestedInteger holds a single integer,
        # rather than a nested list.

    def getInteger(self):
        # @return {int} the single integer that this NestedInteger holds,
        # if it holds a single integer
        # Return None if this NestedInteger holds a nested list

    def getList(self):
        # @return {NestedInteger[]} the nested list that this NestedInteger holds,
        # if it holds a nested list
        # Return None if this NestedInteger holds a single integer
"""


class Solution(object):
    # @param {NestedInteger[]} nestedList a list of NestedInteger Object
    # @return {int} an integer
    def depthSum(self, nestedList):
        # Write your code here
        
        def decompse(nestedList,res,step):
            n=len(nestedList)
            if n==0:
                return 
            for i in range(n):
                if nestedList[i].isInteger():
                    res.append((nestedList[i].getInteger(),step))
                else:
                    decompse(nestedList[i].getList(),res,step+1)
        res=[]
        decompse(nestedList,res,1)
        
        return sum([num*step for num , step in res])
                    
                

#552. Create Maximum Number
class Solution:
    """
    @param nums1: an integer array of length m with digits 0-9
    @param nums2: an integer array of length n with digits 0-9
    @param k: an integer and k <= m + n
    @return: an integer array
    """
    def maxNumber(self, nums1, nums2, k):
        # write your code here
#https://leetcode.com/problems/create-maximum-number/discuss/77291/Share-my-Python-solution-with-explanation        
#To create the max number from num1 and nums2 with k elements, 
#we assume the final result combined by i numbers (denotes as left) from num1 and 
#j numbers (denotes as right) from nums2, where i+j==k.
#
#Obviously, left and right must be the maximum possible number in num1 and
# num2 respectively. i.e. num1 = [6,5,7,1] and i == 2, then left must be [7,1].
#
#The final result is the maximum possible merge of all left and right.
#
#So there're 3 steps:
#
#iterate i from 0 to k.
#find max number from num1, num2 by select i , k-i numbers, denotes as left, right
#find max merge of left, right
#function maxSingleNumber select i elements from num1 that is maximum. The idea find 
#the max number one by one. i.e. assume nums [6,5,7,1,4,2], selects = 3.
#1st digit: find max digit in [6,5,7,1], the last two digits [4, 2] can not be 
#selected at this moment.
#2nd digits: find max digit in [1,4], since we have already selects 7, we should 
#consider elements after it, also, we should leave one element out.
#3rd digits: only one left [2], we select it. and function output [7,4,2]
#
#function mergeMax find the maximum combination of left, and right.        
#        
        def getmax(nums,nselect):
            #res=[-1]
            n=len(nums)
            if nselect>=n:
                return nums
            
            ans=[]
            for i in range(n):
                while ans and len(ans)+(n-i)>nselect and ans[-1]<nums[i]:
                    ans.pop()
                if len(ans)<nselect:
                    ans.append(nums[i])
            return ans
                
        def mergemax(n1,n2):
            res=[]
            while n1 or n2:
                if n1>n2:
                    res.append(n1[0])
                    n1=n1[1:]
                    
                else:
                    res.append(n2[0])
                    n2=n2[1:]
            return res
        
        l1=len(nums1)
        l2=len(nums2)
        ret=[0 for _ in range(k)]
        for i in range(k+1):
            j=k-i
            if i>l1 or j>l2:
                continue
            left=getmax(nums1,i)
            right=getmax(nums2,j)
            tempret=mergemax(left,right)
            ret=max(ret,tempret)
        return ret
            
        
        
        
nums1 = [3, 4, 6, 5]
nums2 = [9, 1, 2, 5, 8, 3]
k = 5
#[9, 8, 6, 5, 3]

nums1 = [6, 7]
nums2 = [6, 0, 4]
k = 5
#[6, 7, 6, 0, 4]

nums1 = [3, 9]
nums2 = [8, 9]
k = 3
#[9, 8, 9]

if __name__ == "__main__":
    print(Solution().maxNumber( nums1, nums2, k))   


#553. Bomb Enemy
class Solution:
    """
    @param grid: Given a 2D grid, each cell is either 'W', 'E' or '0'
    @return: an integer, the maximum enemies you can kill using one bomb
    """
    def maxKilledEnemies(self, grid):
        # write your code here

        m=len(grid)
        if m==0:
            return 0
        n=len(grid[0])
        
        row=0
        res=0
        col=[0 for _ in range(n)]
        
        for i in range(m):
            for j in range(n):
                if j ==0 or grid[i][j-1]=='W':
                   row=0
                   for c in range(j,n):
                       if grid[i][c]=='W':
                           break
                       if grid[i][c]=='E':
                           row+=1
                if i==0 or grid[i-1][j]=='W':
                    col[j]=0
                    for r in range(i,m):
                        if grid[r][j]=='W':
                           break
                        if grid[r][j]=='E':
                           col[j]+=1
                if grid[i][j]=='0'  and row+col[j]>res:
                    res=row+col[j]
        return res
grid=["0E00","E0WE","0E00"]                        
if __name__ == "__main__":
    print(Solution().maxKilledEnemies(grid))                 
                       
                       
#555. Counting Bloom Filter
from collections import defaultdict
class CountingBloomFilter:
    """
    @param: k: An integer
    """
    def __init__(self, k):
        # do intialization if necessary
        self.capacity=k
        
        self.table=defaultdict(int)
        

    """
    @param: word: A string
    @return: nothing
    """
    def add(self, word):
        # write your code here
        
        self.table[word]+=1
            

    """
    @param: word: A string
    @return: nothing
    """
    def remove(self, word):
        # write your code here
        if self.table[word] >0:
          self.table[word]-=1
          

    """
    @param: word: A string
    @return: True if contains word
    """
    def contains(self, word):
        # write your code here
        if self.table[word]==0:
            return False
        if word not in self.table:
            return False
        
        if self.table[word]>0:
            return True
        
#556. Standard Bloom Filter
class StandardBloomFilter:
    """
    @param: k: An integer
    """
    def __init__(self, k):
        # do intialization if necessary

    """
    @param: word: A string
    @return: nothing
    """
    def add(self, word):
        # write your code here

    """
    @param: word: A string
    @return: True if contains word
    """
    def contains(self, word):
        # write your code here



#557. Count Characters
class Solution:
    """
    @param: : a string
    @return: Return a hash map
    """

    def countCharacters(self, str):
        # write your code here
        from collections import defaultdict
        table=defaultdict(int)
        
        for s in str:
            table[s]+=1
        return table

#564. Combination Sum IV
class Solution:
    """
    @param nums: an integer array and all positive numbers, no duplicates
    @param target: An integer
    @return: An integer
    """
    def backPackVI(self, nums, target):
        # write your code here
        
#        def dfs(target,nums,path,res):
#            if target==0:
#                res.append(path[:])
#            if target<0:
#                return 
#            for x in nums:
#                dfs(target-x,nums,path+[x],res)
#        res=[]
#        dfs(target,nums,[],res)
#        return len(res)
        
        
        n=len(nums)
        if n==0:
            return 0
                
        dp=[0 for _ in range(target+1)]
        dp[0]=1
        
        for i in range(1,target+1):
            for j in range(0,n):
                if i-nums[j]>=0:
                    dp[i]+=dp[i-nums[j]]
        return dp[target]
nums=[1,2,4]
target=4
nums=[1,2,4]
target=32
if __name__ == "__main__":
    print(Solution().backPackVI(nums, target))                 
                       
#569. Add Digit
class Solution:
    """
    @param num: a non-negative integer
    @return: one digit
    """
    def addDigits(self, num):
        # write your code here
#数学推导规律，O(1)时间复杂度。
#
#num = a0 + a1 * 10 + a2 * 100 + ... + ak * 10^k
#= (a0 + a1 + ... + ak) + 9(a1 + a2 + ... + ak) + 99(a2 + ... + ak) + ... + (10^k - 1)ak
#
#其中a0 + a1 + ... + ak是下一步计算要得到的结果，记为num1，重复上述过程：
#
#num = num1 + 9 * x1, 其中 x = (a1 + a2 + ... + ak) + 11 * (a2 + ... + ak) + ...
#num1 = num2 + 9 * x2
#...
#
#直到numl < 10 为止。
#
#则可知 num = numl + 9 * x
#numl = num % 9
        if num==0:
           return 0
        return num%9 if num%9 else 9

#570. Find the Missing Number II
class Solution:
    """
    @param n: An integer
    @param str: a string with number from 1-n in random order and miss one number
    @return: An integer
    """
    def findMissing2(self, n, string):
        # write your code here
        if not string :
            return -1
        
        self.numbers=set()
        
        def dfs(n,string,start,path):
            if len(path)==n-1:
                self.numbers=set(path)
                return 
            
            for i in range(start,len(string)):
                substring=string[start:i+1]
                if len(substring)>2:
                    break
                if substring in path or int(substring)>n or int(substring)<1:
                    continue
                dfs(n,string,i+1,path | set([substring]))
        dfs(n,string,0,set())
        for j in range(1,n+1):
            if str(j) not in self.numbers:
                return j
n = 20
string = '19201234567891011121314151618'            
if __name__ == "__main__":
    print(Solution().findMissing2( n, string))                        
                
            
#573. Build Post Office II
class Solution:
    """
    @param grid: a 2D grid
    @return: An integer
    """
    def shortestDistance(self, grid):
        # write your code here
#        m=len(grid)
#        if m==0:
#            return -1
#        n=len(grid[0])
#        
#        house=set()
#        
#        for i in range(m):
#            for j in range(n):
#                if grid[i][j]==1:
#                    house.add((i,j))
#        
#        from collections import deque
#        
#        def bfs(a,b,house,grid,m,n) :
#            dq=deque([(a,b,0)])
#            temphouse=set()
#            res=0
#        
#            visited=set( ( a,b))
#        
#        
#            while dq:
#               h,k,step=dq.popleft()
#               if grid[h][k]==1  and (h,k) not in temphouse:
#                  temphouse.add((h,k))
#                  res+=step
#                  if len(temphouse)==len(house):
#                     return res
#               if grid[h][k]==0:
#               #for x,y in   ((h+1,k),(h-1,k),(h,k+1),(h,k-1)):
#                  for x,y in   ((h+1,k),(h-1,k),(h,k+1),(h,k-1)):
#                     if x>=0 and x<m  and y>=0 and y<n and (x,y) not in visited and grid[x][y]!=2:
#                        dq.append((x,y,step+1))
#                        visited.add((x,y))
#            return float('inf') 
#        ans=float('inf')
#        for a  in range(m):
#            for b in range(n):
#                if grid[a][b]!=1 and grid[a][b]!=2:
#                   #print(a,b)
#                   tempans=bfs(a,b,house,grid,m,n)
#                   #print(a,b,tempans)
#                   ans=min(ans,tempans)
#        return ans if ans !=float('inf') else -1
        def bfs(i,j,grid):
            queue=[(i,j)]
            _queue=[]
            distance=0
            visited=[[False for _ in range(self.n)] for _ in range(self.m)]
            
            while queue:
                  distance+=1
                  _queue=[]
                  for a, b in queue:
                      for x, y in ((a+1,b),(a-1,b),(a,b+1),(a,b-1)):
                          if  x>=0 and x<self.m  and y>=0 and y<self.n and not visited[x][y] and grid[x][y]==0:
                              visited[x][y]=True
                              self.visitTimes[x][y]+=1
                              self.distance[x][y]+=distance
                              _queue.append((x,y))
                  queue=_queue            
        
        self.m=len(grid)
        self.n=len(grid[0])
        self.visitTimes=[[0 for _ in range(self.n)] for _ in range(self.m)]
        self.distance=[[0 for _ in range(self.n)] for _ in range(self.m)]
        house=0
        for i in range(self.m):
            for j in range(self.n):
                if grid[i][j]==1:
                    house+=1
                    bfs(i,j,grid)
                    
        
        ans=float('inf')
#        print(grid)
#        print(self.visitTimes)
#        print(self.distance)
        
        for i in range(self.m):
            for j in range(self.n):
                if grid[i][j]==0 and self.visitTimes[i][j]==house and self.distance[i][j]<ans:
                    ans=self.distance[i][j]
#        print(ans)
        return ans if ans < float('inf') else -1
        
        
            
  
grid=[[0,1,0,0,0],
      [1,0,0,2,1],
      [0,1,0,0,0]]
grid=[[0,1,0,0],
      [1,0,2,1],
      [0,1,0,0]]

if __name__ == "__main__":
    print(Solution().shortestDistance( grid))                        
                            
        
#575. Decode String 
class Solution:
    """
    @param s: an expression includes numbers, letters and brackets
    @return: a string
    """
    def expressionExpand(self, s):
        # write your code here
        if not s:
            return ''
        
        stack=[]
        
        for x in s:
            if x!=']':
               stack.append(x)
            else:
                temp=''
                while stack[-1]!='[':
                    temp=stack.pop()+temp
                if stack[-1]=='[':
                    stack.pop()
                    num=''
                    while stack and stack[-1].isdigit():
                        num=stack.pop()+num
                    stack.append(temp*int(num))
        #print(stack)
        return ''.join(stack)
s = 'abc3[a]' #return abcaaa
s = '3[abc]' #return abcabcabc
s = '4[ac]dy' # return acacacacdy
s = '3[2[ad]3[pf]]xyz' # return adadpfpfpfadadpfpfpfadadpfpfpfxyz  
s ='5[10[abcd]Ac20[abcde]]'
if __name__ == "__main__":
    print(Solution().expressionExpand(s))               



#577. Merge K Sorted Interval Lists
"""
Definition of Interval.
class Interval(object):
    def __init__(self, start, end):
        self.start = start
        self.end = end
"""

class Solution:
    """
    @param intervals: the given k sorted interval lists
    @return:  the new sorted interval list
    """
    def mergeKSortedIntervalLists(self, intervals):
        # write your code here
        
        import heapq
        heap=[]
                
        for i,row in enumerate(intervals):
            if len(row)>0:
                heapq.heappush(heap,(row[0].start,row[0].end,i,0))
        
        start,end,x,y=heapq.heappop(heap)
        
        if y+1<len(intervals[x]):
            heapq.heappush(heap,(intervals[x][y+1].start,intervals[x][y+1].end,x,y+1))
        res=[]    
        while heap:
            new_start,new_end,new_x,new_y=heapq.heappop(heap)
            if new_start<=end:
                end=max(end,new_end)
            else:
                res.append(Interval(start,end))
                start=new_start
                end=new_end
            x=new_x
            y=new_y
            if y+1<len(intervals[x]):
                heapq.heappush(heap,(intervals[x][y+1].start,intervals[x][y+1].end,x,y+1))
        res.append(Interval(start,end))
        return res

#578. Lowest Common Ancestor III
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        this.val = val
        this.left, this.right = None, None
"""


class Solution:
    """
    @param: root: The root of the binary tree.
    @param: A: A TreeNode
    @param: B: A TreeNode
    @return: Return the LCA of the two nodes.
    """
    def lowestCommonAncestor3(self, root, A, B):
        # write your code here
        
        
        def search(node,A,B):
            if not node:
               return False,False,None
        
            
            left=search(node.left,A,B)
            right=search(node.right,A,B)
            findA=left[0]  or right[0] or node==A
            findB=left[1]  or right[1] or node==B
            
            if node==A or node==B:
                return findA,findB,node
        
            if left[2] and right[2]:
                return findA,findB,node
               
        
            if left[2]:
               return findA,findB,left[2]
            if right[2]:
               return findA,findB,right[2]
            
            return findA,findB,None
        
       
          findA,findB,LCA=search(root,A,B)
          if findA and  findB:
              return LCA
          else:
              return None
            
#582. Word Break II        
class Solution:
    """
    @param: s: A string
    @param: wordDict: A set of words.
    @return: All possible sentences.
    """
    def wordBreak(self, s, wordDict):
        # write your code here
        
        def dfs(s,wordDict,memo):
            if s in memo:
                return memo[s]
            if not s:
                return []
            
            res=[]
               
            for x in wordDict:
                if not s.startswith(x):
                    continue
                
                if len(s)==len(x):
                    res.append(x)
                else:
                    rest=dfs(s[len(x):],wordDict,memo)
                    
                    for item in rest:
                        res.append(x+' '+item)
                    
            memo[s]=res
            return res
        wordDict=[ w for w in wordDict if w]
        return dfs(s,wordDict,{})
s = 'lintcode'
wordDict= ["de", "ding", "co", "code", "lint"]

s = "a"
wordDict=["","t","t"]
wordDict=['']

s ="aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
wordDict=["a","aa","aaa","aaaa","aaaaa","aaaaaa","aaaaaaa","aaaaaaaa","aaaaaaaaa","aaaaaaaaaa"]
#["lint code", "lint co de"].
if __name__ == "__main__":
    print(Solution().wordBreak( s, wordDict))


#584. Drop Eggs II
class Solution:
    """
    @param m: the number of eggs
    @param n: the number of floors
    @return: the number of drops in the worst case
    """
    def dropEggs2(self, m, n):
        # write your code here
#        dp[i][j]表示有j层、i个鸡蛋时，至少需要尝试多少次。
#现在假设第i个鸡蛋从第k层落下，分两种情况，如果鸡蛋碎了，那么问题变成有k-1层、i-1个鸡蛋，
#也就是dp[i-1][k-1]
#如果鸡蛋没碎，那么问题变成有j-k层、仍是i个鸡蛋，也就是dp[i][j-k]
#因为我们不知道鸡蛋是否碎，所以要取两者的较大值
        egg=m
        floor=n
        
        dp=[[0 for _ in range(floor+1)]  for _ in range(egg+1)]
        
        
        for i in range(1,egg+1):
            dp[i][1]=1
        for j in range(1,floor+1):
            dp[1][j]=j
            
            
            
        for x in range(2,egg+1):
            for y in range(2,floor+1):
                
                dp[x][y]=float('inf')
                
                for k in range(1,y+1):
                    dp[x][y]=min(dp[x][y],  1+max(dp[x-1][k-1],dp[x][y-k]   )     )
        return dp[m][n]
m = 2
n = 100 #return 14
m = 2
n = 36 #return 8                    
if __name__ == "__main__":
    print(Solution().dropEggs2( m, n))                
                
#585. Maximum Number in Mountain Sequence                
class Solution:
    """
    @param nums: a mountain sequence which increase firstly and then decrease
    @return: then mountain top
    """
    def mountainSequence(self, nums):
        # write your code here
        if not nums:
            return 0
        top=num[0]
        for num in nums[1:]:
            if num<top:
                return top
            else:
                top=num
            
                
#587. Two Sum - Unique pairs
class Solution:
    """
    @param nums: an array of integer
    @param target: An integer
    @return: An integer
    """
    def twoSum6(self, nums, target):
        # write your code here
                
                

        nums.sort()
        self.res=0
        def twoSum(nums,target):
              
            for i in range(len(nums)-1):
                if i!= 0 and nums[i]==nums[i-1]:
                   continue
                if target-nums[i] in nums[i+1:]:
                    self.res+=1
        twoSum(nums,target)
        return self.res 
nums = [1,1,2,45,46,46]
target = 
#return 2
#1 + 46 = 47
#2 + 45 = 47                            
if __name__ == "__main__":
    print(Solution().twoSum6(nums, target))                
                                
#588. Partition Equal Subset Sum
class Solution:
    """
    @param nums: a non-empty array only positive integers
    @return: true if can partition or false
    """
    def canPartition(self, nums):
        # write your code here

        n=len(nums)
        nsum=sum(nums)
        if nsum%2:
           return False
        if n==0 or n==1:
           return False
        target=nsum//2
        
        dp=[False for _ in range(20000)]
        
        dp[0]=True
        
        for i in range(n):
            for j in range(target, nums[i]-1,-1  ):
               
                    dp[j]|= dp[j-nums[i]]
        return dp[target]
                
       
#        def dfs(target,nums):
#           if target<0:
#               return 
#           if target==0:
#               return True
#           
#           for i in range(len(nums)):
#               if dfs(target-nums[i],nums[i+1:]):
#                   return True
#           return False    
#        return dfs(target,nums)
nums = [1, 5, 11, 5]# return true
[#1, 5, 5], [11]

nums = [1, 2, 3, 9]# return false
nums = [1,4,5,6,1,2,4,1,3,4,1,2,4,5,1,91,4,5,6,1,2,4,1,3,4,1,2,4,5,1]
nums = [ 2]
if __name__ == "__main__":
    print(Solution().canPartition( nums))           
           
       



#591. Connecting Graph III
    
    
    
    
    
    
    
    
    
    





#594. strStr II
class Solution:
    """
    @param: source: A source string
    @param: target: A target string
    @return: An integer as index
    """
    def strStr2(self, source, target):
        # write your code here
        if source is None or target is None:
            return -1
        m=len(target)
        if m==0:
            return 0
        
        import random
        mod=99999999
        target_value=0
        m26=1
        
        for i in range(m):
            target_value=(target_value*26+ord(target[i])-ord('a'))%mod
            if target_value<0:
                target_value+=mod
        for _ in range(m-1):
            m26=26*m26%mod
          
        value=0
        for i in range(len(source)):
            if i>=m:
                value= value-(ord(source[i-m])-ord('a'))*m26%mod
            value=(value*26+ord(source[i])-ord('a'))%mod
            if value<0:
                value+=mod
            if i>=m-1 and value==target_value:
                return i-m+1
        return -1
source='qwerty'
target='ert'
source="abcdef"
target="bcd"
if __name__ == "__main__":
    print(Solution().strStr2(source, target))                      
                
                

#595. Binary Tree Longest Consecutive Sequence                
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""

class Solution:
    """
    @param root: the root of binary tree
    @return: the length of the longest consecutive sequence path
    """
    def longestConsecutive(self, root):
        # write your code here
        
        if not root:
            return 0
        if not root.right and not root.left:
            return 1
        def walkdown(node,res,path):
            if not node.left  and not node.right:
                res.append(path)
                return 
                
            if node.left:
                if node.left.val==node.val+1:
                    walkdown(node.left,res,path+1)
                else:
                    res.append(path)
                    walkdown(node.left,res,1)
            if node.right:
                if node.right.val==node.val+1:
                    walkdown(node.right,res,path+1)
                else:
                    res.append(path)
                    walkdown(node.right,res,1)
        res=[]
        walkdown(root,res,1)
        return max(res)
#    1
#    \
#     3
#    / \
#   2   4
#        \
#         5            
                
root=TreeNode(1) 

root.right= TreeNode(3) 
 
root.right.left= TreeNode(2)
root.right.right= TreeNode(4)  
root.right.right.right= TreeNode(5)    
            
if __name__ == "__main__":
    print(Solution().longestConsecutive( root)) 


#599. Insert into a Cyclic Sorted List
"""
Definition of ListNode
class ListNode(object):

    def __init__(self, val, next=None):
        self.val = val
        self.next = next
"""


class Solution:
    """
    @param: node: a list node in the list
    @param: x: An integer
    @return: the inserted new list node
    """
    def insert(self, node, x):
        # write your code here
        
        if node is None:
            #print('**')
            node=ListNode(x)
            node.next=node
            
            return node
        #print('****')
        if node.next==node:
            new_node=ListNode(x)
            new_node.next=node
            node.next=new_node
            return new_node
            
        
        
        cur=node
        
        while cur.next.val>=cur.val:
            cur=cur.next
            if cur==node:
                break
        
        maxv=cur.val
        minv=cur.next.val
        
        if x>maxv or x<minv:
            new_node=ListNode(x)
            new_node.next=cur.next
            cur.next=new_node
        else:
            cur=cur.next
            while cur.next.val<x:
                cur=cur.next
            new_node=ListNode(x)
            new_node.next=cur.next
            cur.next=new_node
        return new_node
            

        
#Given a list, and insert a value 4:
#3->5->1
#Return 5->1->3->4
        
node=None
x=4
if __name__ == "__main__":
    print(Solution().insert(node, x)) 


#600. Smallest Rectangle Enclosing Black Pixels
class Solution:
    """
    @param image: a binary matrix with '0' and '1'
    @param x: the location of one of the black pixels
    @param y: the location of one of the black pixels
    @return: an integer
    """
    def minArea(self, image, x, y):
        # write your code here
#        self.pixels=set()
#        m=len(image)
#        n=len(image[0])
#        def dfs(image,x,y,visited):
#            if image[x][y]=='1':
#                #self.pixels.add((x,y))
#                if x < self.mina:
#                   self.mina=x
#                if x>self.maxa:
#                   self.maxa=x
#                if y < self.minb:
#                   self.minb=y
#                if y>self.maxb:
#                   self.maxb=y
#                
#            for i , j in ((x+1,y),(x-1,y),(x,y+1),(x,y-1)):
#                if i>=0 and j>=0 and i<m and j <n and (i,j) not in visited:
#                    visited.add((i,j))
#                    dfs(image,i,j,visited)
#        visited=set()
#        
#        self.mina=float('inf')
#        self.minb=float('inf')
#        self.maxa=float('-inf')
#        self.maxb=float('-inf')
#        dfs(image,x,y,visited)
#       
#        return (self.maxa-self.mina+1)*(self.maxb-self.minb+1) 
        
        m=len(image)
        if m==0:
           return 0
        n=len(image[0])
        if n==0:
            return 0
        
       
        
        def checkcol(image,col):
            for i in range(m):
                if image[i][col]=='1':
                    return True
            return False
        def checkrow(image,row):
            for i in range(n):
                if image[row][i]=='1':
                    return True
            return False
        
        #right
        start=y
        end=n-1
        
        while start<end:
            mid=(start+end)//2+1
            if checkcol(image,mid):
                start=mid
            else:
                end=mid-1
        right=start
        #left
        start=0
        end=y
        while start<end:
            mid=(start+end)//2
            if checkcol(image,mid):
                end=mid
            else:
                start=mid+1
            
        left=start
        #down
        start=x
        end=m-1
        while start<end:
            
            mid=(start+end)//2+1
            if checkrow(image,mid):
                start=mid
            else:
                end=mid-1
        down=start
        
        #up
        
        start=0
        end=x
        
        while start<end:
            mid=(start+end)//2
            if checkrow(image,mid):
                end=mid
            else:
                start=mid+1
        
        up=start
        
        return (right-left+1)*(down-up+1)
image=[
  "0010",
  "0110",
  "0100"
]
x = 0
y = 2
#Return 6
if __name__ == "__main__":
    print(Solution().minArea( image, x, y))                
                
                
#601. Flatten 2D Vector                
class Vector2D(object):

    # @param vec2d {List[List[int]]}
    def __init__(self, vec2d):
        # Initialize your data structure here
        self.stack=[]
        self.pointer=0
        for row in vec2d:
                for item in row:
                    self.stack.append(item)
      
            
                    
        
   
    # @return {int} a next element
    def next(self):
        # Write your code here
        if self.hasNext:
            self.pointer+=1
            return self.stack[self.pointer-1]
        

    # @return {boolean} true if it has next element
    # or false
    def hasNext(self):
        # Write your code here
        return not self.pointer==len(self.stack)
        
        
vec2d=[
  [1,2],
  [3],
  [4,5,6]
]
# Your Vector2D object will be instantiated and called as such:
# i, v = Vector2D(vec2d), []
# while i.hasNext(): v.append(i.next())                
                
#602. Russian Doll Envelopes
class Solution:
    """
    @param: envelopes: a number of envelopes with widths and heights
    @return: the maximum number of envelopes
    """
    def maxEnvelopes(self, envelopes):
        # write your code here
        m=len(envelopes)
        if m==0:
            return 0
        n=len(envelopes[0])
        if n==0:
            return 0
        envelopes.sort(key=lambda x:(x[0],-x[1]))

        #就是找最长increasing substring
        h=[]
        from bisect import bisect_left
        
        for e in envelopes:
            j =bisect_left(h,e[1])
            
            if j < len(h):
                h[j]=e[1] #使高度尽量变小，虽然打乱了width的次序，但总长度不变
            else:
                h.append(e[1])
        return len(h)
        
        
        
        
  
envelopes = [[5,4],[6,4],[6,7],[2,3]]
envelopes =[[5,6],[6,4],[6,7],[2,9]]


# 3 ([2,3] => [5,4] => [6,7]).                
if __name__ == "__main__":
    print(Solution().maxEnvelopes( envelopes))                
        
#603. Largest Divisible Subset
class Solution:
    """
    @param: nums: a set of distinct positive integers
    @return: the largest subset 
    """
    def largestDivisibleSubset(self, nums):
        # write your code here
        n=len(nums)
        if n==0 or n==1:
            return []
        
        count=[0 for _ in range(n)]
        
        prev_index=[-1 for _ in range(n)]
        
        res=[]
        nums.sort()
        for i in range(1,n):
            for j in range(i):
                if nums[i]%nums[j]==0:
                    count[i]=count[j]+1
                    prev_index[i]=j
        index= count.index(max(count))
        
        res=[]
        while index!=-1:
            res.append(nums[index])
            index=prev_index[index]
        return res
nums = [1,2,3]
nums = [1,2,4,8]
if __name__ == "__main__":
    print(Solution().largestDivisibleSubset( nums))                  
            
            
                    
                    
#605. Sequence Reconstruction            
class Solution:
    """
    @param org: a permutation of the integers from 1 to n
    @param seqs: a list of sequences
    @return: true if it can be reconstructed only one or false
    """
    def sequenceReconstruction(self, org, seqs):
        # write your code here

#拓扑排序的路数
#
#构建两个字典，一个用来存放入度，一个用来存放邻居，用org里的元素初始化字典
#要防止seqs里面给出不合法的节点，如果发现直接返回False
#确保seqs里的节点个数和orgs相等
        
        degrees={}
        nodes=set()
        edges={}
        
        for x in org:
            edges[x]=[]
            degrees[x]=0
        
        
        for s in seqs:
            nodes|=set(s)
            for i in range(len(s)-1):
                edges[s[i]].append(s[i+1])
                if s[i+1] in degrees:
                   degrees[s[i+1]]+=1
                else:
                    return False
        
        from collections import deque
        q=deque()
        for k,v in degrees.items():
            if v==0:
                q.append(k)
        
        ans=[]
        while len(q)==1:
            
            item=q.popleft()
            ans.append(item)
            for e in edges[item]:
                degrees[e]-=1
                if degrees[e]==0:
                    q.append(e)
                
        return ans==org and len(nodes)==len(org)
org=[1,2,3]
seqs = [[1,2],[1,3]] 
org = [1,2,3]
seqs = [[1,2]]
org = [1,2,3]
seqs = [[1,2],[1,3],[2,3]] 
org = [4,1,5,2,6,3]
seqs = [[5,2,6,3],[4,1,5,2]]          
if __name__ == "__main__":
    print(Solution().sequenceReconstruction(org, seqs))                  
                            
                
#607. Two Sum III - Data structure design            
class TwoSum:
    """
    @param: number: An integer
    @return: nothing
    """
    def __init__(self):
        self.table=[]
        
    def add(self, number):
        # write your code here
        self.table.append(number)

    """
    @param: value: An integer
    @return: Find if there exists any pair of numbers which sum is equal to the value.
    """
    def find(self, value):
        # write your code here
        hashset=set()
        for x in self.table:
            if value-x not in hashset:
                hashset.add()
            else:
                return True
        return False
                
#608. Two Sum II - Input array is sorted            
class Solution:
    """
    @param nums: an array of Integer
    @param target: target = nums[index1] + nums[index2]
    @return: [index1 + 1, index2 + 1] (index1 < index2)
    """
    def twoSum(self, nums, target):
        # write your code here
        import bisect
        
        n=len(nums)
        if n==0 or n==1:
            return []
        
        for i in range(n):
            another=target-nums[i]
            if another<nums[i]:
                break
            if another>nums[-1]:
                continue
            j=bisect.bisect_right(nums,another)
            print(j)
            #if nums[j-1]==another:
            return [i+1,j]
        
  
        
nums = [0,0,3,4]
target = 0
nums =[2,7,11,15]
target =9
#return [1, 2]        
if __name__ == "__main__":
    print(Solution().twoSum(nums, target))  

#611. Knight Shortest Path
"""
Definition for a point.
class Point:
    def __init__(self, a=0, b=0):
        self.x = a
        self.y = b
"""

class Solution:
    """
    @param grid: a chessboard included 0 (false) and 1 (true)
    @param source: a point
    @param destination: a point
    @return: the shortest path 
    """
    def shortestPath(self, grid, source, destination):
        # write your code here
        m=len(grid)
        if m==0:
            return -1
        n=len(grid[0])
        if n==0:
            return -1
        
        if grid[source[0]][source[1]]==1 or grid[destination[0]][destination[1]]==1:
            return -1
        
        source=tuple(source)
        destination=tuple(destination)
        
        from collections import deque
        dq=deque([(source[0],source[1],0)])
        visited=set()
        visited.add(source)
        while dq:
            tempdp=deque()
            for _ in range(len(dq)):
                x,y,step=dq.popleft()
                if (x,y)==destination:
                    return step
                for i ,j in ((x + 1, y + 2), 
                             (x + 1, y - 2),
                             (x - 1, y + 2),
                             (x - 1, y - 2),
                             (x + 2, y + 1),
                             (x + 2, y - 1),
                             (x - 2, y + 1),
                              (x - 2, y - 1)):
                    if i>=0 and j>=0 and i<m and j <n and ( i,j) not in visited and grid[i][j]!=1:
                        tempdp.append((i,j,step+1))
                        visited.add((i,j))
            dq=tempdp
        return -1
                        
                        
                
                
 
        
grid=[[0,0,0],
 [0,0,0],
 [0,0,0]]
source = [2, 0]
destination = [2, 2] #return 2
grid=[[0,1,0],
 [0,0,0],
 [0,0,0]]
source = [2, 0] 
destination = [2, 2] #return 6

grid=[[0,1,0],
 [0,0,1],
 [0,0,0]]
source = [2, 0]
destination = [2, 2] #return -1
if __name__ == "__main__":
    print(Solution().shortestPath( grid, source, destination))  


#612. K Closest Points
"""
Definition for a point.
class Point:
    def __init__(self, a=0, b=0):
        self.x = a
        self.y = bDefinition for a point.
class Point:
    def __init__(self, a=0, b=0):
        self.x = a
        self.y = b
"""

class Solution:
    """
    @param points: a list of points
    @param origin: a point
    @param k: An integer
    @return: the k closest points
    """
    def kClosest(self, points, origin, k):
        # write your code here
        import heapq
        n=len(points)
        if n==0:
            return []
        
        hp=[]
        for p in points:
            heapq.heappush(hp,((p.x-origin.x)**2+(p.y-origin.y)**2,p.x,p.y))
            
        
        res=[]
        for _ in range(min(k,n)):
            d,x,y=heapq.heappop(hp)
            res.append(Point(x,y))
        return res
    
points = [[4,6],[4,7],[4,4],[2,5],[1,1]]
origin = [0, 0]
k = 3
#return [[1,1],[2,5],[4,4]]


#614. Binary Tree Longest Consecutive Sequence II
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""

class Solution:
    """
    @param root: the root of binary tree
    @return: the length of the longest consecutive sequence path
    """
    def longestConsecutive2(self, root):
        # write your code here
        
#        def dfs(node,diff):
#            
#            if not node:
#                return 0
#            if not node.left and not node.right:
#                return 1
#            
#            if node.left and node.val-node.left.val==diff:
#                left=1+dfs(node.left,diff)
#            if node.right and node.val-node.right.val==diff:
#                right=1+dfs(node.right,diff)
#            return max(left,right)
#        
#        if not root:
#            return 0
#        
#        if not root.left and not root.right:
#            return 1
#        
#        res=1+dfs(root,-1)+dfs(root,1)
#        
#        return max(res,self.longestConsecutive2(root.left),self.longestConsecutive2(root.right))
        
        def search(node):
            if not node:
                return 0
            dec=1
            inc=1
            
            if node.left:
                cdec,cinc=search(node.left)
                if node.val- node.left.val==1:
                    inc=cinc+1
                elif node.val- node.left.val==-1:
                    dec=cdec+1
            
            if node.right:
                cdec,cinc=search(node.right)
                if node.val- node.right.val==1:
                    inc=max(cinc+1,inc)
                elif node.val- node.right.val==-1:
                    dec=max(dec,cdec+1)
            self.res=max(self.res,inc+dec-1)
            return dec,inc
        self.res=0
        search(root)
        return self.res
                

    1
   / \
  2   0
 /
3

#615. Course Schedule
class Solution:
    """
    @param: numCourses: a total of n courses
    @param: prerequisites: a list of prerequisite pairs
    @return: true if can finish all courses or false
    """
    def canFinish(self, numCourses, prerequisites):
        # write your code here
#        visited=[0 for _ in range(numCourses)]
#        from collections import defaultdict
#        graph=defaultdict(list)
#        for x,y in prerequisites:
#            graph[x].append(y)
#            
#        def dfs(visited,graph,i):
#            if visited[i]==-1:
#              return False
#            if visited[i]==1:
#                return True
#            
#            visited[i]=-1
#            for j in graph[i]:
#                if not dfs(visited,graph,j):
#                    return False
#            visited[i]=1
#            return True
#            
#                
#                
#        for course in range(numCourses):
#            if not dfs(visited,graph,course):
#                return False
#        return True
    
    
    
    #topological sort 
    
        from collections import defaultdict,deque
        ind=defaultdict(list)
        out=[0 for _ in range(numCourses)]
        
        for p in  prerequisites:
            out[p[0]]+=1
            ind[p[1]].append(p[0])
        
        
        dq=deque()
        
        for i in range(numCourses):
            if out[i]==0:
                dq.append(i)
        if len(dq)==0:
            return False
        
        k=0
        while dq:
            x=dq.popleft()
            k+=1
            
            for y in ind[x]:
                out[y]-=1
                if out[y]==0:
                    dq.append(y)
        return k==numCourses
            
            
numCourses = 2
prerequisites = [[1,0]]
numCourses = 2
prerequisites = [[1,0],[0,1]] 
numCourses =10
prerequisites=[[5,8],[3,5],[1,9],[4,5],[0,2],[1,9],[7,8],[4,9]]           
if __name__ == "__main__":
    print(Solution().canFinish(numCourses, prerequisites)) 

#616. Course Schedule II
class Solution:
    """
    @param: numCourses: a total of n courses
    @param: prerequisites: a list of prerequisite pairs
    @return: the course order
    """
    def findOrder(self, numCourses, prerequisites):
        # write your code here
        from collections import defaultdict,deque
        
        ind=defaultdict(list)
        out=[0 for _ in range(numCourses)]
        
        res=[]
        
        for a,b in prerequisites:
            out[a]+=1
            ind[b].append(a)
        dq=  deque()  
        res=[]
        for i in range(numCourses):
            if out[i]==0:
                dq.append(i)
        
        while dq:
            x=dq.popleft()
            res.append(x)
            for j in ind[x]:
                out[j]-=1
                if out[j]==0:
                    dq.append(j)
        return res if len(res)==numCourses else []
numCourses = 2
prerequisites = [[1,0]]  
numCourses = 4
prerequisites = [[1,0],[2,0],[3,1],[3,2]]              
if __name__ == "__main__":
    print(Solution().findOrder(numCourses, prerequisites)) 
            
            
        
#617. Maximum Average Subarray II        
class Solution:
    """
    @param: nums: an array with positive and negative numbers
    @param: k: an integer
    @return: the maximum average
    """
    def maxAverage(self, nums, k):
        # write your code here        
        
#复杂度：O(nlog(max + min))，其中n是nums的长度，max和min分别是nums中的最大值和最小值。
#这里用了“二分答案”思想。
#
#所求的最大平均值一定是介于原数组的最大值和最小值之间，所以我们的目标是用二分法来快速的在这个
#范围内找到我们要求的最大平均值，初始化left为原数组的最小值，right为原数组的最大值，然后mid就是
#left和right的中间值，难点就在于如何得到mid和要求的最大平均值之间的大小关系，从而判断二分的方向。
#我们想，如果我们已经算出来了这个最大平均值maxAvg，那么对于任意一个长度大于等于k的数组，如果让每
#个数字都减去maxAvg，那么得到的累加差值一定是小于等于0的。所以我们通过left和right值算出来的mid，
#可以看作是maxAvg的一个candidate，所以我们就让数组中的每一个数字都减去mid，然后算差值的累加和，
#一旦发现累加和大于0了，那么说明我们mid比maxAvg小，这样就可以判断方向了。
#
#具体步骤：
#1.每次进入循环时，我们建立一个前缀和数组prefixSums，然后求出原数组中最小值赋给left，最大值赋给right，
#题目中说了误差是1e-6，所以我们的循环条件就是right比left大1e-6；
#2.然后我们算出来mid，prefixSumMin初始为0，maxSum初始化为INT_MIN。然后开始遍历数组，
#先更新prefixSums，注意prefixSums是它们和mid相减的差值累加。我们的目标是找长度大于等于k的子数组的
#平均值大于mid，由于我们每个数组都减去了mid，那么就转换为找长度大于等于k的子数组的差累积值大于0。
#然后问题转变成了“最大 >k 的 sum range 要小于0”的问题。如果确实小于0，则end = mid，否则start = mid。

        
        def has_greater(nums,k,mid):
            sm=0.0
            prev_sm=0.0
            prev_min=0.0
            
            for i in range(len(nums)):
                sm+=float(nums[i])-mid
                if i>=k-1 and sm>=0:
                    return True
                if i-k>=0:
                   prev_sm+=float(nums[i-k])-mid
                   prev_min=min(prev_min,prev_sm)
                   if sm-prev_min>=0:
                       return True
            return False
        start=min(nums)
        end=max(nums)
        
        while start+1e-6<end:
            mid=(start+end)/2
            if has_greater(nums,k,mid):
                start=mid
            else:
                end=mid
        return start
                   
#622. Frog Jump  
class Solution:
    """
    @param stones: a list of stones' positions in sorted ascending order
    @return: true if the frog is able to cross the river or false
    """
    def canCross(self, stones):
        # write your code here
#        n=len(stones)
#        if n==0:
#            return True
#        if n==1:
#            return True
#        if stones[1]!=1:
#            return False
#        def dfs(stones,pos,last_jump):
#            if pos==stones[-1]:
#                return True
#            #print(pos)
#            
#            for next_step in (last_jump-1,last_jump,last_jump+1):
#                if next_step==0 or pos+next_step not in stones:
#                    continue
#                if  dfs(stones,pos+next_step,next_step):
#                    return True
#            return False
#        
#        
#        if dfs(stones,1,1):
#            return True
#        else:
#            return False
        
        
        S=set(stones)
        visited=set([(stones[0],0)])
        
        
        from collections import deque
        q=deque([(stones[0],0)])
        
        while q:
            pos,step=q.popleft()
            if pos==stones[-1]:
                return True
            
            for x in (step-1,step,step+1):
                if x>0 and x+pos in S and (x+pos,x) not in visited:
                    visited.add((x+pos,x))
                    q.append((x+pos,x))
        return False
                    
stones = [0,1,3,5,6,8,12,17]
stones = [0,1,2,3,4,8,9,11]        
if __name__ == "__main__":
    print(Solution().canCross(stones)   )      
        
        
#623. K Edit Distance
class Solution:
    """
    @param words: a set of stirngs
    @param target: a target string
    @param k: An integer
    @return: output all the strings that meet the requirements
    """
    def kDistance(self, words, target, k):
        # write your code here
        
        def Distance(w1,w2):
            m=len(w1)
            n=len(w2)
            dp=[[0 for _ in range(n+1)] for _ in range(m+1)]
            
            
            for i in range(1,m+1):
                dp[i][0]=i
            for j in range(1,n+1):
                dp[0][j]=j
                
            for i in range(1,m+1):
                for j in range(1,n+1):
                    if w1[i-1]==w2[j-1]:
                       dp[i][j]=dp[i-1][j-1]
                    else:
                        dp[i][j]=1+min(dp[i-1][j-1],dp[i][j-1],dp[i-1][j])
            return dp[m][n]
        res=[]
        for word in words:
            if Distance(target,word) <=k:
                res.append(word)
        return res
words = ["abc", "abd", "abcd", "adc"] 
target = "ac"
k = 1
#Return ["abc", "adc"]        
if __name__ == "__main__":
    print(Solution().kDistance( words, target, k))      
                
        
        
#626. Rectangle Overlap        
"""
Definition for a point.
class Point:
    def __init__(self, a=0, b=0):
        self.x = a
        self.y = b
"""

class Solution:
    """
    @param l1: top-left coordinate of first rectangle
    @param r1: bottom-right coordinate of first rectangle
    @param l2: top-left coordinate of second rectangle
    @param r2: bottom-right coordinate of second rectangle
    @return: true if they are overlap or false
    """
    def doOverlap(self, l1, r1, l2, r2):
        # write your code here
        
         return not ( (r1.y>l2.y   or r2.y>l1.y)   or (r1.x<l2.x or l1.x>r2.x ))
       
        
#627. Longest Palindrome
class Solution:
    """
    @param s: a string which consists of lowercase or uppercase letters
    @return: the length of the longest palindromes that can be built
    """
    def longestPalindrome(self, s):
        # write your code here
        from collections import Counter
        count=Counter(s)
        
        res=0
        for k,v in count.items():
            if v%2==0:
                res+=v
            else:
                res+=v-1
        return res
                
        
#632. Binary Tree Maximum Nod        
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""

class Solution:
    """
    @param: root: the root of tree
    @return: the max node
    """
    def maxNode(self, root):
        # write your code here
        def maxNode(self, root):
        # write your code here
        self.res=None
        def preorder(node):
            if not self.res or  node.val>self.res.val :
                self.res=node
            
            if node.left:
               preorder(node.left)
            if node.right:
                preorder(node.right)
        
                
        if not root:
           return None
        preorder(root)
        return self.res


#633. Find the Duplicate Number
class Solution:
    """
    @param nums: an array containing n + 1 integers which is between 1 and n
    @return: the duplicate one
    """
    def findDuplicate(self, nums):
        # write your code here
        n=len(nums)
        
        table=[0 for _ in range(n)]
        
        for x in nums:
            if table[x-1] >0:
                return x
            else:
                table[x-1]=x
        
            

#634. Word Squares   
class TrieNode:
    def __init__(self):
        self.children={}
        self.words=[]

class Trie:
    def __init__(self):
        self.root=TrieNode()
    
    def insert(self,word):
        cur=self.root
        cur.words.append(word)
        
        for char in  word:
            if char  not in cur.children:
                cur.children[char]=TrieNode()
            cur=cur.children[char]
            cur.words.append(word)
            
    def wordstartwithprefix(self,string):
        cur=self.root
        for char in string:
            if char not in cur.children:
                return []
            cur=cur.children[char]
        return cur.words
        
class Solution:
    
    """
    @param: words: a set of words without duplicates
    @return: all word squares
    """
    def wordSquares(self, words):
        # write your code here
#http://massivealgorithms.blogspot.com/2016/10/leetcode-425-word-squares.html
        
        if words is None or len(words)==0:
            return []
        
        self.wordTrie=self.initTrie(words)
        
        res=[]
        self.getWordSquares(len(words[0]),0,[],res)
        return res
        
    def initTrie(self,words):
        wordTrie=Trie()
        for word in words:
            wordTrie.insert(word)
        return wordTrie
    
    def checkValidPrefix(self,wordLen,level,cur,word):
        for i in range(level+1,wordLen):
            prefix=''.join(cur[row][i] for row in range(level) )
            prefix+=word[i]
            if not self.wordTrie.wordstartwithprefix(prefix):
                return False
        return True
            
    def getWordSquares(self,wordLen,level,cur,res):
        if level==wordLen:
            res.append(cur[:])
            return 
        prefix=''.join(cur[row][level] for row in range(level))
        candidates=self.wordTrie.wordstartwithprefix(prefix)
        
        for word in candidates:
            if not self.checkValidPrefix(wordLen,level,cur,word):
                continue
            self.getWordSquares(wordLen,level+1,cur+[word],res)
words=["abat","baba","atan","atal"]      
if __name__ == "__main__":
    print(Solution().wordSquares( words))      
                    
#636. 132 Pattern        
class Solution:
    """
    @param nums: a list of n integers
    @return: true if there is a 132 pattern or false
    """
    def find132pattern(self, nums):
        # write your code here
        
#the maximum candidate for s3 is always the recently popped number from the stack, because
# if we encounter any 
#entry smaller than the current candidate, the function would already have returned. 
        n=len(nums)
        if n<=2:
            return False
        
        stack=[]
        
        e3=float('-inf')
        for e in reversed(nums):
            
            if e<e3:
                return True
            while stack and e>stack[-1]:
                e3=stack.pop()
                
            stack.append(e)
        return False

                
        
nums = [1, 2, 3, 4]
nums = [3, 1, 4, 2]

#637. Valid Word Abbreviation
class Solution:
    """
    @param word: a non-empty string
    @param abbr: an abbreviation
    @return: true if string matches with the given abbr or false
    """
    def validWordAbbreviation(self, word, abbr):
        # write your code here
        
        def match(word, abbr):
            if not word and not abbr:
                return True
            if not word and abbr:
                return False
            if word and not abbr:
                return False
            m=len(word)
            n=len(abbr)
            
            
            
            
            i=0
            j=0
            
            while i<m and j<n:
                if word[i]==abbr[j]:
                    i+=1
                    j+=1
                else:
                    break
            
            if i==m and j==n:
                return True
            elif i==m and j!=n:
                return False
            elif i!=m and j==n:
                return False
            
            if not abbr[j].isdigit() and  abbr[j] != word[i]:
                return False
            #print(i,j)
            digittemp=''
            for x in range(j,n):
                if abbr[x].isdigit():
                    digittemp+=abbr[x]
                else:
                    break
            if digittemp.startswith('0'):
                return False
            num=int(digittemp)
            if num+i>m:
                return False
            #print(i,num,x)
            return  match(word[i+num:], abbr[j+len(digittemp):])
        return match(word, abbr)
word = "internationalization"
abbr = "i12iz4n" 
word = "apple"
abbr = "a2e"
word ="a"
abbr ="1"
word ="a"
abbr ="01"
word ="aa"
abbr ="a2"   
if __name__ == "__main__":
    print(Solution().validWordAbbreviation(word, abbr))      
                                
                    
#638. Isomorphic Strings        
class Solution:
    """
    @param s: a string
    @param t: a string
    @return: true if the characters in s can be replaced to get t or false
    """
    def isIsomorphic(self, s, t):
        # write your code here
        
        from collections  import Counter
        scount=Counter(s)
        tcount=Counter(t)
        
        return sorted(scount.values())==sorted(tcount.values())
        
s = "egg"
t = "add"
#return true.

s = "foo"
t = "bar"
#return false.

s = "paper"
t = "title"
#return true.        
if __name__ == "__main__":
    print(Solution().isIsomorphic( s, t))            
        
        

#639. Word Abbreviation
class Solution:
    """
    @param dict: an array of n distinct non-empty strings
    @return: an array of minimal possible abbreviations for every word
    """
    def wordsAbbreviation(self, dict):
        # write your code here
        self.dmap={}
        def abbr(word,size):
            if len(word)-size<=3:
                return word
            return word[:size+1]+str(len(word)-size-2)+word[-1]
        
        def solve(dict,size):
            from collections import defaultdict
            
            dlist=defaultdict(list)
            
            for word in dict:
                dlist[abbr(word,size)].append(word)
                #print(dlist)
            
            for ab,wlist in dlist.items():
                if len(wlist)==1:
                    self.dmap[wlist[0]]=ab
                else:
                    #print(wlist)
                    solve(wlist,size+1)
        
        
                    
        solve(dict,0)     
        return list(map(self.dmap.get,dict))
                
dict = ["like", "god", "internal", "me", "internet", "interval", "intension", "face", "intrusion"]        
if __name__ == "__main__":
    print(Solution().wordsAbbreviation( dict))            
                
        
        
#640. One Edit Distance
class Solution:
    """
    @param s: a string
    @param t: a string
    @return: true if they are both one edit distance apart or false
    """
    def isOneEditDistance(self, s, t):
        # write your code here
#        m=len(s)
#        n=len(t)
#        
#        dp=[[0 for _ in range(n+1)] for _ in range(m+1)]
#        
#        for i in range(1,m+1):
#            dp[i][0]=i
#            
#        for j in range(1,n+1):
#            dp[0][j]=j
#        
#        for i in range(1,m+1):
#            for j in range(1,n+1):
#                if s[i-1]==t[j-1]:
#                    dp[i][j]=dp[i-1][j-1]
#                else:
#                    
#                    dp[i][j]=1+min(dp[i-1][j-1],dp[i][j-1],dp[i-1][j])
#        #print(dp)
#        return dp[m][n]==1
        
        m=len(s)
        n=len(t)
        
        #make sure m is the longer one
        
        if abs(m-n)>1:
            return False
        if s==t:
            return False
        # ensure that s is a longer one
        if m<n:
            m,n=n,m
            s,t=t,s
        
        i=0
        
        while i<min(n,m):
            if s[i]==t[i]:
                i+=1
                # find the first different position
            else:
                # insert or delete
                if s[i+1:]==t[i:]:
                    return True
                # replace
                if s[i+1:]==t[i+1:]:
                    return True
                return False
        return True

s= "aDb"
t = "adb"
#return true
s="a"
t ="ab"
if __name__ == "__main__":
    print(Solution().isOneEditDistance(s, t))            
                
#641. Missing Ranges
class Solution:
    """
    @param: nums: a sorted integer array
    @param: lower: An integer
    @param: upper: An integer
    @return: a list of its missing ranges
    """
    def findMissingRanges(self, nums, lower, upper):
        # write your code here
        from bisect import insort,bisect_left
        if not nums:
            if lower==upper:
                return [str(lower)]
            else:
                return [str(lower)+'->'+str(upper)]
        lower_in=True
        upper_in=True
        if lower not in nums:
            insort(nums,lower)
            lower_in=False
        if upper not in nums  :
            insort(nums,upper)
            upper_in=False
            
        index_lower=bisect_left(nums,lower)
        if not lower_in:
            nums[index_lower]=lower-1
            
        index_upper=bisect_left(nums,upper)
        if not upper_in:
            nums[index_upper]=upper+1
            
        
        
        res=[]
        for i in range(index_lower+1,index_upper+1):
            if nums[i]-nums[i-1]==1:
                continue
            elif nums[i]-nums[i-1]==2:
                res.append( str(nums[i]-1))
            elif nums[i]-nums[i-1]>2:
                res.append( str(nums[i-1]+1)+ '->'+ str(nums[i]-1)     )
        return res
                
nums = [0, 1, 3, 50, 75]
lower = 0 
upper = 99
#return ["2", "4->49", "51->74", "76->99"].     
if __name__ == "__main__":
    print(Solution().findMissingRanges(nums, lower, upper))            
                
#642. Moving Average from Data Stream
from collections import deque
class MovingAverage:
    """
    @param: size: An integer
    """
    def __init__(self, size):
        # do intialization if necessary
        self.q=deque()
        self.capacity=size
        self.size=0
        self.sum=0

    """
    @param: val: An integer
    @return:  
    """
    def next(self, val):
        # write your code here
        
        if self.size<self.capacity:
            self.size+=1
            self.q.append(val)
            self.sum+=val
            return self.sum/self.size
        else:
            temp=self.q.popleft()
            self.q.append(val)
            self.sum-=temp
            self.sum+=val
            
            return self.sum/self.size
            


# Your MovingAverage object will be instantiated and called as such:
# obj = MovingAverage(size)
# param = obj.next(val)           

#643. Longest Absolute File Path
class Solution:
    """
    @param input: an abstract file system
    @return: return the length of the longest absolute path to file
    """
    def lengthLongestPath(self, input):
        # write your code here
        dictionary={}
        
        res=0
        
        fileList=input.split('\n')
        print(fileList)
        
        for file in fileList:
            if '.' not in file:#是文件夹
                key=file.count('\t')#\t 是一个字
                dictionary[key]=len(file)-key
                #print(file,key,dictionary[key])
            else:
                key=file.count('\t')
                filelength=sum( [v for k,v in dictionary.items() if k<key])+len(file.replace('\t',''))+key#还要加斜杠
                res=max(res,filelength)
            print(dictionary)
        return res
input="dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext" 
input="dir\n\tsubdir1\n\tsubdir2\n\t\tfile.ext"   
if __name__ == "__main__":
    print(Solution().lengthLongestPath(input))    
                
#644. Strobogrammatic Number                
class Solution:
    """
    @param num: a string
    @return: true if a number is strobogrammatic or false
    """
    def isStrobogrammatic(self, num):
        # write your code here
        
        def Strobogrammatic(num):
            n=len(num)
            if n==0:
               return True
            if n==1 and num in ('1','8','0'):
               return True
            elif n==1 and num not in ('1','8','0'):
               return False
            x=num[0]
            y=num[-1]
            if x==y and x in ('1','8','0'):
                return Strobogrammatic(num[1:-1])
            if x!=y:
                if  ((x =='6' and y=='9')  or (x =='9' and y=='6')):
                    return Strobogrammatic(num[1:-1])
                else:
                    return False
        return Strobogrammatic(num)
num = "69"
#return true
num = "68"#
#return false
num ='818'
if __name__ == "__main__":
    print(Solution().isStrobogrammatic( num))


#645. Find the Celebrity                
"""
The knows API is already defined for you.
@param a, person a
@param b, person b
@return a boolean, whether a knows b
you can call Celebrity.knows(a, b)
"""
class Solution:
    # @param {int} n a party with n people
    # @return {int} the celebrity's label or -1
    def findCelebrity(self, n):
        # Write your code here
        
        
        def verify(n,j):
            for y in range(n):
                if y==j:
                    continue
                    
                if not Celebrity.knows(y, j):
                       return False
                if  Celebrity.knows(j,y):
                       return False
            return True
        
        
        if n==1:
            return 0
        for i in range(n):
            for j in range(n):
                if i==j:
                    continue
                
                if Celebrity.knows(i, j):
                    if verify(n,j):
                        return j
        return -1
        
                
#646. First Position Unique Character
class Solution:
    """
    @param s: a string
    @return: it's index
    """
    def firstUniqChar(self, s):
        # write your code here
        n=len(s)
        if n==0:
            return -1
        if n==1:
            return s[0]
        
        for i,x in  enumerate(s):
          if x not in s[:i]:
            if x not in s[i+1:]:
                return i
        return -1
s="lintcode"  
s = "lovelintcode" 
s ="{{;;lintcodelintcode}}"     
if __name__ == "__main__":
    print(Solution().firstUniqChar( s))        
        
        
#647. Find All Anagrams in a String
class Solution:
    """
    @param s: a string
    @param p: a string
    @return: a list of index
    """
    def findAnagrams(self, s, p):
        # write your code here
        if not s:
            return []
        m=len(s)
        n=len(p)
        
        if m<n:
            return []
        res=[]
        from collections import Counter
        pcount=Counter(p)
        print(pcount)
        for i in range(n-1,m):
            
            if i==n-1:
               scount=Counter(s[:i+1])
               if scount==pcount:
                  res.append(i-n+1)
            else:
                
                if s[i] not in scount:
                                       
                   scount[s[i]]=1
                else:
                   scount[s[i]]+=1 
                scount[s[i-n]] -=1 
                if scount[s[i-n]]==0:
                    del scount[s[i-n]]
                print(i,scount,pcount)
                if scount==pcount:
                  res.append(i-n+1) 
                
                
        return res
        
s="abab"
p="ab"
if __name__ == "__main__":
    print(Solution().findAnagrams( s, p))        
                
        
#648. Unique Word Abbreviation  
from collections import  defaultdict
     
class ValidWordAbbr:
    """
    @param: dictionary: a list of words
    """
    def __init__(self, dictionary):
        # do intialization if necessary
        self.table=defaultdict(int)
        self.dictionary=set(dictionary)
        for w in self.dictionary:
            
           
            if len(w)<=2:
                abbr=w
                
            else:
                abbr=w[0]+str(len(w)-2)+w[-1]
            self.table[abbr]+=1
        #print(self.table)
            

    """
    @param: word: a string
    @return: true if its abbreviation is unique or false
    """
    def isUnique(self, word):
        # write your code here
        if len(word)<=2:
                abbr=word
        else:
             abbr=word[0]+str(len(word)-2)+word[-1]
        if abbr not in self.table  or self.table[abbr]==0:
            return True
        elif word in self.dictionary  and self.table[abbr]==1:
            return True
        else:
            return False
        
        
        
dictionary = [ "deer", "door", "cake", "card" ]
obj.isUnique("dear") # return false
obj.isUnique("cart") # return true
obj.isUnique("cane") # return false
obj.isUnique("make") # return true 
       
dictionary =["dog"]
obj.isUnique("dig")
obj.isUnique("dug")
obj.isUnique("dag")
obj.isUnique("dog")
obj.isUnique("doge")        


dictionary =["ValidWordAbbr","isUnique"]
obj = ValidWordAbbr(dictionary)
obj.isUnique("a")
obj.isUnique("")


["a","a"]
isUnique("a")
# Your ValidWordAbbr object will be instantiated and called as such:
# obj = ValidWordAbbr(dictionary)
# param = obj.isUnique(word)        
        
        
#649. Binary Tree Upside Down
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""

class Solution:
    """
    @param root: the root of binary tree
    @return: new root
    """
    def upsideDownBinaryTree(self, root):
        # write your code here
        
        def dfs(node):
            if not node.left:
                return node
            
            newnode=dfs(node.left)
            node.left.right=node
            node.left.left=node.right
            node.left=None
            node.right=None
            return newnode
        if not root:
            return None
        return dfs(root)
            
        
        
        
        
    1
   / \
  2   3
 / \
4   5        
        
        
        
   4
  / \
 5   2
    / \
   3   1          
        
#650. Find Leaves of Binary Tree
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""


class Solution:
    """
    @param: root: the root of binary tree
    @return: collect and remove all leaves
    """
    def findLeaves(self, root):
        # write your code here
        
        from collections import deque
        def depth(node):
            if not node:
                return 0
            return 1+max(depth(node.left),depth(node.right))
        
        self.res=deque()
        
        def preOrder(node):
            if not node:
                return 
            self.res.append((node.val,depth(node.left),depth(node.right)))
            preOrder(node.left)
            preOrder(node.right)
        
        
        preOrder(root) 
        ans=[]
        while self.res:
            temp1=deque()
            temp2=[]
            for _ in range(len(self.res)):
                  node,left,right=self.res.popleft()
                  if left==0 and right==0:
                      temp2.append(node)
                  else:
                      if left>0:
                          left-=1
                      if right>0:
                          right-=1
                      temp1.append((node,left,right))
            ans.append(temp2[:])
            self.res=temp1
                      
                
            
        return ans
        
        
#    1
#   / \
#  2   3
# / \     
#4   5  
#
#
#[[4, 5, 3], [2], [1]]
root=TreeNode(1)
root.left=TreeNode(2)
root.right=TreeNode(3)

root.left.left=TreeNode(4)
root.left.right=TreeNode(5)
if __name__ == "__main__":
    print(Solution().findLeaves(root))       







#651. Binary Tree Vertical Order Traversal
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""
from collections import defaultdict,deque
class Solution:
    """
    @param root: the root of tree
    @return: the vertical order traversal
    """
    def verticalOrder(self, root):
        # write your code here
        
        self.res=defaultdict(list)
        if not root:
            return []
        if not root.left and not root.right:
            return [[root.val]]
        dq=deque([(root,0)])
       
        while dq:
           node,level=dq.popleft()
           self.res[level].append(node.val)
           if node.left:
               dq.append((node.left,level-1))
           if node.right:
               dq.append((node.right,level+1))
           
            
        
        
        
        #return self.res
        import heapq
        
        ans=[]
        
        for k,v in self.res.items():
            heapq.heappush(ans,(k,v))
        
        ans2=[]
        while ans:
            
            ans2.append(heapq.heappop(ans)[1])
            
        return ans2

#   3
#  /\
# /  \
# 9  20
#    /\
#   /  \
#  15   7
#[[9],[3,15],[20],[7]]
root=TreeNode(3)
root.left=TreeNode(9)
root.right=TreeNode(20)

root.right.left=TreeNode(15)
root.right.right=TreeNode(7)        
if __name__ == "__main__":
    print(Solution().verticalOrder( root))              
        
#653. Expression Add Operators
class Solution:
    """
    @param num: a string contains only digits 0-9
    @param target: An integer
    @return: return all possibilities
    """
    def addOperators(self, num, target):
        # write your code here

#        res=[]
#        def insert(string,target,path,res):
#            
#            if not string:
#               if  eval(path)==target:
#                   res.append(path[:])
#               return 
#            for operator in ('+','-','*',''):
#                if not operator and (path=='0' or path[-2:] in ('+0','-0','*0')):
#                    continue
#                
#                
#                insert(string[1:],target,path+operator+string[0],res)
#            return 
#        insert(num[1:],target,num[0],res)
#        return res
        
        def dfs(num,path,cur,last,target,res):
            if not num:
                if cur==target:
                    res.append(path[:])
                return 
            
            for i in range(1,len(num)+1):
                if i==1 or (num[0]!='0'):
                    val=int(num[:i])
                    
                    dfs(num[i:],path+'+'+num[:i] ,cur+val,val,target,res  )
                    dfs(num[i:],path+'-'+num[:i] ,cur-val,-val,target,res  )
                    dfs(num[i:],path+'*'+num[:i] ,cur-last+last*val,last*val,target,res)
        
        
        res=[]
        
        for i in range(1,len(num)+1):
                if i==1 or (num[0]!='0'):
                    dfs(num[i:],num[:i],int(num[:i]),int(num[:i]),target,res)
        return res
        
num="123"
target= 6
num="232"
target= 8 #-> ["2*3+2", "2+3*2"]
num="105"
target= 5 #-> ["1*0+5","10-5"]
num="00" 
target=0 #-> ["0+0", "0-0", "0*0"]
num="3456237490"
target= 9191 #-> []
if __name__ == "__main__":
    print(Solution().addOperators(num, target))              
                        
#654. Sparse Matrix Multiplication        
class Solution:
    """
    @param A: a sparse matrix
    @param B: a sparse matrix
    @return: the result of A * B
    """
    def multiply(self, A, B):
        # write your code here
        ma=len(A)
        namb=len(A[0])
        nb=len(B[0])
        
        C=[[0 for _ in range(nb)] for _ in range(ma)]
        
        for i in range(ma):
            for j in range(namb):
                for k in range(nb):
                    C[i][k]+=A[i][j]*B[j][k]
        return C
A = [
  [ 1, 0, 0],
  [-1, 0, 3]
]
B = [
  [ 7, 0, 0 ],
  [ 0, 0, 0 ],
  [ 0, 0, 1 ]
]
if __name__ == "__main__":
    print(Solution().multiply(A, B))          
        
        
#655. Add Strings        
class Solution:
    """
    @param num1: a non-negative integers
    @param num2: a non-negative integers
    @return: return sum of num1 and num2
    """
    def addStrings(self, num1, num2):
        # write your code here
        return str(int(num1)+int(num2))
        
        
#656. Multiply Strings
class Solution:
    """
    @param num1: a non-negative integers
    @param num2: a non-negative integers
    @return: return product of num1 and num2
    """
    def multiply(self, num1, num2):
        # write your code here
        l1=len(num1)
        l2=len(num2)
        l3=l1+l2
        res=[ 0 for _ in range(l3)]

        for i in range(l1-1,-1,-1):
            carry=0
            for j in range(l2-1,-1,-1):
                res[i+j+1]+=carry+int(num1[i])*int(num2[j])
                carry=res[i+j+1]//10
                res[i+j+1]=res[i+j+1]%10
            res[i]=carry
        
        k=0
        while k<l3 and res[k]==0:
            k+=1
        res=res[k:]
        
        return '0' if not res else ''.join([str(x) for x in res])

                
#657. Insert Delete GetRandom O(1)                
class RandomizedSet:
    
    def __init__(self):
        # do intialization if necessary
        self.nums=[]
        self.pos={}

    """
    @param: val: a value to the set
    @return: true if the set did not already contain the specified element or false
    """
    def insert(self, val):
        # write your code here
        if val  not in self.pos:
           self.nums.append(val)
           self.pos[val]=len(self.nums)-1
           return True
        return False
    """
    @param: val: a value from the set
    @return: true if the set contained the specified element or false
    """
    def remove(self, val):
        # write your code here
        if val  in self.pos:
            idx=self.pos[val]
            self.nums[idx]=self.nums[-1]
            self.nums.pop()
            self.pos[self.nums[idx]]=idx
            del self.pos[val]
            return True
        return False
            

    """
    @return: Get a random element from the set
    """
    def getRandom(self):
        # write your code here
        import random
        self.nums[random.randint(0,len(self.nums)-1)]

# Your RandomizedSet object will be instantiated and called as such:
# obj = RandomizedSet()
# param = obj.insert(val)
# param = obj.remove(val)
# param = obj.getRandom()                
        
#659. Encode and Decode Strings
class Solution:
    """
    @param: strs: a list of strings
    @return: encodes a list of strings to a single string.
    """
    def encode(self, strs):
        # write your code here
        res=''
        for i,string in enumerate(strs):
            for j in range(len(string)):
                if string[j]==':':
                    res=res+string[j]+':'
                else:
                    res=res+string[j]
            res+=':'
        return res[:-1]
                    
                  
            

    """
    @param: str: A string
    @return: dcodes a single string to a list of strings
    """
    def decode(self, str):
        # write your code here
        str+=':'
        res=[]
        temp=''
        for i,char in enumerate(str):
            if char==':'  and i+1<len(str)  and str[i+1]==':':
                temp+=':'
            elif  char!=':':
                temp+=char
            elif  char==':':
                res.append(temp[:])
                temp=''
        return res
strs = ["lint","code","love","you"]        
        
#660. Read N Characters Given Read4 II - Call multiple times        
"""
The read4 API is already defined for you.
@param buf a list of characters
@return an integer
you can call Reader.read4(buf)
"""


class Solution:

    # @param {char[]} buf destination buffer
    # @param {int} n maximum number of characters to read
    # @return {int} the number of characters read
    def __init__(self):
        self.head=0
        self.tail=0
        self.buffer=[0 for _ in range(4)]
    def read(self, buf, n):
        # Write your code here
#The meaning here is that read4() function will read 4 characters at 
#a time from a file and then put the characters that has been read into this buf variable.
#So read() function is reading at most n characters from a file 
#( we don’t know what file and how it’s reading from the file),
# and put x characters into char[] buf.
        i=0
        
        while i<n:
            
            if self.head==self.tail:
                self.head=0
                self.tail=Reader.read4(self.buffer)
                if self.tail==0:
                    break
            
            else:
                while i<n and self.head<self.tail:
                    buf[i]=self.buffer[self.head]
                    i+=1
                    self.head+=1
        return i
                
                
            
                
            






        
        
        
#661. Convert BST to Greater Tree        
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""

class Solution:
    """
    @param root: the root of binary tree
    @return: the new root
    """
    def convertBST(self, root):
        # write your code here
        self.sm=0
        self.last=0
        def inorder(node):
            if not node:
                return 
         
            inorder(node.left)
            self.sm+=node.val
            print(self.sm,node.val)
            #print(node.val)
          
            inorder(node.right)
        
        inorder(root)
        
        
        def inorder2(node):
            if not node:
                return 
            
            inorder2(node.left)
            self.sm-=self.last
            self.last=node.val
            node.val=self.sm
            inorder2(node.right)
        inorder2(root)
        return root
        
              5
            /   \
           2     13 
root=TreeNode(5)  
root.left=   TreeNode(2)
root.right=   TreeNode(13)         
if __name__ == "__main__":
    print(Solution().convertBST(root))             
        
        
#662. Guess Number Higher or Lower
"""
The guess API is already defined for you.
@param num, your guess
@return -1 if my number is lower, 1 if my number is higher, otherwise return 0
you can call Guess.guess(num)
"""


class Solution:
    # @param {int} n an integer
    # @return {int} the number you guess
    def guessNumber(self, n):
        # Write your code here
        
        lo=1
        hi=n
        
        while lo<hi:
            mid=(lo+hi)//2
            
            if Guess.guess(mid)==0:
                return mid
            elif Guess.guess(mid)==1:
                hi=mid-1
            else:
                lo=mid+1
                

#663. Walls and Gates
class Solution:
    """
    @param rooms: m x n 2D grid
    @return: nothing
    """
    def wallsAndGates(self, rooms):
        # write your code here
        
        from collections import deque
        m=len(rooms)
        if m==0:
            return 
        n=len(rooms[0])
        
        
        def bfs(rooms,x,y):
            
            visited=set((x,y))
            dq=deque([(x,y,0)])
            
            
            while dq:
                a,b,step=dq.popleft()
                for i,j in ( (a+1,b), (a-1,b),(a,b+1),(a,b-1)):
                    if i <m and j<n and i>=0 and j>=0 and (i,j) not in visited and rooms[i][j]!=0  and rooms[i][j]!=-1:
                        if rooms[i][j] >step+1:
                            rooms[i][j]=step+1
                            dq.append((i,j,step+1))
                            visited.add((i,j))
        for u in range(m):
            for v in range(n):
                if rooms[u][v]==0:
                    bfs(rooms,u,v)
        #return rooms
rooms=[[2147483647,-1,0,2147483647],
 [2147483647,2147483647,2147483647,-1],
 [2147483647,-1,2147483647,-1],
 [0,-1,2147483647,2147483647]]

if __name__ == "__main__":
    print(Solution().wallsAndGates(rooms))             
        

#664. Counting Bits
class Solution:
    """
    @param num: a non negative integer number
    @return: an array represent the number of 1's in their binary
    """
    def countBits(self, num):
        # write your code here
#        from collections import Counter
#        res=[]
#        for i in range(num):
#            res.append(  bin(i)[2:]   )
#        return res
        
        if num==1:
            return [0,1]
        if num==0:
            return [0]
        if num==2:
            return [0,1,2]
        
        
        
        res=[0,1]
        x=1
        while 2**x <=num:
            res=res+ list(map(lambda x:x+1,res))
            x+=1
        return res[:num+1]
num=4
if __name__ == "__main__":
    print(Solution().countBits( num))  


#665. Range Sum Query 2D - Immutable
class NumMatrix(object):

    def __init__(self, matrix):
        """
        :type matrix: List[List[int]]
        """
        m=len(matrix)
        if m>0:
          n=len(matrix[0])
          
        #self.table=[[0 for _ in range(n+1)]  for _ in range(m+1)]
        self.table=[[0 for _ in range(n+1)]  for _ in range(m+1)]
        for i in range(1,m+1):
            for j in range(1,n+1):
                self.table[i][j]=self.table[i][j-1]+matrix[i-1][j-1]
                #table[i][j]=table[i][j-1]+matrix[i-1][j-1]
                
        for i in range(1,m+1):
            for j in range(1,n+1):
                self.table[i][j]+=self.table[i-1][j]
                #table[i][j]+=table[i-1][j]
            
            
        

    def sumRegion(self, row1, col1, row2, col2):
        """
        :type row1: int
        :type col1: int
        :type row2: int
        :type col2: int
        :rtype: int
        """
        
        return self.table[row2+1][col2+1]+self.table[row1][col1]-self.table[row2+1][col1]-self.table[row1][col2+1]
        

row1, col1, row2, col2=(2, 1, 4, 3)
matrix=[
  [3, 0, 1, 4, 2],
  [5, 6, 3, 2, 1],
  [1, 2, 0, 1, 5],
  [4, 1, 0, 1, 7],
  [1, 0, 3, 0, 5]
]

# Your NumMatrix object will be instantiated and called as such:
# obj = NumMatrix(matrix)
# param_1 = obj.sumRegion(row1,col1,row2,col2)


#666. Guess Number Higher or Lower II
class Solution:
    """
    @param n: An integer
    @return: how much money you need to have to guarantee a win
    """
    def getMoneyAmount(self, n):
        # write your code here
#dp[i][j]，代表着如果我们在区间 [i , j] 内进行查找，所需要的最少 cost 来保证找到结果
#可以发现对于区间 [i, j] ，猜测 i <= k <= j 我们可能出现以下三种结果：
#       1. k 就是答案，此时子问题的额外 cost = 0 ，当前位置总 cost  = k + 0;
#       2. k 过大，此时我们的有效区间缩小为 [i , k - 1] 当前操作总 cost  = k + dp[i][k - 1];
#       3. k 过小，此时我们的有效区间缩小为 [k + 1 , j] 当前操作总 cost  = k + dp[k + 1][j];
        
        
        dp=[[0 for _ in range(n+1)] for _ in range(n+1)]
        
        for i in range(1,n+1):
            dp[i][i]=0
        
        for i in range(n-1,0,-1):
            for j in range(i+1,n+1):
                mincost=float('inf')
                for k in range(i,j):
                    mincost=min(mincost,k+max(dp[i][k-1],dp[k+1][j]))
                dp[i][j]=mincost
        print(dp)     
        return dp[1][n]
n=10 
if __name__ == "__main__":
    print(Solution().getMoneyAmount( n))        
       
#667. Longest Palindromic Subsequence       
class Solution:
    """
    @param s: the maximum length of s is 1000
    @return: the longest palindromic subsequence's length
    """
    def longestPalindromeSubseq(self, s):
        # write your code here
#F[i][j] defines the max length of longest palindropmic subsequence from i to j in s (j > i)
#for each case, if (s[i] == s[j]) then we know F[i][j] = 2 + F[i + 1][j-1],
#if (s[i] != s[j]), then two case, either don't consider i, or don't consider j
#so F[i][j] = max(F[i + 1][j], F[i][j-1]);        
        n=len(s)
        if n==0:
            return 0
        
        dp=[[0 for _ in range(n)] for _ in range(n)]
        
        
        for i in range(n):
            dp[i][i]=1
        
        for i in range(n-1,-1,-1):
            for j in range(i+1,n):
                if s[i]==s[j]:
                    dp[i][j]=2+dp[i+1][j-1]
                else:
                    dp[i][j]=max(dp[i+1][j],dp[i][j-1])
        return dp[0][n-1]
       
#668. Ones and Zeroes
class Solution:
    """
    @param strs: an array with strings include only 0 and 1
    @param m: An integer
    @param n: An integer
    @return: find the maximum number of strings
    """
    def findMaxForm(self, strs, m, n):
        # write your code here
        #其中dp[i][j]表示有i个0和j个1时能组成的最多字符串的个数
        from collections import Counter
        res=0
        dp=[[0 for _ in range(n+1)] for _ in range(m+1)]
        for s in strs:
            c =Counter(s)
            zero=c.get('0',0) 
            one=c.get('1',0)
            for i in range(m,zero-1,-1):
                for j in range(n,one-1,-1):
                    dp[i][j]=max(dp[i][j],dp[i-zero][j-one]+1)
        print(dp)
        return dp[-1][-1]
strs = ["10", "0001", "111001", "1", "0"]
m = 5
n = 3  
strs = ["0","11","1000","01","0","101","1","1","1","0","0","0","0","1","0","0110101","0","11","01","00","01111","0011","1","1000","0","11101","1","0","10","0111"]
m =9
n =80  
if __name__ == "__main__":
    print(Solution().findMaxForm( strs, m, n))         
       
#669. Coin Change
class Solution:
    """
    @param coins: a list of integer
    @param amount: a total amount of money amount
    @return: the fewest number of coins that you need to make up
    """
    def coinChange(self, coins, amount):
        # write your code here
        
        
#        self.res=float('inf')
#        def dfs(coins,step,amount):
#            if amount<0:
#                return 
#            if amount==0:
#                self.res=min(self.res,step)
#                return 
#            
#            for coin in coins:
#                dfs(coins,step+1,amount-coin)
#        dfs(coins,0,amount)
#        return self.res if self.res <float('inf') else -1
        dp=[2**31 for i in range(amount+1)]
        dp[0]=0
        
        for i in range(amount+1):
            for coin in coins:
                if i-coin>=0:
                    dp[i]=min(dp[i],dp[i-coin]+1)
        print(dp)
        return dp[amount] if dp[amount]!=2**31  else -1
                    
coins = [1, 2, 5]
amount = 11
coins =[1,2,4]
amount =32000
if __name__ == "__main__":
    print(Solution().coinChange(coins, amount))                
        
#670. Predict the Winner        
class Solution:
    """
    @param nums: nums an array of scores
    @return: check if player 1 will win
    """
    def PredictTheWinner(self, nums):
        # write your code here
        n=len(nums)
        if len(nums)%2==0:
            return True
        
        dp=[[0 for _ in range(n)] for _ in range(n)]
        
        for i in range(n):
            dp[i][i]=nums[i]
        for d in range(1,n):    
            for i in range(0,n-d):
                j=i+d
                dp[i][j]=sum(nums[i:j+1])-min(dp[i+1][j],dp[i][j-1])
                #dp[i][j]= max(nums[i] + sum(nums[i+1:j+1])-dp[i+1][j] , nums[j] +  sum(nums[i:j])- dp[i][j-1])
                #print(dp)
        return dp[0][n-1]> sum(nums)-dp[0][n-1]
nums = [1, 5, 233, 7]
nums = [1, 5, 2]
if __name__ == "__main__":
    print(Solution().PredictTheWinner(nums))              

#671. Rotate Words       
class Solution:
    """
    @param: words: A list of words
    @return: Return how many different rotate words
    """
#    def __init__(self):
#       self.array=[]
#    def find(self,i):
#        if self.array[i]!=i:
#            self.array[i]=self.find(self.array[i])
#        return self.array[i]
#    
#    def union(self,x,y):
#        a=self.find(x)
#        b=self.find(y)
#        self.array[min(a,b)]=max(a,b)
            
    def countRotateWords(self, words):
        # Write your code here
        n=len(words)
        if n==1:
            return 1
        if n==0:
            return 0
        
        hashset=set()
        count=0
        exist=False
        for word in words:
            for i  in range(len(word)):
                new_word=word[i+1:]+word[:i+1]
                #print(word,new_word ,hashset)
                if new_word in hashset:
                    exist=True
                    break
            #print(word,hashset,exist)
            if not exist:
                hashset.add(word)
               
                count+=1
            else:
                exist=False
        return count
                
                
                
            
#        self.array=[i for i in range(n)]
        
#        for i in range(n):
#            if self.array[i]!=i:
#                continue
#            for j in range(i+1,n):
#                if self.array[j]!=j:
#                    continue
#                if  len(words[i]) == len(words[j]):
#                  if  words[i] in words[j]+words[j]:
#                      self.array[j]=i
#        print(self.array)
#        for x in range(1,n):
#            self.find(x)
#        print(self.array)    
#        return len(set(self.array))
        
words = ["picture", "turepic", "icturep", "word", "ordw", "lint"] 
if __name__ == "__main__":
    print(Solution().countRotateWords(words))              
              
#676. Decode Ways II
class Solution:
    """
    @param s: a message being encoded
    @return: an integer
    """
    def numDecodings(self, s):
        # write your code here
        
        mod=1000000007
        one = {'1': 1, '2': 1, '3': 1, '4': 1, '5': 1, '6': 1, '7': 1, '8': 1, '9': 1, '*': 9}            
        two = {'10': 1, '11': 1, '12': 1, '13': 1, '14': 1, '15': 1, '16': 1, '17': 1, '18': 1, '19': 1, '20': 1, '21': 1,
       '22': 1, '23': 1, '24': 1, '25': 1, '26': 1, '*0': 2, '*1': 2, '*2': 2, '*3': 2, '*4': 2, '*5': 2, '*6': 2,
       '*7': 1, '*8': 1, '*9': 1, '1*': 9, '2*': 6, '**': 15}
        
        pre=1
        cur=one.get(s[:1],0)
        
        for i in range(1,len(s)):
        
            pre,cur=cur, (cur*one.get(s[i],0)+pre*two.get(s[i-1:i+1],0))%mod
        return cur
                    
                    
#677. Number of Big Islands
class Solution:
    """
    @param grid: a 2d boolean array
    @param k: an integer
    @return: the number of Islands
    """
    def numsofIsland(self, grid, k):
        # Write your code here
        m=len(grid)
        if m==0:
            return 0
        n=len(grid[0])
        
        def dfs(grid,i,j,count):
            for x,y in ((i-1,j),(i+1,j),(i,j-1),(i,j+1)):
                if x>=0 and y>=0 and x<m and y<n and grid[x][y]==1 and (x,y) not in visited:
                    visited.add((x,y))
                    count=dfs(grid,x,y,count+1)
            return count
        visited=set()
        res=0
        for i in range(m):
            for j in range(n):
                
                if grid[i][j]==1 and (i,j) not in visited:
                    visited.add((i,j))
                    count=dfs(grid,i,j,1)
                    if count>=k:
                        res+=1
        return res
grid=[
  [1, 1, 0, 0, 0],
  [0, 1, 0, 0, 1],
  [0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0],
  [0, 0, 0, 0, 1]
]                    
k=2
if __name__ == "__main__":
    print(Solution().numsofIsland( grid, k))                       
                    
                    
#678. Shortest Palindrome
class Solution:
    """
    @param str: String
    @return: String
    """
    def convertPalindrome(self, str):
        # Write your code here
        def isPalindrome(s):
            n=len(s)
            if n==0 or n==1:
                return True
            if n==2:
                return s[0]==s[1]
            return s[0]==s[-1]  and isPalindrome(s[1:-1])
        
        
        n=len(str)
        if isPalindrome(str):
           return str
        
        for i in range(n-1,-1,-1):
            if isPalindrome(str[:i]):
                return str[i:][::-1]+str
str="aacecaaa"
str="abcd"
if __name__ == "__main__":
    print(Solution().convertPalindrome( str))           
                    
#679. Unique Paths III                
class Solution:
    """
    @param: : an array of arrays
    @return: the sum of all unique weighted paths
    """

    def uniqueWeightedPaths(self, grid):
        # write your codes here
        
#        def travel(grid,i,j,pathsum):
#            #print(i,j)
#            if i+1==len(grid) and j+1==len(grid[0]):
#                #print(i,j)
#                self.res.add(pathsum)
#                return 
#            for x,y in ((i+1,j), (i,j+1)):
#                if x>=0 and y>=0 and x<len(grid) and y<len(grid[0]):
#                    travel(grid,x,y,pathsum+grid[x][y])
#        self.res=set()
#        m=len(grid)
#        if m==0:
#            return 0
#        n=len(grid[0])
#        if n==0:
#            return 0
#            
#        travel(grid,0,0,grid[0][0])
#        return sum(self.res)
        
        m=len(grid)
        if m==0:
            return 0
        n=len(grid[0])
        if n==0:
            return 0
        from collections import defaultdict
        dp=defaultdict(set)
        dp[0].add(grid[0][0])
        
        
        for i in range(1,m):
            cur=i*n
            pre=(i-1)*n
            for dis in dp[pre]:
                dp[cur].add(dis+grid[i][0])
                
        for j in range(1,n):
            cur=j
            pre=j-1
            for dis in dp[pre]:
                dp[cur].add(dis+grid[0][j])
                
                
        for i in range(1,m):
            for j in range(1,n):
                cur=i*n+j
                left=i*n+j-1
                up=(i-1)*n+j
                
                for dis in dp[left]:
                    dp[cur].add(dis+grid[i][j])
                for dis in dp[up]:
                    dp[cur].add(dis+grid[i][j])
        idx=m*n-1
        
        return sum(dp[idx])
                
    
grid=[
  [1,1,2],
  [1,2,3],
  [3,2,4]
]
grid=[[]]
if __name__ == "__main__":
    print(Solution().uniqueWeightedPaths( grid))

                    
#680. Split String                    
class Solution:
    """
    @param: : a string to be split
    @return: all possible split string array
    """

    def splitString(self, s):
        # write your code here
        
        def split(S,path,res):
            if not S:
                res.append(path[:])
                return 
            print(S)
            n=len(S)
            if n==1:
                split(S[1:],path+[S],res)
            elif n>=2:
                split(S[1:],path+[S[0]],res)
                split(S[2:],path+[S[0:2]],res)
            return 
            
        res=[]
        split(s,[],res)
        return res
s= "123"       
if __name__ == "__main__":
    print(Solution().splitString( s))
                    

#681. First Missing Prime Number
class Solution:
    """
    @param nums: an array of integer
    @return: the first missing prime number
    """
    def firstMissingPrime(self, nums):
        # write your code here
        def isPrime(n):
            import math
            if n in (2,3,5,7):
                return True
           
            if n in (4,6,8,9):
                return False
            for i in range(2,  int(math.ceil(n**0.5))+1):
                if n%i==0:
                    return False
            return True
        
        n=len(nums)
        if n==0:
            return 2
        if nums[0]>2:
            return 2
        k=2
        
        nums=set(nums)
        
        while True:
            if k in nums:
                k+=1
                continue
            else:
                if isPrime(k):
                    return k
                else:
                    k+=1
            
                    
nums=[2,3,5,7,11,13,17,23,29]                    
                    
if __name__ == "__main__":
    print(Solution().firstMissingPrime( nums))                    
                    
                    
#683. Word Break III
class Solution:
    """
    @param: : A string
    @param: : A set of word
    @return: the number of possible sentences.
    """

    def wordBreak3(self, s, dict):
        # Write your code here   

        dict=[st.lower()  for st in dict ]
        dict=set(dict)
        s=s.lower()
        
        max_length=0
        for x in dict:
            if len(x)>max_length:
                max_length=len(x)
        
        def dfs(string,dict,max_length,memo):
            if not string:
                return 1
            if string in memo:
                return memo[string]
            
            count=0
            
            for i in range(1,max_length+1):
                if i >len(string):
                    break
                if string[:i] not in dict:
                    continue
                count+=dfs(string[i:],dict,max_length,memo)
            memo[string]=count
            return count
                
        return dfs(s,dict,max_length,{})
        
                   
               

dict=["Cat", "Mat", "Ca", "tM", "at", "C", "Dog", "og", "Do"] 
                
s='CatMat'
s="aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
dict=["a","aa","aaa","aaaa","aaaaa","aaaaaa","aaaaaaa","aaaaaaaa","aaaaaaaaa","aaaaaaaaaa"]    
if __name__ == "__main__":
    print(Solution().wordBreak3( s, dict))                   
                         
#684. Missing String                     
class Solution:
    """
    @param str1: a given string
    @param str2: another given string
    @return: An array of missing string
    """
    def missingString(self, str1, str2):
        # Write your code here
        str1=str1.split()
        str2=str2.split()
        from collections import Counter
        count=Counter(str2)
        
        for i in range(len(str1)):
            if str1[i] in count  and count[str1[i]]>0:
                str1[i]=''
                count[str1[i]]-=1
        res=[x for x in str1 if x]
        return res
                
        
            
        
        
        
       
str1=    "This is an example"
str2="is example"
str1= "This is an example"
str2=" "
str1="This is an example"
str2="example is"
if __name__ == "__main__":
    print(Solution().missingString( str1, str2))                      
            
#685. First Unique Number In Stream            
class Solution:
    """
    @param nums: a continuous stream of numbers
    @param number: a number
    @return: returns the first unique number
    """
    def firstUniqueNumber(self, nums, number):
        # Write your code here
        from collections import OrderedDict
        numtable=OrderedDict()
        has=False
        for x in nums:
            
            if x in numtable:
               numtable[x]+=1
            else:
                numtable[x]=1
            if x==number:
                has=True
                break
        if not has:
            return -1
        for y in numtable:
            if numtable[y]==1:
                return y
        return -1
nums=[1, 2, 2, 1, 3, 4, 4, 5, 6]            
number=5                        
                    
nums=[1, 2, 2, 1, 3, 4, 4, 5, 6]
number=7                         
if __name__ == "__main__":
    print(Solution().firstUniqueNumber(nums, number))                      
                                    
#688. The Number In Words
class Solution:
    """
    @param number: the number
    @return: the number in words
    """
    def __init__(self):
            self.less20=["","One","Two","Three","Four","Five","Six","Seven","Eight","Nine","Ten","Eleven","Twelve","Thirteen","Fourteen","Fifteen","Sixteen","Seventeen","Eighteen","Nineteen"]
            self.tens=["","Ten","Twenty","Thirty","Forty","Fifty","Sixty","Seventy","Eighty","Ninety"]
            self.thousands=["","Thousand","Million","Billion"]
    def convertWords(self, number):
        # Write your code here
        if number==0:
            return 'Zero'
        def helper(n):
            if n==0:
                return ''
            if n<20:
               return self.less20[n]+' '
            elif n<100:
               return self.tens[n//10]+' '+self.less20[n%10]
            else:
               #print('&&')
               #print(self.tens[n//100])
               #print(self.tens[n//100]+'Hundred' +helper(n%100))
               return self.less20[n//100]+' Hundred' +' '+helper(n%100)
        
        res=''
        #print('**')
        for i in range(len(self.thousands)):
            if number%1000!=0:
               
               res=helper(number%1000) +' '+self.thousands[i]+' '+res
            number//=1000
            #print(res)
        return res.lower()

number = 125
if __name__ == "__main__":
    print(Solution().convertWords( number))            
        
#689. Two Sum IV - Input is a BST                        
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""

class Solution:
    """
    @param: : the root of tree
    @param: : the target sum
    @return: two numbers from tree which sum is n
    """

    def twoSum(self, root, n):
        # write your code here 
        self.table=set()
        
        def inorder(node,n,res,setval):
            if not node:
                return 
            inorder(node.left,n,res,setval | set([node.val]))
            if n-node.val in setval:
                res.append(node.val)
                res.append(n-node.val)
            inorder(node.right,n,res,setval | set([node.val]))
        res=[]
        
        
        inorder(root,n,res,set())
        #print(res)
        return res[:2] if res else None
            
root=  TreeNode(4)     
root.left=  TreeNode(2)
root.right=  TreeNode(5)
root.left.left=  TreeNode(1)
root.left.right=  TreeNode(3)     
 
n = 3
#[1, 2] or [2, 1]                    
#    4
#   / \
#  2   5
# / \
#1   3            
if __name__ == "__main__":
    print(Solution().twoSum(root, n))            
                   
        
        
        
        
#690. Factorial
class Solution:
    """
    @param n: an integer
    @return:  the factorial of n
    """
    def factorial(self, n):
        # write your code here
#https://blog.csdn.net/zhaohengchuan/article/details/78590395
        
        res=[0  for _ in range(5800)]
        
        res[0]=1
        digit=1
        
        for i in range(2,n+1):
            carry=0
            for j in range(digit):
                num=res[j]*i+carry
                #print(res,num)
                res[j]=num%10
                carry=num//10
            while carry:
                res[digit]=carry%10
                carry=carry//10
                digit+=1
   
        start=False
        res2=''
        for  k in range(5800) :
            if start:
                res2+=str(res[5800-k-1])
                continue
                
            if  not start and res[5800-k-1]:
                start=True
                res2+=str(res[5800-k-1])
        
        return res2
n = 2000
if __name__ == "__main__":
    print(Solution().factorial( n))   


#691. Recover Binary Search Tree        
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""

class Solution:
    """
    @param root: the given tree
    @return: the tree after swapping
    """
    def bstSwappedNode(self, root):
        # write your code here
        self.prev=TreeNode(float('-inf'))
        self.first=None
        self.second=None
        
        def tranverse(root):
            if not root:
                return 
            tranverse(root.left)
            if not self.first  and self.prev.val>root.val:
                self.first=self.prev
            if self.first  and self.prev.val>root.val:
                self.second=root
            self.prev=root
            tranverse(root.right)
        
        tranverse(root)
        
        if self.second  and self.first:
        
             self.second.val,self.first.val =self.first.val ,self.second.val
        return root

            
#https://leetcode.com/problems/recover-binary-search-tree/discuss/32559/Detail-Explain-about-How-Morris-Traversal-Finds-two-Incorrect-Pointer            
#http://www.cnblogs.com/AnnieKim/archive/2013/06/15/morristraversal.html            
class Solution:
    """
    @param root: the given tree
    @return: the tree after swapping
    """
    def bstSwappedNode(self, root):
        self.prev=None
        self.first=None
        self.second=None
        
        def moristranverse(root):
            if not root:
                return 
            temp=None
            while root:
                if root.left:
                    temp=root.left
                    while temp.right and temp.right!=root:
                         temp=temp.right
                    if temp.right:
                        temp.right=None
                        print(root.val)
                        if self.prev and self.prev.val>root.val:
                            if not self.first:
                                self.first=self.prev
                                self.second=root
                            else:
                                self.second=root
                        self.prev=root
                        root=root.right
                    else:
                        temp.right=root
                        root=root.left
                else:
                    print(root.val)
                    if self.prev and self.prev.val>root.val:
                            if not self.first:
                                self.first=self.prev
                                self.second=root
                            else:
                                self.second=root
                    self.prev=root
                    root=root.right
        moristranverse(root)
        if self.second  and self.first:
               self.second.val,self.first.val =self.first.val ,self.second.val
        return root               
                
#692. Sliding Window Unique Elements Sum
class Solution:
    """
    @param nums: the given array
    @param k: the window size
    @return: the sum of the count of unique elements in each window
    """
    def slidingWindowUniqueElementsSum(self, nums, k):
        # write your code here
        if not nums :
            return 0
        if not k:
            return 0
        n=len(nums)
        from collections import Counter
        res=0
        count={}
        ans=0
        if k>=n:
            count=Counter(nums)
            
            for key,v in count.items():
                if v==1:
                    res+=1
            return res
        
        else:
            for i in range( k ,n+1):
                if not count:
                   count=Counter(nums[i-k:i])
                   
                   for key,v in count.items():
                       if v==1:
                          res+=1
                   #print(count,res)
                   ans+=res
                else:
                    
                    if nums[i-k-1]==nums[i-1]:
                        ans+=res
                        continue
                        
                    if count[nums[i-k-1]]==2  and nums[i-k-1]!=nums[i-1]:
                        res+=1
                    elif count[nums[i-k-1]]==1:
                        #print(count,count[nums[i-k-1]])
                        res-=1
                    #print(res)
                    count[nums[i-k-1]]-=1
                    
                    if nums[i-1] in count:
                        if count[nums[i-1]]==1 :
                            #print(count,count[nums[i-1]])
                            res-=1
                        count[nums[i-1]]+=1
                        
                    else:
                        count[nums[i-1]]=1
                    if count[nums[i-1]]==1:
                        res+=1
                    #print(res)
                    ans+=res
        return ans
                        
nums = [1, 2, 1, 3, 3] 
k = 3   
nums = [1,1,1,1,1]
k =2 
nums =[27,14,60,87,37,53,100,18,51,37,14,57,22,95,50,83,41,43,36,48,52,97,16,46,75,24,47,13,40,40,48,45,56,58,77,3,78,60,31,27,40,53,57,29,30,65,37,77,1,40,89,100,50,49,100,51,22,66,33,33,70,36,64,70,11,27,57,77,17,28,62,70,32,88,12,47,69,30,93,3,47,69,64,88,7,40,38,5,23,4,58,97,19,55,17,23]
k =21                
if __name__ == "__main__":
    print(Solution().slidingWindowUniqueElementsSum( nums, k))   
                 
#696. Course Schedule III
class Solution:
    """
    @param courses: duration and close day of each course
    @return: the maximal number of courses that can be taken
    """
    def scheduleCourse(self, courses):
        # write your code here
        if not courses or len(courses)==0:
            return 0
        start=0
        import heapq
        pq=[]
        for t, end  in sorted(courses,key=lambda x: x[1] ):
        #for t, end in sorted(courses, key = lambda (t, end): end):
            start+=t
            heapq.heappush(pq,-t)
            while start >end:
                start+=heapq.heappop(pq)
        return len(pq)
            
courses=[[100, 200], [200, 1300], [1000, 1250], [2000, 3200]]            
if __name__ == "__main__":
    print(Solution().scheduleCourse(courses))            
        
        
#697. Sum of Square Numbers
class Solution:
    """
    @param num: the given number
    @return: whether whether there're two integers
    """
    def checkSumOfSquareNumbers(self, num):
        # write your code here
        if num<0:
            return False
        import math
        
        cutoff= math.ceil( num**0.5)
        
        hashset=set()
        
        for i in range(cutoff+1):
            hashset.add(i*i)
            if num-i*i in hashset:
                return True
        return False
            
        
        
#698. Maximum Distance in Arrays        
class Solution:
    """
    @param arrs: an array of arrays
    @return: return the max distance among arrays
    """
    def maxDiff(self, arrs):
        # write your code here
        l=[]
        import heapq
        start=[]
        end=[]
        for i,x in enumerate(arrs):
            heapq.heappush(start,(x[0],i))
            heapq.heappush(end,(-x[1],i))
        s,si=heapq.heappop(start)
        e,ei=heapq.heappop(end)
        if si!=ei:
            return abs(s+e)
        else:
            s2,si2=heapq.heappop(start)
            e2,ei2=heapq.heappop(end)
            return max(abs(s2+e),abs(e2+s) )
            
arrs = [[1,2,3], [4,5], [1,2,3]]
arrs = [[2,3,4,5,6,7,8,9],[1,10],[-1,200]]
if __name__ == "__main__":
    print(Solution().maxDiff( arrs))             
        
#699. Check Sum of K Primes        
class Solution:
    """
    @param n: an int
    @param k: an int
    @return: if N can be expressed in the form of sum of K primes, return true; otherwise, return false.
    """
    def isSumOfKPrimes(self, n, k):
        # write your code here
        
        def isPrime(n):
            import math
            if n in (2,3,5,7):
                return True
           
            if n in (4,6,8,9):
                return False
            for i in range(2,  int(math.ceil(n**0.5))+1):
                if n%i==0:
                    return False
            return True
        if n<k*2 or k<1:
            return False
        if k==1:
            return isPrime(n)
        if k==2:
            
            if n%2==0:
                return True
            return isPrime(n-2)
        return True
        
        
#        if n<2:
#            return False
#        if n ==2:
#           primes=set([2])
#        elif n ==3 or n ==4:
#           primes=set([2,3])
#        elif n==5 :
#            primes=set([2,3,5])
#        else:
#            primes=set([2,3,5])
#            for i in range(6,n+1):
#                if isPrime(i):
#                    primes.add(i)
#        dp=[False for _ in range(n+1)]    
#        dp[0]=True        
#        for _ in range(k):
#            temp=[False for _ in range(n+1)] 
#            for x in primes:
#                for y in range(n+1):
#                    if dp[y]==True  and x+y<n+1:
#                        temp[x+y]=True
#            dp=temp
#            
        
n = 10
k = 2
n = 2
k = 2
n =888450280
k =444225140
if __name__ == "__main__":
    print(Solution().isSumOfKPrimes( n, k))             
                        
            
            
#700. Cutting a Rod                    
class Solution:
    """
    @param prices: the prices
    @param n: the length of rod
    @return: the max value
    """
    def cutting(self, prices, n):
        # Write your code here
        prices=[0]+prices
        memo={}
        def cut(prices,k):
            if k in memo:
                return memo[k]
            if k==0:
                memo[0]=0
                return 0
            if k==1:
                memo[1]=prices[1]
                return prices[1]
            if k==2:
                memo[2]=max(prices[1]*2,prices[2])
                return max(prices[1]*2,prices[2])
            res=0
            temp=0
            for i in range(1,k+1):
                
                temp=prices[i]+cut(prices,k-i)
                res=max(res,temp)
            memo[k]=res
            return res
        return cut(prices, n)
prices=[3,5,8,9,10,17,17,20]
n=8
prices= [1, 5, 8, 9, 10, 17, 17, 20]
n=8                    
if __name__ == "__main__":
    print(Solution().cutting(prices, n))                      
                
        
#701. Trim a Binary Search Tree
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""

class Solution:
    """
    @param root: given BST
    @param minimum: the lower limit
    @param maximum: the upper limit
    @return: the root of the new tree 
    """
    def trimBST(self, root, minimum, maximum):
        # write your code here
        def trim(node):
            if not node:
                return 
            if node.val>maximum:
                return trim(node.left)
            elif node.val<minimum:
                return trim(node.right)
            else:
                node.left=trim(node.left)
                node.right=trim(node.right)
            return node
        return trim(root)



#702. Concatenated String with Uncommon Characters of Two Strings
class Solution:
    """
    @param s1: the 1st string
    @param s2: the 2nd string
    @return: uncommon characters of given strings
    """
    def concatenetedString(self, s1, s2):
        # write your code here
        if not s1:
            return s2
        if not s2 :
            return s1
        
        res=''
        
        for s in s1:
            if s not in s2:
                res+=s
        for s in s2:
            if s not in s1:
                res+=s
        return res



#703. Folding Array
class Solution:
    """
    @param nums: the original array
    @param req: the direction each time
    @return: the final folded array 
    """
    def folding(self, nums, req):
        # write your code here
#https://github.com/jiadaizhao/LintCode/blob/master/0703-Folding%20Array/0703-Folding%20Array.cpp        
        n=len(nums)
        l=n//2
        for i in range(len(req)):
            res=[0 for _ in range(n)]
            if req[i]==0:
                k=0
                for j in range(n//2-1,-1,-1):
                    res[j]=nums[k]
                    k+=1
                    if k%l==0:
                        k+=l
                k=l
                for j in range(n//2,n):
                    res[j]=nums[k]
                    k+=1
                    if k%l==0:
                        k+=l
            else:
              k=n-1
              for j in range(n//2):
                res[j]=nums[k]
                k-=1
                if (k+1)%l==0:
                    k-=l
              k=0
              for j in range(n//2,n):
                res[j]=nums[k]
                k+=1
                if (k)%l==0:
                    k+=l
            l//=2
            nums[:]=res[:]
        return res
                    
#req[i] = 0            
#1 2 3 4 5 6 7 8  ==>   4 3 2 1
#                       5 6 7 8  
#If req[i] = 1
#1 2 3 4 5 6 7 8  ==>   8 7 6 5
#                       1 2 3 4                       
#                       
#fold from left to right
#4 3 2 1  ==>  6 5
#5 6 7 8       3 4
#              2 1
#              7 8                       
nums = [1, 2, 3, 4, 5, 6, 7, 8]
req = [0, 0, 1]                       
if __name__ == "__main__":
    print(Solution().folding( nums, req))                      
                                       
#704. Bulb Switcher II
class Solution:
    """
    @param n: number of lights
    @param m: number of operations
    @return: the number of status
    """
    def flipLights(self, n, m):
        # write your code here
                       
#https://leetcode.com/problems/bulb-switcher-ii/discuss/107267/Python-Straightforward-with-Explanation                       
#As before, the first 6 lights uniquely determine the rest of the lights.
# This is because every operation that modifies the xx-th light also modifies 
# the (x+6)(x+6)-th light, so the xx-th light is always equal to the
# (x+6)(x+6)-th light.
#
#Actually, the first 3 lights uniquely determine the rest of the sequence,
# as shown by the table below for performing the operations a, b, c, d:
#
#Light 1 = 1 + a + c + d
#Light 2 = 1 + a + b
#Light 3 = 1 + a + c
#Light 4 = 1 + a + b + d
#Light 5 = 1 + a + c
#Light 6 = 1 + a + b
#So that (modulo 2):
#
#Light 4 = (Light 1) + (Light 2) + (Light 3)
#Light 5 = Light 3
#Light 6 = Light 2                       
        import itertools
        seen=set()
        for cand in  itertools.product((0,1),repeat=4):
              print(cand)
              
              if sum(cand)%2==m%2 and sum(cand)<=m:
                  A=[]
                  for i in range(min(n,3)):
                      light=1
                      light^=cand[0]
                      if i%2==0 :
                         light^=cand[1] 
                      if i%2==1:  
                         light^=cand[2]
                      if i%3==0:#0 index
                         light^=cand[3]
                      A.append(light)
                  seen.add(tuple(A))
        return len(seen)
n=5
m=5
if __name__ == "__main__":
    print(Solution().flipLights( n, m))                      
                                               
#706. Binary Watch
    
class Solution:
    """
    @param num: the number of "1"s on a given timetable
    @return: all possible time
    """
    def binaryTime(self, num):
        # Write your code here
#hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59)
        from collections import defaultdict
        res=[]
        if num==0:
            return ["0:00"]
        
        gethour=defaultdict(list)
        getmin=defaultdict(list)
        hourList=['0',"1", "2", "3", "4","5", "6","7", "8","9", "10","11"]   
        minList=['00',"01", "02", "03", "04","05", "06","07", "08","09", "10",
                    "11", "12", "13", "14","15", "16","17", "18","19", "20",
                    "21", "22", "23", "24","25", "26","27", "28","29", "30",
                    "31", "32", "33", "34","35", "36","37", "38","39", "40",
                    "41", "42", "43", "44","45", "46","47", "48","49", "50",
                    "51", "52", "53", "54","55", "56","57", "58","59" ]
        for i in range(12):
                gethour[bin(i)[2:].count('1')].append(i)
        for j in range(60):
                getmin[bin(j)[2:].count('1')].append(j)
        print(gethour)
        print(getmin)
        for hour in range(num+1):
            minute=num-hour
            if hour not in gethour  or minute  not in getmin:
                continue
            
            for h in gethour[hour]:
                for m in getmin[minute]:
                    
                    res.append(hourList[h]+':'+minList[m])
        return res
num=1   
num=0 
num=5            
if __name__ == "__main__":
    print(Solution().binaryTime( num))                
                
#707. Optimal Account Balancing  
#这题未作出，need to re do  
#/**************************************************************************************/
#/**************************************************************************************/
#/**************************************************************************************/
#/**************************************************************************************/
#/**************************************************************************************/
#/**************************************************************************************/
#/**************************************************************************************/         

class Solution:
    """
    @param edges: a directed graph where each edge is represented by a tuple
    @return: the number of edges
    """
    def balanceGraph(self, edges):
        # Write your code here
#https://github.com/kamyu104/LeetCode/blob/master/Python/optimal-account-balancing.py
#https://blog.csdn.net/magicbean2/article/details/78582544
#            http://www.cnblogs.com/grandyang/p/6108158.html
#        https://liumingzhang.gitbooks.io/google-questions/optimal_account_balancing.html
#        from collections import defaultdict
#        graph=defaultdict(int)
#        
#        for u,v,w in edges:
#            graph[u]-=w
#            graph[v]+=w
#        account=[]
#        n=0
#        for k,v in graph.items():
#            if v !=0:
#               account.append(v)
#               n+=1
#        memo={}
#        def dfs(account,start,length,cnt,memo):
#            if (tuple(account) , start) in memo:
#                return  memo[(tuple(account) , start)]
#            while start<length and account[start]==0:
#                start+=1
#            res=float('inf')
#            for i in range(start+1,length):
#                if account[start]*account[i]<0:
#                   account[i]+=account[start]
#                   res=min(res,dfs(account,start+1,length,cnt+1,memo))
#                   account[i]-=account[start]
#            memo[(tuple(account) , start)]=res if res!=float('inf') else cnt
#                   
#            return res if res!=float('inf') else cnt
#        return dfs(account,0,n,0,memo)
    
    
        from collections import defaultdict
        graph=defaultdict(int)
        
        for u,v,w in edges:
            graph[u]-=w
            graph[v]+=w
        account=[]
      
        for k,v in graph.items():
            if v !=0:
               account.append(v)
          
        n=1<<len(account)
        dp=[float('inf') for _ in range(n)]
        subset=[]
        if len(account)==0:
            return 0
        for i in range(1,n):
            new_debt=0
            number=0
            for j in range(len(account)):
                if i & 1<<j:#take some random combinations of pairs 
                    new_debt+=account[j]
                    number+=1
            if new_debt==0:
                number-=1
                dp[i]=number
                for s in subset:
                    if (i&s) ==s:#  i&(i-s)==i-s
                        dp[i]=min(dp[i],dp[s]+dp[i-s])# s可以使net_debt  所以i - s 可以使其余的为0，因为总和是0
            subset.append(i)
        return dp[-1]
                    
                    
    
    
   
        
 
edges=[[0,1,10],[2,0,5]]
edges=[[0,1,10],[1,0,1],[1,2,5],[2,0,5]] 
edges=[[7,9,1],[9,8,59],[4,0,46],[7,6,92],[7,6,92],[2,3,93],[1,3,96],[6,8,70],[2,4,36],[3,1,23],[8,9,42],[8,7,45],[2,4,24],[9,8,17],[5,7,89],[0,2,65],[1,0,91],[5,6,2],[8,9,24],[4,1,41]]                 
edges=[[16,15,1],[9,11,59],[0,1,46],[14,15,92],[16,11,37],[14,13,54],[6,5,17],[7,6,72],[5,0,68],[15,11,4],[10,11,74],[5,7,54],[3,4,63],[11,15,24],[15,12,17],[13,14,89],[0,6,65],[6,5,91],[15,13,7],[11,10,30]]                
if __name__ == "__main__":
    print(Solution().balanceGraph( edges))                         
                       
                       
#717. Tree Longest Path With Same Value        
class Solution:
    """
    @param A: as indicated in the description
    @param E: as indicated in the description
    @return: Return the number of edges on the longest path with same value.
    """
    def LongestPathWithSameValue(self, A, E):
        # write your code here
        from collections import defaultdict
#https://github.com/jiadaizhao/LintCode/blob/master/0717-Tree%20Longest%20Path%20With%20Same%20Value/0717-Tree%20Longest%20Path%20With%20Same%20Value.cpp
        #不要用 visited， 只要 cur != prev排除重复检测。 
        graph=defaultdict(list)
        
        for i in range(0,len(E),2):
            graph[E[i]].append(E[i+1])
            graph[E[i+1]].append(E[i])
        print(graph)    
   
        self.visited=set()
    
        A=[0]+A
        def dfs(node,graph,prev):
            if not node :
                return 0
            res=0
         
            for next_node in graph[node]:
                if next_node !=prev:
                    
                    if A[node]==A[next_node]:
                        
                        
                        temp1=1+dfs(next_node,graph,node)
                        if temp1>res:
                           
                           res=temp1
                        
                        print('node',node, 'next_node',next_node, 'res',res)
            
            return res
        ans=0
        prev=0
        for x in range(1,len(A)):
            
                first=0
                second=0
                
                for nei in graph[x]:
                    print('x',x, 'nei',nei)
                    if A[nei] ==A[x]:
                        
                        temp =1+dfs(nei,graph,x)
                        if temp>first:
                            second=first
                            first=temp
                            
                        elif temp>second:
                            second=temp
                        print('first',first ,'second',second)   
                ans=max(ans,first+second)
                            
                            
        return ans
            
 
A = [1, 1, 1 ,2, 2,1,1] 
E =  [1, 2, 1, 3, 2, 4, 2, 5,3,6,6,7]
A = [1, 1, 1 ,2, 2] 
E =  [1, 2, 1, 3, 2, 4, 2, 5]
A =[1,1,1,1,1]
E =[1,2,1,3,2,4,2,5]

                   1 （value = 1）
                 /   \
    (value = 1) 2     3 (value = 1)
               /  \
 (value = 2)  4     5 (value = 2)

if __name__ == "__main__":
    print(Solution().LongestPathWithSameValue( A, E))

class Solution:
    """
    @param A: string A to be repeated
    @param B: string B
    @return: the minimum number of times A has to be repeated
    """
    def repeatedString(self, A, B):
        # write your code here
        na=len(A)
        nb=len(B)
        if na==0:
            return -1
        if nb==0:
            return 0
        
        if B in A:
            return 1
        
        i=2
        while i*na <nb*2:
               
            x=A*i
            if B in x:
                return i
            i+=1
        return -1
      
            
A = 'abcd'
B = 'cdabcdab'

if __name__ == "__main__":
    print(Solution().repeatedString( A, B))



#719. Calculate Maximum Value
class Solution:
    """
    @param str: the given string
    @return: the maximum value
    """
    def calcMaxValue(self, str):
        # write your code here
        if not str:
            return 0
        
        s=str[::-1]
        self.res=0
        
        def decomposite(s):
            if len(s)==0:
                return 0
            if s[0]=='0':
                  return decomposite(s[1:])
            elif s[0]=='1':
                return decomposite(s[1:])+1
            else:
                return max(decomposite(s[1:])+int(s[0]),decomposite(s[1:])*int(s[0]))
            
        return decomposite(s)
str='891'  
str='01231'              
if __name__ == "__main__":
    print(Solution().calcMaxValue(str))
        
#720. Rearrange a String With Integers
class Solution:
    """
    @param str: a string containing uppercase alphabets and integer digits
    @return: the alphabets in the order followed by the sum of digits
    """
    def rearrange(self, string):
        # Write your code here
        if not string:
           return ''
        temp=0
        res=[]
        for x in string:
            if x.isdigit():
                temp+=int(x)
            else:
                res.append(x)
        res.sort()
        return ''.join(res)+str(temp)
                
        
#721. Next Sparse Number            
class Solution:
    """
    @param x: a number
    @return: return the next sparse number behind x
    """
    def nextSparseNum(self, x):
        # write your code here
        
        
#'0b10100010110010001001100110011'            
#'0b10100100000000000000000000000'
        if '11' not in bin(x):
            return x
        def add11(s):
            n=len(s)
            
            for i in range(n-1):
                if s[i:i+2]=='11':
                    break
            if i==0:
                return '1'+'0'*n
            else:
                return s[:i-1]+'1'+'0'*(n-i)
        cur=bin(x)[2:]
        while '11'  in cur:
            
             cur=add11(cur)
        return int(cur,2)

x=341381939
x=6
x=4
x=38
#return 343932928
if __name__ == "__main__":
    print(Solution().nextSparseNum(x))

#723. Rotate Bits - Left
class Solution:
    """
    @param n: a number
    @param d: digit needed to be rorated
    @return: a number
    """
    def leftRotate(self, n, d):
        # write code here
        
        s=bin(n)[2:]
        m=len(s)
        if m<32:
            s='0'*(32-m)+s
        return int( s[d:]+s[:d],2)
if __name__ == "__main__":
    print(Solution().leftRotate( n, d))
        
#724. Minimum Partition
class Solution:
    """
    @param nums: the given array
    @return: the minimum difference between their sums 
    """
    def findMin(self, nums):
        # write your code here
#        n=len(nums)
#        if n==1 :
#            return nums[0]
#        if n==2:
#            return abs(nums[0]-nums[1])
#        sm=sum(nums)
#        nums.sort()   
#        self.res=float('inf')
#        def select(nums,path):
#            if abs(sm/2-path)==0:
#                self.res=0
#                return 
#            if abs(sm-2*path)<self.res:
#                self.res=abs(sm-2*path)
#            for i in range(len(nums)):
#                if path+nums[i]<=sm/2:
#                    select(nums[:i]+nums[i+1:],path+nums[i])
#        select(nums,0)
#        return self.res
        n=len(nums)
        sm=sum(nums)
        if n==1 :
           return nums[0]
        if n==2:
            return abs(nums[0]-nums[1])
        sm=sum(nums)
        dp=[0 for _ in range(sm//2+1)]
        dp[0]=True
        for num in nums:
            for j in range(sm//2,num-1,-1):
                dp[j]=dp[j] or dp[j-num]
        for i in range(sm//2,-1,-1):
            if dp[i]:
                return abs(2*i-sm)
nums=[911,72,268,540,441,328,822,618,132,553,673,189,280,365,157,769,467]
nums = [1, 6, 11,5]
if __name__ == "__main__":
    print(Solution().findMin(nums))
                        
#725. Boolean Parenthesization        
class Solution:
    """
    @param symb: the array of symbols
    @param oper: the array of operators
    @return: the number of ways
    """
    def countParenth(self, symb, oper):
        # write your code here
#        slist=[] # 有重复计算
#        oper=list(oper)
#        for s in symb:
#            if s=='F':
#                slist.append(0)
#            else:
#                slist.append(1)
#        self.res=0
#        def cal(slist,olist):
#            if len(olist)==1:
#                print(slist,olist)
#                if olist[0]=='^':
#                   ans= slist[0] ^ slist[1]
#                elif olist[0]=='&':
#                   ans= slist[0] & slist[1]
#                else:
#                   ans= slist[0] | slist[1]
#                if ans==1:
#                    self.res+=1
#                return 
#            else:
#                for i in range(len(olist)):
#                    print(slist,olist,i)
#                    if olist[i]=='^':
#                       temp=slist[i] ^ slist[i+1]
#                    elif olist[i]=='&':
#                       temp=slist[i] & slist[i+1]
#                       #print(temp,slist[i],slist[i+1])
#                    else:
#                       temp=slist[i] | slist[i+1]
#                    cal(slist[:i]+[temp]+slist[i+2:] ,olist[:i]+olist[i+1:])
#        cal(slist,oper)
#        return self.res
        n=len(symb)
        T=[[0 for _ in range(n)] for _ in range(n)]
        F=[[0 for _ in range(n)] for _ in range(n)]
        
        
        
        for i in range(n):
            if symb[i]=='T':
                T[i][i]=1
            else:
                F[i][i]=1
        
        for j in range(n):
            for i in range(j-1,-1,-1):
                T[i][j]=0
                F[i][j]=0
                for k in range(i,j):
                    if oper[k]=='&':
                         T[i][j]+=T[i][k]*T[k+1][j]
                         F[i][j]+=(T[i][k]+F[i][k])*(T[k+1][j]+F[k+1][j])-T[i][k]*T[k+1][j]
                    elif oper[k]=='|':
                         T[i][j]+=(T[i][k]+F[i][k])*(T[k+1][j]+F[k+1][j])-F[i][k]*F[k+1][j]
                         F[i][j]+=F[i][k]*F[k+1][j]
                    else:
                         T[i][j]+=T[i][k]*F[k+1][j]+F[i][k]*T[k+1][j]
                         F[i][j]+=F[i][k]*F[k+1][j]+T[i][k]*T[k+1][j]
        #print(T)
        return T[0][n-1]
symb = ['T', 'F', 'T']
oper = ['^', '&']
symb = ['T', 'F', 'F']
oper = ['^', '|']
symb ="TFFF"
oper ="^|&"        
if __name__ == "__main__":
    print(Solution().countParenth(symb, oper))
                                
#726. Check Full Binary Tree
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""

class Solution:
    """
    @param root: the given tree
    @return: Whether it is a full tree
    """
    def isFullTree(self, root):
        # write your code here
        from collections import deque
        
        if not root:
            return True
        
        dq=deque([root])
        
        while dq:
              node=dq.popleft()
              if (not node.left  and not node.right):
                  continue
              if (not node.left  and node.right)  or (not node.right  and node.left):
                 return False
              dq.append(node.left)
              dq.append(node.right)
              
        return True
        
#727. Chinese Remainder Theorem            
class Solution:
    """
    @param num: the given array
    @param rem: another given array
    @return: The minimum positive number of conditions to meet the conditions
    """
    def remainderTheorem(self, num, rem):
        # write your code here
#https://zh.wikipedia.org/wiki/模反元素
#https://zh.wikipedia.org/wiki/扩展欧几里得算法
        def exd_euclid(a,b):
            if b==0:
                return (1 ,0 , a)
            
            else:
                x,y,q=exd_euclid(b,a%b)#q = gcd(a, b) = gcd(b, a%b)
                x,y=y,x-a//b*y
                return x,y,q
        from functools import reduce 
        modulus=reduce(lambda a,b: a*b,num)
        
        mutiplier=[]
        for mi in num:
            Mi=modulus//mi
            inverse,y,gcd=exd_euclid(Mi,mi)
            mutiplier.append(inverse*Mi%modulus)
        res=0
        for multi, ai in zip(mutiplier,rem):
            res+=multi*ai
        return res%modulus
            
           
                
                
num=[3,4,5]
rem=[2,3,1]    
num=[41,5,23,29,3,2,31,11,7]
rem=[16,4,14,11,2,1,8,1,2]        
if __name__ == "__main__":
    print(Solution().remainderTheorem( num, rem))
        
            
#728. Three Distinct Factors
class Solution:
    """
    @param n: the given number
    @return:  return true if it has exactly three distinct factors, otherwise false
    """
    def isThreeDisctFactors(self, n):
        # write your code here
        
        if n==1 or n==2 :
            return False
        lo=3
        hi=n
        lo=2
        def isPrime(n):
            import math
            if n in (2,3,5,7):
                return True
           
            if n in (4,6,8,9):
                return False
            for i in range(2,  int(math.ceil(n**0.5))+1):
                if n%i==0:
                    return False
            return True
        while lo < hi:
            mid=(lo+hi)//2
            #print(lo,hi,mid)
            if mid*mid==n:
                return isPrime(mid)
            elif mid*mid >n:
                hi=mid-1
            else:
                lo=mid+1
            #print(lo,hi,mid)
        
        
            
        return lo*lo==n and isPrime(lo)
            
            
n=755246849567941769
n=9   
n=550220950190521  
n=10000       
if __name__ == "__main__":
    print(Solution().isThreeDisctFactors( n))            
        
        
#729. Last Digit By Factorial Divide        
class Solution:
    """
    @param A: the given number
    @param B: another number
    @return: the last digit of B! / A! 
    """
    def computeLastDigit(self, A, B):
        # write your code here
        
        if A==B:
            return 1
        if B-A>=5:
            return 0
        res=1
        while B>A:
            res*=B%10
            B=B-1
        return res%10
            
#730. Sum of All Subsets        
class Solution:
    """
    @param n: the given number
    @return: Sum of elements in subsets
    """
    def subSum(self, n):
        # write your code here
        
        return sum(range(1,n+1))**2(n-1)

        
        

#734. Number of Subsequences of Form a^i b^j c^k        
class Solution:
    """
    @param source: the input string
    @return: the number of subsequences 
    """
    def countSubsequences(self, source):
        # write your code here
#他博客里讲的可能比较简略点但大概意思传达到了这里写一下我自己的理解。首先要明确一个思路就是说
#比如当以字符‘c’结尾时有多少种情况是取决于这个c之前的以c结尾的组合数和以b结尾的组合数，当以b
#结尾时有多少种情况取决于这个b之前的以b结尾的组合数和以a结尾的组合数，当以a结尾时有多少种情况则
#仅仅取决于这个a之前的以a结尾的组合数，注意这里说以a结尾或者以b结尾的意思并不是真正的结尾，因为
#结尾一定要以c，这里结尾的意思就是判断到这一位的时候。 
#然后我们设以a结尾的组合数为Sa，以b结尾的组合数为Sb，以c结尾的组合数为Sc，那么这里就有三个层层
#递进的关系了： 
#1. Sa => Sa 
#2. Sa , Sb => Sb 
#3. Sb, Sc => Sc 
#我们最后要得到的答案其实就是Sc。 
#然后接下仔细分析下这三个关系式的具体实现： 
#1. Sa => Sa 
#假设一个a前面的以a结尾的组合数为x，那么又来了个a，这个x会变成多少？答案是2x+1，这个2x+1可以
#其实可以看成 x+x+1，第一份x就是原来的x，即无视掉这个新来的a，第二份x就是对原来的x个组合后面都
#加上这个新来的a，最后那个1就是忽略掉前面的a，只用新来的这个a，即字符串’a’。 当然这个2x+1
#也是可以严格计算出来的，假设新的a之前出现过n个字符a，那么x应该等于 2^n-1，那算是这个
#新来的a之后就出现了n+1个a，那组合数应该就等于 2^(n+1)-1。即x = 2^n-1，设ax+b = 2^(n+1)-1,
#就可以计算出a=2，b=1。 
#2. Sa, Sb => Sb 
#假设这时候来了个新的b，这个b前面以a结尾的组合数为Sa，以b结尾的组合数为Sb，那如何去更新Sb的值？
#很显然 Sb = Sa + 2 * Sb，我们可以再把这个分开来看成 Sb = Sa + Sb + Sb，第一份Sa就是在所有
#以a结尾的组合后面跟上这个新来的b，第二份Sb可以看成在 所有以b结尾的组合后面跟上这个b，第三份
#Sb可以看成直接取所有以b结尾的组合，把新的b不要了。 
#3. Sb, Sc => Sc 
#这个道理跟2一样，同理可得Sc = Sb + 2 * Sc        
        n=len(source)
        a=0
        b=0
        c=0
        
        
        for i in range(n):
            if source[i]=='a':
                a=a+a+1
            elif source[i]=='b':
                b=a+b+b
            else:
                c=b+c+c
        return c
                
#735. Replace With Greatest From Right
class Solution:
    """
    @param nums: An array of integers.
    @return: nothing
    """
    def arrayReplaceWithGreatestFromRight(self, nums):
        # Write your code here.



        n=len(nums)
        maxdict={}
        if n==1:
            return [-1]
        curmax=nums[-1]
        nums[-1]=-1
        for i in range(n-2,-1,-1):
            temp=nums[i]
            nums[i]=curmax
            if curmax<temp:
                curmax=temp
        print(nums)
            
nums=[16, 17, 4, 3, 5, 2]                
#[17, 5, 5, 5, 2, -1]        
if __name__ == "__main__":
    print(Solution().arrayReplaceWithGreatestFromRight( nums))            
                
        
#737. Find Elements in Matrix
class Solution:
    """
    @param Matrix: the input
    @return: the element which appears every row
    """
    def FindElements(self, Matrix):
        # write your code here
        one=set(Matrix[0])
        for row in Matrix[1:]:
            rowset=set(row)
            one=rowset & one
            if len(one)==1:
                return list(one)[0]
        
Matrix= [
  [2,5,3],
  [3,2,1],
  [1,3,5]
]   
Matrix=[[1],[1],[1]]    
if __name__ == "__main__":
    print(Solution().FindElements(Matrix))         
        
        
        
#738. Count Different Palindromic Subsequences        
class Solution:
    """
    @param str: a string S
    @return: the number of different non-empty palindromic subsequences in S
    """
    def countPalindSubseq(self, str):
        # write your code here
#https://leetcode.com/problems/count-different-palindromic-subsequences/discuss/109507/Java-96ms-DP-Solution-with-Detailed-Explanation
        n=len(str)
        dp=[[0 for _ in range(n)] for _ in range(n)]
        
        for k in range(n):
            dp[k][k]=1
        
        for L in range(1,n):
            for i in range(0,n-L):
                j=i+L
                if str[i]!=str[j]:
                    dp[i][j]=dp[i+1][j]+dp[i][j-1]-dp[i+1][j-1]
                else:
                    low=i+1
                    high=j-1
                    
                    while low<=high  and str[low]!=str[i]:
                        low+=1
                    while low<=high  and str[high]!=str[i]:
                        high-=1
                    
                    if low>high:
                        dp[i][j]=dp[i+1][j-1]*2+2
                    elif low==high:
                        dp[i][j]=dp[i+1][j-1]*2+1
                    else:
                        dp[i][j]=dp[i+1][j-1]*2-dp[low+1][high-1]
        return dp[0][n-1]% (10**9 + 7)
    
str='bccb'
str='abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba'
str="aacaa"
if __name__ == "__main__":
    print(Solution().countPalindSubseq(str))                           
                        
#739. 24 Game
class Solution:
    """
    @param nums: 4 cards
    @return: whether they could get the value of 24
    """
    def compute24(self, nums):
        # write your code here
        from fractions import Fraction
        
        def compute(array ):
            n=len(array)
            #print(array)
            if n==1:
                if array[0]==24:
                    return True
                return False
               
           
            for i in range(n-1):
                temp1=array[i]+array[i+1]
                temp2=array[i]-array[i+1]
                temp3=array[i]*array[i+1]
                if array[i+1]:
                   temp4=Fraction( array[i], array[i+1]) 
                   if compute(array[:i] +[temp4]+array[i+2:]):
                      return True
                   
                if compute(array[:i] +[temp1]+array[i+2:]):
                    return True
                if compute(array[:i] +[temp2]+array[i+2:]):
                    return True
                if compute(array[:i] +[temp3]+array[i+2:]):
                    return True
            return False
        nums.sort()
        def permute(nums,path,res):
            if not nums:
                res.append(path[:]) 
            
            for i in range(len(nums)):
                if i>0 and nums[i]==nums[i-1]:
                    continue
                permute(nums[:i]+nums[i+1:],path+[nums[i]],res)
        res=[]
        permute(nums,[],res)
        return any([compute(nums )  for nums in res])
nums = [4, 1, 8, 7]
nums = [8, 7,4,1] # return true // 8 * （7 - 4） * 1 = 24
nums = [1, 1, 1, 2]# return false
nums = [3, 3, 8, 8]# return true // 8 / ( 3 - 8 / 3) = 24 
nums = [8, 3, 8, 3]               
if __name__ == "__main__":
    print(Solution().compute24( nums))     
                            
#740. Coin Change 2
class Solution:
    """
    @param amount: a total amount of money amount
    @param coins: the denomination of each coin
    @return: the number of combinations that make up the amount
    """
    def change(self, amount, coins):
        # write your code here
        
        dp=[0 for _ in range(amount+1)]
        dp[0]=1
        for x in coins:
            for i in range(1,amount+1):
                if i>=x:
                    print(i,x)
                    dp[i]+=dp[i-x]
        #print(dp)
        return dp[-1]
        
                
        
amount = 8
coins = [2, 3, 8]# return 3
#8 = 8
#8 = 3 + 3 + 2
#8 = 2 + 2 + 2 + 2        
if __name__ == "__main__":
    print(Solution().change( amount, coins))        
        
        
#742. Self Dividing Numbers
class Solution:
    """
    @param lower: Integer : lower bound
    @param upper: Integer : upper bound
    @return: a list of every possible Digit Divide Numbers
    """
    def digitDivideNums(self, lower, upper):
        # write your code here 
        def isDivid(num):
            cur=num
            while cur:
                temp=cur%10
                if temp==0:
                    return False
                if num%temp!=0:
                    return False
                cur=cur//10
            return True
        res=[]
        for x in range(lower,upper+1):
            if isDivid(x):
                res.append(x)
        return res
                
#743. Monotone Increasing Digits        
class Solution:
    """
    @param num: a non-negative integer N
    @return: the largest number that is less than or equal to N with monotone increasing digits.
    """
    def monotoneDigits(self, num):
        # write your code here
#找到第一个不递增或相等的数，把后面每一位变为0, 然后整体减去1        
        cur=num
        num2=num
        num=[]
        while cur:
            temp=cur%10
            num.append(temp)
            cur=cur//10
        
        num.reverse()
        
        smaller=False
        for i,x in enumerate(num):
            if i>0 and x<num[i-1]:
                smaller=True
                break
        if not smaller:
            return num2
        i=i-1
        res=0
        #print(i)
        while i >0 and num[i]==num[i-1]:
            i-=1
        while i+1<len(num):
            num[i+1]=0
            i+=1
        print(num)
        for j in range(len(num)):
            res=res*10+num[j]
        return res-1  
            
            
                
                
                
num=12234
num=10000
num=111111110
num=1234543
if __name__ == "__main__":
    print(Solution().monotoneDigits( num))     
           
          
#744. Sum of first K even-length Palindrome numbers
class Solution:
    """
    @param k: Write your code here
    @return: the sum of first k even-length palindrome numbers
    """
    def sumKEven(self, k):
#找规律，回文前半部分是顺序递增的数字，需要K个，那么就是1..K，那么就构造11..KK,按序镜像。 
        
        setK=set()
        res=0
        for i in  range(1,k+1):
            half_palindrome=str(i)
            palindrome=half_palindrome+half_palindrome[::-1]
            res+=int(palindrome)
            
        
        return res
            
#745. Palindromic Ranges
class Solution:
    """
    @param L: A positive integer
    @param R: A positive integer
    @return:  the number of interesting subranges of [L,R]
    """
    def PalindromicRanges(self, L, R):
        # test
        dp=[0 for _ in range(R-L+1)]
        def isPalindrome( num):
       
        
            def check(s):
              if not s:
                return True
              n=len(s)
              if n==1:
                return True
              if s[0]!=s[-1]:
                return False
              else:
                return check(s[1:-1])
            return check(str(num))
        for i in range(L,R+1):
            if isPalindrome(i):
                dp[i-L]=1
            if i>L:
                dp[i-L]+=dp[i-L-1]
       
        dp=[0]+dp
        print(dp)
        res=0
        for i in range(R-L+1):
            for j in range(i+1,R-L+2):
                if (dp[j]-dp[i])%2==0:
                    res+=1
        return res
                
L = 1
R = 2
L = 1
R = 7 
L = 87
R = 88               
if __name__ == "__main__":
    print(Solution().PalindromicRanges(L, R))     
                           
       
#749. John's backyard garden            
class Solution:
    """
    @param x: the wall's height
    @return: YES or NO
    """
    def isBuild(self, x):
        # write you code here
        
        dp=[False for _ in range(x+1)]
        
        dp[0]=True
        for brick in (3,7):
            for i in range(1,x+1):
                if i>=3:
                    dp[i]=dp[i] or dp[i-3]
                if i>=7:
                    dp[i]=dp[i] or dp[i-7]
        return 'YES' if dp[-1] else 'NO'
x=10
x=5
x=13
if __name__ == "__main__":
    print(Solution().isBuild( x))             
        
        
#750. Portal
class Solution:
    """
    @param Maze: 
    @return: nothing
    """
    def Portal(self, Maze):
        # 
    
        from collections import deque
        m=len(Maze)
        n=len(Maze[0])
        
        for a in range(m):
            for b in range(n):
                if Maze[a][b]=='S':
                    break
            if Maze[a][b]=='S':
                    break
                
        dq=deque([(a,b,0)])
        visited=set(( a,b))
        while dq:
           i,j,step= dq.popleft()
           
           if Maze[i][j]=='E':
               return step
           
           for x, y in  (( i+1,j),( i,j+1),( i-1,j),( i,j-1)):
               if x >=0 and y >=0 and x<m and y<n and Maze[x][y]!='#' and (x,y) not in visited:
                 dq.append((x,y,step+1))
                 visited.add((x,y))
        return -1
           
        
        
Maze=[
['S','E','*'],
['*','*','*'],
['*','*','*']
]        
#return 1        
        
Maze=[
['S','#','#'],
['#','*','#'],
['#','*','*'],
['#','*','E']
] 
# return -1       
if __name__ == "__main__":
    print(Solution().Portal( Maze))        
        
        
#751. John's business
class SegmentTree(object):
    def __init__(self,start,end,minimum=0):
        self.start=start
        self.end=end
        self.min=minimum
        self.left,self.right=None,None
    
    @classmethod
    def build(cls,start,end,a):
        if start >end:
            return None
        elif start==end:
            return SegmentTree(start,end,a[start])
        else:
            root=SegmentTree(start,end,a[start])
            mid=(start+end)//2
            root.left=cls.build(start,mid,a)
            root.right=cls.build(mid+1,end,a)
            root.min=min(root.left.min,root.right.min)
            return root
        
    @classmethod    
    def query(self,root,start,end):
        if  root.end<start or root.start>end :
            return float('inf')
        elif root.end <= end    and root.start >=start:
            return root.min
        else:
            return min(self.query(root.left,start,end), self.query(root.right,start,end))
        
        
        
    
class Solution:
    """
    @param A: The prices [i]
    @param k: 
    @return: The ans array
    """
    def business(self, A, k):
        # 
        
#        n=len(A)
#        import heapq 
#        hp=      A[:k]   
#        heapq.heapify(hp)
#        res=[]
#        for i,x in enumerate(A):
#            
#            if i<=k:
#                if i+k <n:
#                   heapq.heappush(hp,A[i+k])
#                res.append(x-hp[0])
#            else:
#                hp.remove(A[i-k-1])
#                if i+k <n:
#                   heapq.heappush(hp,A[i+k])
#                #print(x,hp[0])
#                res.append(x-hp[0])
#        return res
#https://github.com/cherryljr/LintCode/blob/master/John's%20business.java
#https://lintcode.com/problem/interval-minimum-number/description 
        
        root=SegmentTree.build(0,len(A)-1,A)
        res=[]
        for i in range(len(A)):
            left=max(0,i-k)
            right=min(len(A)-1,i+k)
            res.append(A[i]-SegmentTree.query(root,left,right))
        return res
        
        
A = [1, 3, 2, 1, 5]
k = 2 # return [0, 2, 1, 0, 4]  
A =[1, 1, 1, 1, 1] 
k =1 
if __name__ == "__main__":
    print(Solution().business( A, k))        
                        
#752. Rogue Knight Sven
class Solution:
    """
    @param n: the max identifier of planet.
    @param m: gold coins that Sven has.
    @param limit: the max difference.
    @param cost: the number of gold coins that reaching the planet j through the portal costs.
    @return: return the number of ways he can reach the planet n through the portal.
    """
    def getNumberOfWays(self, n, m, limit, cost):
        # 
#        self.res=0
#        def search(j,mm,limit,cost):
#            
#            if j==n:
#                self.res+=1
#                return 
#            
#            for i in range(1,limit+1):
#                if j+i <=n and cost[j+i]<=mm:
#                    #print(j+i,mm-cost[j+i],limit,cost)
#                    search(j+i,mm-cost[j+i],limit,cost)
#        search(0, m, limit, cost)
#        return self.res
#F[i][j] defines number of ways when reaching i planet by using j coins ( j <= m)
#F[i][j] = sum(F[i-limit..i-1][j-cost[i]])       
#        dp=[[0 for _ in range(m+1)] for _ in range(n+1)]
#        for j in range(m+1):
#            dp[0][j]=1 #从 dp[n][m] 出发 ，，到 dp[0] 与下面的方法相反
#
#        for i in range(1,n+1):
#                for j in range(m+1):
#                    start=max(i-limit,0)
#                    for k in range(start,i):
#                       if j>=cost[i]:
#                          dp[i][j]+=dp[k][j-cost[i]]
#        print(dp)
#        return dp[n][m]
        dp=[[0 for _ in range(m+1)] for _ in range(n+1)]
        dp[0][m]=1#从 [0][m] 出发 ，，到 dp[n]与上面的方法相反
        for i in range(1,n+1):
            for j in range(m+1):
                start=max(i-limit,0)
                for k in range(start,i):
                    if j+cost[i]<=m:
                        dp[i][j]+=dp[k][j+cost[i]]
        return sum(dp[n])
        
            
                
   
            
n = 1
m = 1
limit = 1
cost = [0, 1]#return 1.


n = 1
m = 1
limit = 1
cost = [0, 2]#return 0.


n = 2
m = 3
limit = 2
cost = [0, 1, 1]#return 2.


n = 2
m = 3
limit = 2
cost = [0, 3, 1]#return 1.

n =37
m =73
limit =20
cost =[0,1,3,1,1,3,2,0,3,2,0,3,1,0,3,3,3,3,0,1,3,1,2,1,0,0,2,0,3,2,1,3,2,2,3,2,0,3] 


n =7
m =7
limit =5
cost =[0,1,3,0,0,3,2,2]

      
if __name__ == "__main__":
    print(Solution().getNumberOfWays( n, m, limit, cost))            
        
#761. Smallest Subset
class Solution:
    """
    @param arr:  an array of non-negative integers
    @return: minimum number of elements
    """
    def minElements(self, arr):
        # write your code here
        n=len(arr)
        
        arr.sort(reverse=True)
        
        N=sum(arr)
        
        res=0
        sm=0
        for a in arr:
            sm+=a
            res+=1
            if sm> N-sm:
                return res
arr=[3,1,7,1] 
arr = [2, 1, 2]       
        
if __name__ == "__main__":
    print(Solution().minElements(arr))         
        
        
#762. Longest Common Subsequence II        
class Solution:
    """
    @param P: an integer array P
    @param Q: an integer array Q
    @param k: the number of allowed changes
    @return: return LCS with at most k changes allowed.
    """
    def longestCommonSubsequenceTwo(self, P, Q, k):
        # Write your code here
        m=len(P)
        n=len(Q)
        
        
        dp=[[[0 for _ in range(k+1)] for _ in range(n+1)] for _ in range(m+1)]
        
        # initialize g=0 
        for i in range(m+1):
            for j in range(n+1):
                if i==0 or j==0:
                    dp[i][j][0]=0
                elif P[i-1]==Q[j-1]:
                    dp[i][j][0]= dp[i-1][j-1][0]+1
                else:
                    dp[i][j][0]= max(    dp[i-1][j][0] , dp[i][j-1][0] )
        
        for i in range(m+1):
            for j in range(n+1):
                for g in range(1,k+1):
                    if i==0 or j==0:
                       dp[i][j][g]=0 
                    
                    elif P[i-1]!=Q[j-1]:
                        dp[i][j][g]= max(    dp[i-1][j][g] , dp[i][j-1][g],  dp[i-1][j-1][g-1]+1)
                    else:
                        dp[i][j][g]= max(    dp[i-1][j][g] , dp[i][j-1][g],  dp[i-1][j-1][g]+1)
                        
        return dp[m][n][k]
P = [8 ,3]
Q = [1, 3]
k = 1

P = [1, 2, 3, 4, 5]
Q = [5, 3, 1, 4, 2]
k = 1      
if __name__ == "__main__":
    print(Solution().longestCommonSubsequenceTwo( P, Q, k))         
                
                    
#763. Hex Conversion                    
class Solution:
    """
    @param n: a decimal number
    @param k: a Integer represent base-k
    @return: a base-k number
    """
    def hexConversion(self, n, k):
        # write your code here
        res=''
        if n==0:
            return '0'
        while n>0:
            t=n%k
            if t<=9:
                c=str(t)
            else:
               c= chr(ord('A')+(t-10))
            res=c+res
            n=n//k
        return res
                
#764. Calculate Circumference And Are        
class Solution:
    """
    @param r: a Integer represent radius
    @return: the circle's circumference nums[0] and area nums[1]
    """
    def calculate(self, r):
        # write your code here
        pi=3.14
        
        nums=[]
        nums.append( round(  r*2*pi,2))
        nums.append( round(  r*r*pi,2))
        return nums
       
       
       
#765. Valid Triangle       
class Solution:
    """
    @param a: a integer represent the length of one edge
    @param b: a integer represent the length of one edge
    @param c: a integer represent the length of one edge
    @return: whether three edges can form a triangle
    """
    def isValidTriangle(self, a, b, c):
        # write your code here
        tri=[a,b,c]
        tri.sort()
        
        if tri[0]+tri[1]>tri[2]:
            return True
        else:
            return False
        

#766. Leap Year       
class Solution:
    """
    @param n: a number represent year
    @return: whether year n is a leap year.
    """
    def isLeapYear(self, n):
        # write your code here
#The year can be evenly divided by 4;
#If the year can be evenly divided by 100, it is NOT a leap year, unless;
#The year is also evenly divisible by 400. Then it is a leap year.
        if n%4==0:
            if n%100==0:
                if n%400==0:
                    return True
                else:
                    return False
            return True
        return False
        
#767. Reverse Array        
class Solution:
    """
    @param nums: a integer array
    @return: nothing
    """
    def reverseArray(self, nums):
        # write your code here
        n=len(nums)
        if n==0 or n==1:
            return nums
        
        for i in range(n//2):
            nums[i],nums[n-i-1]=nums[n-i-1],nums[i]
        print(nums)
nums=[1,2,3]
if __name__ == "__main__":
    print(Solution().reverseArray( nums)) 


#768. Yang Hui Triangle
class Solution:
    """
    @param n: a Integer
    @return: the first n-line Yang Hui's triangle
    """
    def calcYangHuisTriangle(self, n):
        # write your code here
        if n==0:
            return []
        if n==1:
            return [[1]]
        if n==2:
            return [[1],[1,1]]
        res=[[1],[1,1]]
        
        for i in range(2,n):
            temp=[1]
            for j in range(1,i):
                temp.append(res[i-1][j-1]+res[i-1][j])
            temp.append(1)
            res.append(temp[:])
        return res
#[
# [1]
# [1,1]
# [1,2,1]
# [1,3,3,1]
#]
n=6
if __name__ == "__main__":
    print(Solution().calcYangHuisTriangle( n)) 



#769. Spiral Array
class Solution:
    """
    @param n: a Integer
    @return: a spiral array
    """
    def spiralArray(self, n):
        # write your code here
        if n==0:
            return []
        if n==1:
            return [[1]]
        
        direction=[(0,1),(1,0),(0,-1),(-1,0)]
        d=0
        
        grid=[[0 for _ in range(n)] for _ in range(n)]
        
        i=1
        r=0
        c=0
        while i<=n*n:
            grid[r][c]=i
            i+=1
            nr=r+direction[d][0]
            nc=c+direction[d][1]
            if nr>=n or nr<0 or nc>=n or nc<0 or grid[nr][nc]>0:
              d=(d+1)%4
              nr=r+direction[d][0]
              nc=c+direction[d][1]
            r=nr
            c=nc
              
            #print(grid,r,c)
        return grid
n=3
if __name__ == "__main__":
    print(Solution().spiralArray( n)) 
            
            
#770. Maximum and Minimum
class Solution:
    """
    @param matrix: an input matrix 
    @return: nums[0]: the maximum,nums[1]: the minimum
    """
    def maxAndMin(self, matrix):
        # write your code here
        m=len(matrix)
        
        if m==0:
            return []
        imax=float('-inf')
        imin=float('inf')
        for row in matrix:
            if min(row) < imin:
                imin=min(row)
            if max(row) > imax:
                imax=max(row)
        return [imax,imin]
            


#772. Group Anagrams        
class Solution:
    """
    @param strs: the given array of strings
    @return: The anagrams which have been divided into groups
    """
    def groupAnagrams(self, strs):
        # write your code here
        from collections import Counter,defaultdict
        import string 
        
        table=defaultdict(list)
        for s in strs:
            c=Counter(s)
            key=''
            for char in string.ascii_lowercase:
                if char in c:
                    key+=char+str(c[char])
            table[key].append(s)
        res=[]
        return list(table.values())
strs = ["eat", "tea", "tan", "ate", "nat", "bat"]       
#[
#    ["ate", "eat","tea"],
#    ["nat","tan"],
#    ["bat"]
#]       
#       
if __name__ == "__main__":
    print(Solution().groupAnagrams( strs)) 
                   
#774. Repeated DNA
class Solution:
    """
    @param s: a string represent DNA sequences
    @return: all the 10-letter-long sequences 
    """
    def findRepeatedDna(self, s):
        # write your code here
        n=len(s)
        
        if n<=10:
            return []
        print(n)
        sset=set()
        res=[]
        for i in range(n-9):
            if s[i:i+10]  not in sset:
                sset.add(s[i:i+10])
            elif s[i:i+10] not in res:
                res.append(s[i:i+10])
            print(i,sset)
        return res
                
s="AAAAAAAAAAA"
s="AAAAAAAAAAAA"   
s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT"
#["AAAAACCCCC", "CCCCCAAAAA"]                   
if __name__ == "__main__":
    print(Solution().findRepeatedDna( s))         
        
        

#775. Palindrome Pairs
class Solution:
    """
    @param words: a list of unique words
    @return: all pairs of distinct indices
    """
    def palindromePairs(self, words):
        # Write your code here
        def isPalindrome(s):
            n=len(s)
            if n==0 or n==1:
                return True
            if n==2:
                return s[0]==s[1]
            return s[0]==s[-1]  and isPalindrome(s[1:-1])
        
        n=len(words)
        res=[]
        words={ word : i for i,word in enumerate(words)}
        
        for word,k in words.items():
            n=len(word)
            #print(res,word,k)
            for j in range(n+1):
                pre=word[:j]
                suf=word[j:]
                
                if isPalindrome( pre):
                    front=suf[::-1]
                    if front!=word and front in words:
                        res.append( [ words[front] , k])
                if j!=n and isPalindrome( suf):
                    back=pre[::-1]
                    if back!=word and back in words:
                        res.append( [ k,words[back] ])
        return res
            
        
        
        
        
#        for i in range(n-1):
#            for j in range(i+1,n):
#                if isPalindrome(words[i] + words[j]):
#                    res.append([i,j])
#                if isPalindrome(words[j]+ words[i]):
#                    res.append([j,i])
        return res
words = ["bat", "tab", "cat"] 
words = ["abcd", "dcba", "lls", "s", "sssll"]       
if __name__ == "__main__":
    print(Solution().palindromePairs(words))  

#776. Strobogrammatic Number II
class Solution:
    """
    @param n: the length of strobogrammatic number
    @return: All strobogrammatic numbers
    """
    def findStrobogrammatic(self, n):
        # write your code here
        if n==0:
           return ['']
        if n==1:
            return ['0','1','8']
        if n==2:
            return ["11","69","88","96"]
        res=[]
       
        pair={'1':'1','6':'9','0':'0','8':'8','9':'6'}
        
        def append(left,right,pair,res,n):
            if (len(left)+len(right))==n:
                if left[0]!='0':
                   res.append(left+right)
                return 
            if (len(left)+len(right)) +1 ==n:
                if left[0]!='0':
                   res.append(left+'0'+right)
                   res.append(left+'1'+right)
                   res.append(left+'8'+right)
                return 
            #print(left,right)
            for l,r in pair.items():
                
                append(l+left,right+r,pair,res,n)
                
        append('','',pair,res,n)
        return res
                
n = 2# return ["11","69","88","96"]
n=3 
if __name__ == "__main__":
    print(Solution().findStrobogrammatic( n))  
 
 
#777. Valid Perfect Square
class Solution:
    """
    @param num: a positive integer
    @return: if num is a perfect square else False
    """
    def isPerfectSquare(self, num):
        # write your code here
        
        if num==1 or num==4 or num==9 or num==16:
            return True
        if num<16 :
            return False
        
        left=0
        right=num
        
        while left<=right:
            #print(left,right)
            mid=(left+right)//2
            
            if mid*mid==num:
                return True
            elif mid*mid>num:
                right=mid-1
            else:
                left=mid+1
        if left*left==num:
            return True
        return False
num=25       
if __name__ == "__main__":
    print(Solution().isPerfectSquare( num))  
  
 
#778. Pacific Atlantic Water Flow
class Solution:
    """
    @param matrix: the given matrix
    @return: The list of grid coordinates
    """
    def pacificAtlantic(self, matrix):
        # write your code here
        
        from collections import deque
        m=len(matrix)
        if m==0:
            return []
        n=len(matrix[0])  
        
        pacific=[[False for _ in range(n)] for _ in range(m)]
        atlantic=[[False for _ in range(n)] for _ in range(m)]
        
        
        def bfs(grid,i,j,ocean):
            visited=set()
            visited.add((i,j))
            dq=deque([(i,j)])
            while dq:
                a,b=dq.popleft()
                ocean[a][b]=True
                for x,y in (( a+1,b  ),( a-1,b  ),( a,b+1  ),( a,b -1 )):
                    if x>=0 and y>=0 and x<m and y<n and (x,y) not in visited:
                        if grid[a][b]<=grid[x][y]:
                            visited.add((x,y))
                            dq.append((x,y))
        
        for r in range(m):
            bfs(matrix,r,0,pacific) 
            bfs(matrix,r,n-1,atlantic)
              
          
               
        for c in range(n):
            bfs(matrix,0,c,pacific)
            bfs(matrix,m-1,c,atlantic)
        res=[]
        for i in range(m):
            for j in range(n):
                if pacific[i][j]  and atlantic[i][j] :
                    res.append((i,j))
        return res
Pacific ~   ~   ~   ~   ~ 
       ~  1   2   2   3  (5) *
       ~  3   2   3  (4) (4) *
       ~  2   4  (5)  3   1  *
       ~ (6) (7)  1   4   5  *
       ~ (5)  1   1   2   4  *
          *   *   *   *   * Atlantic 
 
matrix=[[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]

 
if __name__ == "__main__":
    print(Solution().pacificAtlantic(matrix))  
   
 
#779. Generalized Abbreviation 
class Solution:
    """
    @param word: the given word
    @return: the generalized abbreviations of a word
    """
    def generateAbbreviations(self, word):
        # Write your code here
        
        def generate(w,path,abbr,res):
            n=len(w)
            if n==0:
                res.append(path[:])
                return 
            generate(w[1:],path+w[:1],False,res)
            
            if not abbr:
                for i in range(1,n+1):
                    generate(w[i:],path+str(i),True,res)
        res=[]
        generate(word,'',False,res)
        return res[::-1]
        
                    
            
word = "word"
#["word", "1ord", "w1rd", "wo1d", "wor1", "2rd", "w2d", "wo2", "1o1d", "1or1", "w1r1", "1o2", "2r1", "3d", "w3", "4"]
if __name__ == "__main__":
    print(Solution().generateAbbreviations( word))  
    

#780. Remove Invalid Parentheses
class Solution:
    """
    @param s: The input string
    @return: Return all possible results
    """
    def removeInvalidParentheses(self, s):
        # Write your code here
        
        from collections import deque
        dq=deque([ s])
        visited=set()
        
        visited.add( s )
        
        def isValid( P):
#            stack=[]
#            for p in P:
#                if p=='(':
#                    stack.append(p)
#                elif p==')':
#                    if not stack:
#                        return False
#                    stack.pop()
#            return not stack
            count=0
            for p in P:
                if p=='(':
                    count+=1
                elif p==')':
                    count-=1
                if count<0:
                    return False
            return count==0
        
            
                
        found=False 
        res=[]
        while dq:
            n=len(dq)
            
            for _ in range(n):
                x=dq.popleft()
                print(x)
                if isValid( x):
                    res.append(x)
                    found=True
                if found:
                    continue
                for i in range(len(x)):
                    if (x[i] =='('  or x[i] ==')' ) and x[:i]+x[i+1:] not in visited: #不能省括号
                        dq.append( x[:i]+x[i+1:])
                        visited.add(x[:i]+x[i+1:])
            if found:
                break
        return res
s="()())()"
s= "(a)())()"
s=  ")("
s= ")((())))))()(((l(((("
if __name__ == "__main__":
    print(Solution().removeInvalidParentheses( s))  
                        
                    
                
#780. Remove Invalid Parentheses            
class Solution:
    """
    @param s: The input string
    @return: Return all possible results
    """
    def removeInvalidParentheses(self, s):
        # Write your code here
        l=0
        r=0
        for p in s:
            if p=='(':
                l+=1
            if p==')':
                if l>0:
                    l-=1
                else:
                    r+=1
            
      
        
        def isValid( P):

            count=0
            for p in P:
                if p=='(':
                    count+=1
                elif p==')':
                    count-=1
                if count<0:
                    return False
            return count==0   
        res=[]
        def dfs(ss, start,l,r,res):  
            if l==0 and r==0 and isValid( ss):
                res.append(ss)
                return 
            
            for i in range(start,len(ss)):
                if i>start  and ss[i-1]==ss[i]:
                    continue
                if ss[i]=='(' and l>0:
                    dfs(ss[:i]+ss[i+1:], i,l-1,r,res)
                if ss[i]==')' and r>0:
                    dfs(ss[:i]+ss[i+1:], i,l,r-1,res)
        
        dfs(s, 0,l,r,res) 
        if not res:
            res=['']
        return res           
s="()())()"
s= "(a)())()"
s=  ")("
s= ")((())))))()(((l(((("
if __name__ == "__main__":
    print(Solution().removeInvalidParentheses( s))                  
                
                
#782. AND and OR                
class Solution:
    """
    @param n: 
    @param nums: 
    @return: return the sum of maximum OR sum, minimum OR sum, maximum AND sum, minimum AND sum.
    """
    def getSum(self, n, nums):
        # write your code here
       
        maxand=nums[0]
        minand=nums[0]
        maxor=nums[0]
        minor=nums[0]
        
        for num in nums:
             maxor|=num
             minand &=num
             
             minor=min(minor,num)
             maxand=max(maxand,num)
        
        return maxand +minand+maxor + minor
n = 3
nums = [1, 2, 3]
n = 3
nums = [0, 0, 1]
n = 5
nums = [12313, 156, 4564, 212, 12]
n = 3
nums = [111111, 333333, 555555]
if __name__ == "__main__":
    print(Solution().getSum( n, nums))                    

#783. Minimum Risk Path
class Solution:
    """
    @param n: maximum index of position.
    @param m: the number of undirected edges.
    @param x: 
    @param y: 
    @param w: 
    @return: return the minimum risk value.
    """
    def __init__( self):
        self.v=[[] for _ in range(1010)]
        self.w=[[] for _ in range(1010)]
        self.visited=[0 for _ in range(1010)]
        self.res=float('inf' )
    
    def dfs(self,start,curvalue,end):
        if start==end:
            return curvalue
        
        if curvalue>=self.res:
            return float('inf' )
        
        tempres=float('inf' )
        
        self.visited[start]=1
        for i in range( len(self.v[start]) ):
            if  self.visited[self.v[start][i]]==1:
                continue
            tempres=min( tempres, self.dfs(self.v[start][i],max( self.w[start][i], curvalue),end))
            self.res=min(tempres,self.res)
                             
        
        
        self.visited[start]=0
        return tempres
            
        
        
    def getMinRiskValue(self, n, m, x, y, w):
        for i in range(m):
            self.v[x[i]].append(y[i])
            self.v[y[i]].append(x[i])
            self.w[x[i]].append(w[i])
            self.w[y[i]].append(w[i])
        self.dfs(0,0,n)
        
        return self.res
            
n = 2
m = 2
x = [0, 1]
y = [1, 2]
w = [1, 2]  

n = 3
m = 4
x = [0, 0, 1, 2]
y = [1, 2, 3, 3]
w = [1, 2, 3, 4] 

n = 4
m = 5
x = [0, 1, 1, 2, 3]
y = [1, 2, 3, 4, 4]
w = [3, 2, 4, 2, 1]

n = 5
m = 7
x = [0, 0, 1, 2, 3, 3, 4]
y = [1, 2, 3, 4, 4, 5, 5]
w = [2, 5, 3, 4, 3, 4, 1]
      
if __name__ == "__main__":
    print(Solution().getMinRiskValue( n, m, x, y, w))          

#784. The Longest Common Prefix II
class Solution:
    """
    @param dic: the n strings
    @param target: the target string
    @return: The ans
    """
    def the_longest_common_prefix(self, dic, target):
        # write your code here
        n=len(dic)
        if n==0:
            return 0
        res=float('-inf')
        for d in dic:
            resd=0
            for x, y in zip( d,target):
                if x==y:
                    resd+=1
            if resd>res:
                res=resd
        return res
dic=["abcba","acc","abwsf"]
target = "abse"#return 2            

#785. Maximum Weighted Sum Path
class Solution:
    """
    @param nums: 
    @return: nothing
    """
    def maxWeight(self, nums):
        # write your code here
        m=len(nums)
        if m==0:
            return 0
        n=len(nums[0])
#        self.res=float('-inf')
#        def dfs(nums,i,j,visited,path):
#            if i==m-1 and j==0:
#                if path>self.res:
#                    self.res=path
#                return 
#            
#            for x,y in ((i,j-1) ,(i+1,j)):
#                if x>=0 and y>=0 and x<m and y<n and (x,y) not in visited:
#                    dfs(nums,x,y,visited | set( [( x,y)]),path+nums[x][y])
#    
#                    
#        dfs(nums,0,n-1,set(),nums[0][n-1])     
#        return self.res
        dp=[[0 for _ in range(n)] for _ in range(m)]
        
        for i in range(m):
            for j in range(n-1,-1,-1):
                if i-1 >=0:
                
                   dp[i][j]= max( dp[i][j],dp[i-1][j]+nums[i][j])
                if j+1 < n:
                   dp[i][j]= max( dp[i][j],dp[i][j+1]+nums[i][j])
        
        return dp[m-1][0] +nums[0][n-1]
            
        


nums=[
[1,2,3,4],
[3,5,6,7],
[9,10,1,2],
[4,4,5,5]
]

nums=[
[1,2,3],
[4,5,6],
[7,9,8]
]
if __name__ == "__main__":
    print(Solution().maxWeight( nums))    
 
 
#787. The Maze
class Solution:
    """
    @param maze: the maze
    @param start: the start
    @param destination: the destination
    @return: whether the ball could stop at the destination
    """
    def hasPath(self, maze, start, destination):
        # write your code here
        import time
        m=len(maze)
        n=len(maze[0])
        def dfs(maze,cur,destination):
            if cur==destination:
                return True
            
            for x, y in ((cur[0]+1,cur[1]),(cur[0]-1,cur[1]),(cur[0],cur[1]+1),(cur[0],cur[1]-1)):
                if   x>=0 and y>=0 and x<m and y<n and maze[x][y]==0:
                    if x==cur[0]+1:
                        while   x<m and  maze[x][y]==0 :
                                x+=1
                        x=x-1
                    elif x==cur[0]-1 :
                        while  x>=0 and maze[x][y]==0:
                                x-=1
                        x=x+1
                    elif y==cur[1]+1 :
                        while  y<n and maze[x][y]==0:
                                y+=1
                        y=y-1
                    elif y==cur[1]-1 :
                        while  y>=0 and maze[x][y]==0:
                                y-=1
                        y=y+1
                    if (x,y)==cur:
                        continue
                    #print(cur,(x,y))
                    #time.sleep(5)
                    if (x,y)  not in self.visited:
                       self.visited.add((x,y))
                       if dfs(maze,(x,y),destination ):
                           return True
            return False
           
        start=tuple(start)
        destination=tuple(destination)
        self.visited=set([ start  ]) 
        return dfs(maze,start,destination )
                    
maze=[[0,0,1,0,0],
      [0,0,0,0,0],
      [0,0,0,1,0],
      [1,1,0,1,1],
      [0,0,0,0,0]]
start = (0, 4) 
destination  = (4, 4)
destination  = (4, 3)
destination  = (3,2)
if __name__ == "__main__":
    print(Solution().hasPath( maze, start, destination)) 
 
#788. The Maze II
class Solution:
    """
    @param maze: the maze
    @param start: the start
    @param destination: the destination
    @return: the shortest distance for the ball to stop at the destination
    """
    def shortestDistance(self, maze, start, destination):
        # write your code here
        import time
        m=len(maze)
        n=len(maze[0])
        
        if start==destination:
            return 0
        
        from collections import deque
        
        dp=[[float('inf') for _ in range(n)] for _ in range(m)]
        dq=deque(  [(start[0],start[1],0 ) ])
        directions=[-1,0,1,0,-1]
        while dq:
            cur_x,cur_y,cur_l=dq.popleft()
            if cur_l >= dp[cur_x][cur_y]:
                continue
            dp[cur_x][cur_y]=cur_l
            #print(x,y,dq)
            #print('#####')
            #print('#####')
            for k in range(4):
                x=cur_x
                y=cur_y
                l=cur_l
                while  x>=0 and y>=0 and x<m and y<n and maze[x][y]==0:
                    x+=directions[k]
                    y+=directions[k+1]
                    l+=1
                    #print(x,y,directions[k],directions[k+1])
                
                x-=directions[k]
                y-=directions[k+1]
                l-=1
            
                #print('****',x,y,l)
               
                dq.append((x,y,l))
                #print(dq)
        return dp[destination[0]][destination[1]] if dp[destination[0]][destination[1]] < float('inf') else -1
        
                    
maze=[[0,0,1,0,0],
      [0,0,0,0,0],
      [0,0,0,1,0],
      [1,1,0,1,1],
      [0,0,0,0,0]]
start = (0, 4) 
destination  = (4, 4)
destination  = (4, 3)
destination  = (3,2)
if __name__ == "__main__":
    print(Solution().shortestDistance( maze, start, destination)) 


#789. The Maze III
class Solution:
    """
    @param maze: the maze
    @param ball: the ball position
    @param hole: the hole position
    @return: the lexicographically smallest way
    """
    def findShortestWay(self, maze, ball, hole):
        # write your code here
        import time
        m=len(maze)
        n=len(maze[0])
        
        if ball==hole:
            return ''
        res=[]
        from collections import deque
        
        dp=[[ (float('inf'),'') for _ in range(n)] for _ in range(m)]
        dq=deque(  [(ball[0],ball[1],0,'' ) ])
        directions=[-1,0,1,0,-1]
        while dq:
            cur_x,cur_y,cur_l,cur_path=dq.popleft()
            if cur_l >= dp[cur_x][cur_y][0]:
                continue
            dp[cur_x][cur_y]=(cur_l,cur_path)
            #print(x,y,dq)
            #print('#####')
            #print('#####')
            for k in range(4):
                x=cur_x
                y=cur_y
                l=cur_l
                path=cur_path
                found=False
                while  x>=0 and y>=0 and x<m and y<n and maze[x][y]==0:
                    if x==hole[0]  and y==hole[1]:
                        found=True
                        break
                    x+=directions[k]
                    y+=directions[k+1]
                    l+=1
                    #print(x,y,directions[k],directions[k+1])
                if not found:
                    x-=directions[k]
                    y-=directions[k+1]
                    l-=1
                if x > cur_x:
                    path+='d'
                elif x<cur_x:
                    path+='u'
                elif y<cur_y:
                    path+='l'
                elif y>cur_y:
                    path+='r'  
                if found:
                    res.append( (l,path))
                #print('****',x,y,l)
               
                if not found:
                    dq.append((x,y,l,path))
                #print(dq)
        return sorted(res)[0][1]  if res else 'impossible'



maze=[[0,0,0,0,0],
      [1,1,0,0,1],
      [0,0,0,0,0],
      [0,1,0,0,1],
      [0,1,0,0,0]]
ball=[4,3]
hole=[0,1]
if __name__ == "__main__":
    print(Solution().findShortestWay( maze, ball, hole)) 

#790. Parser
class Solution:
    """
    @param generator: Generating set of rules.
    @param startSymbol: Start symbol.
    @param symbolString: Symbol string.
    @return: Return true if the symbol string can be generated, otherwise return false.
    """
    def canBeGenerated(self, generator, startSymbol, symbolString):
        # Write  your code here.
        from collections import defaultdict
        graph=defaultdict(list)
        
        for x in generator:
            before ,after=x.split( '→' )
            before=before.strip()
            after=after.strip()
            
            #print(before,after)
            graph[before].append(list(after))
        #print(graph)
        
        def dfs( string,symbolString,graph):
            #print(string)
            if ''.join(string)==symbolString:
                return True
            if len(string) >len(symbolString):
                return 
            for i in range(len(string)):
                if string[i] in graph and string[i]!=startSymbol:
                    for next_s in graph[string[i]]:
                        if dfs( string[:i]+next_s+string[i+1:],symbolString,graph):
                            return True
            return False
        
        for string in graph[startSymbol]:
            if dfs( string,symbolString,graph):
                return True
        return False
            
generator = ["S → abc", "S → aA", "A → b", "A → c"]
startSymbol = 'S'
symbolString = 'ac'

generator = ["S → abcd", "S → A", "A → abc"]
startSymbol = 'S'
symbolString = 'abc'

generator = ["S → abc", "S → aA", "A → b", "A → c"]
startSymbol = 'S'
symbolString = 'a'

generator = ["S → abcd", "S → A", "A → abc"]
startSymbol = 'S'
symbolString = 'ab'


generator =["E → TX", "X → bX", "X → c", "T → a", "T → d"]
startSymbol ='E'
symbolString ='d'
if __name__ == "__main__":
    print(Solution().canBeGenerated( generator, startSymbol, symbolString)) 



#791. Merge Number
class Solution:
    """
    @param numbers: the numbers
    @return: the minimum cost
    """
    def mergeNumber(self, numbers):
        # Write your code here
        res=0
        import heapq
        
        q=[]
        for x in numbers:
            heapq.heappush(q,x)
        
        
        while len(q)>1:
              print(q)
              a=heapq.heappop(q)
              b=heapq.heappop(q)
              res+=a+b
              heapq.heappush(q,a+b)
        return res
              
            
       
        
numbers=[1,2,3,4] #19       
numbers=[2,8,4,1]# 25        
if __name__ == "__main__":
    print(Solution().mergeNumber(numbers))
    
    
    
#792. Kth Prime Number  
import math      
class Solution:
    """
    @param n: the number
    @return: the rank of the number
    """
    def kthPrime(self, n):
        # write your code here
        dic={2:1,3:2,5:3,7:4}
        def isPrime(x):
            
            for t in range(2,int(math.ceil(x**0.5+1))):
                if x%t==0:
                    return False
            return True
        i=8
        index=4
        while i <= 100000:
            if  isPrime(i):
                index+=1
                dic[i]=index
            i+=1
        return dic[n]
        
n = 3 
n=11       
if __name__ == "__main__":
    print(Solution().kthPrime( n))
    
#793. Intersection of Arrays    
class Solution:
    """
    @param arrs: the arrays
    @return: the number of the intersection of the arrays
    """
    def intersectionOfArrays(self, arrs):
        # write your code here
        
        n=len(arrs)
        if n==0:
            return 0
        res=set(arrs[0])
        
        for i in range(1,n):
           res  &= set(arrs[i])
           
        return len(res)
            
    
arrs=[[1,2,3],[3,4,5],[3,9,10]]# return 1        
arrs=[[1,2,3,4],[1,2,5,6,7],[9,10,1,5,2,3]]# return 2        
if __name__ == "__main__":
    print(Solution().intersectionOfArrays( arrs))
            
        
#796. Open the Lock        
class Solution:
    """
    @param deadends: the list of deadends
    @param target: the value of the wheels that will unlock the lock
    @return: the minimum total number of turns 
    """
    def openLock(self, deadends, target):
        # Write your code here        
        
        from collections import deque
        deadends=set(deadends)
        if '0000' in deadends:
            return -1
        
        visited=set()
        visited.add('0000')
        
        dq=deque(['0000'])
        step=0
        while dq:
            
           
            temp=deque([])
    
            for _ in range(len(dq)):
              cur=dq.popleft()
              if cur==target:
                  return step
            
              for i in range(4):
                 n1= str((int(cur[i])+1)%10)
                 n2=str((int(cur[i])-1)%10)
                 for nx in ( cur[:i]+n1+cur[i+1:] , cur[:i]+n2+cur[i+1:]  ):
                    if nx not in deadends and nx not in visited:
                        #print(nx)
                        visited.add( nx)
                        temp.append(nx)
            step+=1
            dq=temp
            
        return -1
                        
 

deadends = ["0201","0101","0102","1212","2002"]
target = "0202"
#Return 6
deadends = ["8888"]
target = "0009"
deadends =["8887","8889","8878","8898","8788","8988","7888","9888"]
target = "8888"

deadends =["2110","2000","0000","2111","1110"]
target ="0012"


#Return 1
if __name__ == "__main__":
    print(Solution().openLock(deadends, target))


#797. Reach a Number
class Solution:
    """
    @param target: the destination
    @return: the minimum number of steps
    """
    def reachNumber(self, target):
        # Write your code here
        import math
        t=abs(target)
        n=math.floor(   (2*t)** 0.5)
        
        while True:
            diff=(1+n)*n/2-t
            if diff>=0:
                if diff%2==0:
                    return int(n)
            n+=1
           
 
target = 3
target = 2    
if __name__ == "__main__":
    print(Solution().reachNumber( target))
    
#802. Sudoku Solver
class Solution:
    """
    @param board: the sudoku puzzle
    @return: nothing
    """
    def solveSudoku(self, board):
        # write your code here   
        
        def isValid( n,i,j,board):
            #row
            if n in board[i]:
                return False
            for a in range(len(board)):
                if board[a][j]==n:
                    return False
            ii=i//3
            jj=j//3
            
            
            for b in range(3):
                for c in range(3):
                    if board[ii*3+b][jj*3+c]==n:
                        return False
            return True
                      
            
        def solve(board):
#            if sum([sum(row) for row in board])==45*9:
#                print(board)
#                return True
            for x in range(len(board)):
               for y in range(len(board[0])):
                 
                
                  if board[x][y]==0:
                    for value in range(1,10):
                        if isValid( value,x,y,board):
                            board[x][y]=value
                            if solve(board):
                                return True
                            else:
                                board[x][y]=0
                    return False # 要在这里加return ，截断不合格的。
                                
            return True
            #print(board)
            
        solve(board)
        print(board)
          
      
    
 
    
board=[[0,0,9,7,4,8,0,0,0],
 [7,0,0,0,0,0,0,0,0],
 [0,2,0,1,0,9,0,0,0],
 [0,0,7,0,0,0,2,4,0],
 [0,6,4,0,1,0,5,9,0],
 [0,9,8,0,0,0,3,0,0],
 [0,0,0,8,0,3,0,2,0],
 [0,0,0,0,0,0,0,0,6],
 [0,0,0,2,7,5,9,0,0]]    
    
if __name__ == "__main__":
    print(Solution().solveSudoku( board))    
    
#803. Shortest Distance from All Buildings    
class Solution:
    """
    @param grid: the 2D grid
    @return: the shortest distance
    """
    def shortestDistance(self, grid):
        # write your code here
        m=len(grid)
        n=len(grid[0])
        #dp=[[0  for _ in range(n)] for _ in range(m)]
        from collections import deque
        res=float('inf')
        building=0
        for i in range(m):
            for j in range(n):
                if grid[i][j]==1:
                    building+=1
                    
                
        for i in range(m):
            for j in range(n):
                if grid[i][j]==0:
                    #BFS
                    q=deque([  (i,j,0 )])
                    visited=set( (i,j ))
                    tempres=0
                    tempbuilding=building
                    while q:
                        x,y,step=q.popleft()
                        if grid[x][y]==1:
                            tempbuilding-=1
                            tempres+=step
                        elif grid[x][y]==0:
                            for a,b in ((x+1,y),(x-1,y),(x,y+1),(x,y-1)):
                                if a>=0 and b>=0 and a<m and b<n and (a,b) not in visited  and grid[a][b]!=2:
                                    visited.add((a,b))
                                    q.append((a,b,step+1))
                    if tempres<res and tempbuilding==0:
                        res=tempres
               
        return res
                    
    
    
    
    
grid=[[1,1,1,1,1,0],
 [0,0,0,0,0,1],
 [0,1,1,0,0,1],
 [1,0,0,1,0,1],
 [1,0,1,0,0,1],
 [1,0,0,0,0,1],
 [0,1,1,1,1,0]]    
    
if __name__ == "__main__":
    print(Solution().shortestDistance(grid))    
        
    
    
#804. Number of Distinct Islands II
class Solution:
    """
    @param grid: the 2D grid
    @return: the number of distinct islands
    """
    def numDistinctIslands2(self, grid):
        # write your code here
        directions=[(-1,0),(1,0),(0,1),(0,-1) ]
        
        def dfs(i,j,grid,island):
            if not (0<= i <len(grid)  and 0<= j <len(grid[0]) and grid[i][j] >0):
                return False
            
            grid[i][j]*=-1
            
            island.append(( i,j))
            for d in directions:
                dfs(i+d[0],j+d[1],grid,island)
            return True
        
        
        def normalize(island):
            shapes=[[]for _ in range(8)]
            
            for x,y in island:
                rotations_and_reflections= [ [-x,y] ,[x,-y] ,[-x,-y] ,[x,y] ,  [y,x], [-y,x],[y,-x],[-y,-x]]
                
                for i in range(len(rotations_and_reflections )):
                    shapes[i].append( rotations_and_reflections[i])
            for shape in shapes:
                shape.sort()
                
                origin=list(shape[0])
                
                for p in shape:
                    p[0]-=origin[0]
                    p[1]-=origin[1]
            print(shapes)
            return min(shapes)
        
        islands=set()
        
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                island=[]
                if dfs(i,j,grid,island):
                    islands.add(str(normalize(island))  )
        return len(islands)
grid=[[1,1,0,0,0],[1,0,0,0,0],[0,0,0,0,1],[0,0,0,1,1]]  
grid=[[1,1,1,0,0],[1,0,0,0,1],[0,1,0,0,1],[0,1,1,1,0]]                   
if __name__ == "__main__":
    print(Solution().numDistinctIslands2( grid))                
                
        
#813. Find Anagram Mappings
class Solution:
    """
    @param A: lists A
    @param B: lists B
    @return: the index mapping
    """
    def anagramMappings(self, A, B):
        # Write your code here 
        def find(arr,x):
            
            for i in range(len(arr)):
                if arr[i]==x:
                   return i
        
        res=[]
        for x in A:
            res.append(find(B,x))
        return res
        
        
        
A = [12, 28, 46, 32, 50] 
B = [50, 12, 32, 46, 28]#return [1, 4, 3, 2, 0]        
if __name__ == "__main__":
    print(Solution().anagramMappings(A, B))                
                        
#814. Shortest Path in Undirected Graph        
# Definition for a undirected graph node
# class UndirectedGraphNode:
#     def __init__(self, x):
#         self.label = x
#         self.neighbors = []
class Solution:
    """
    @param graph: a list of Undirected graph node
    @param A: nodeA
    @param B: nodeB
    @return:  the length of the shortest path
    """
    def shortestPath(self, graph, A, B):
        # Write your code here   
        if A==B:
            return 0
        
        from collections import deque
        q1=deque([A])
        q2=deque([B])
        visited=set([A,B])
        
        dis=0
        
        while q1 and q2:
            dis+=1
            len_q1=len(q1)
            for _ in range(len_q1):
                node=q1.popleft()
                
                
                for neighbor in node.neighbors:
                    if neighbor in q2:
                       return dis
                    if neighbor  not in visited:
                        visited.add(neighbor)
                        q1.append(neighbor)
            dis+=1
            len_q2=len(q2)
            for _ in range(len_q2):
                node=q2.popleft()
                
                
                for neighbor in node.neighbors:
                    if neighbor in q1:
                       return dis
                    if neighbor  not in visited:
                        visited.add(neighbor)
                        q2.append(neighbor)
        return -1
                
                
#817. Range Sum Query 2D - Mutable            
class NumMatrix(object):

    def __init__(self, matrix):
        """
        :type matrix: List[List[int]]
        """
        self.matrix=matrix
        m=len(matrix)
        n=len(matrix[0])
        self.msum=[[0 for _ in range(n+1)]  for _ in range(m+1)]
        for i in range(1,m+1):
            for j in range(1,n+1):
                if j==1:
                    
                   self.msum[i][j]= matrix[i-1][j-1]
                else:
                   self.msum[i][j]=self.msum[i][j-1]+matrix[i-1][j-1]
                if i>1:
                    self.msum[i][j]= self.msum[i-1][j]+self.msum[i][j]
                    
        print(self.msum)
        
#        for i in range(2,m+1):
#            for j in range(1,n+1):
#                self.msum[i][j]= self.msum[i-1][j]+self.msum[i][j]
        print(self.msum)
                      
                      
                
        

    def update(self, row, col, val):
        """
        :type row: int
        :type col: int
        :type val: int
        :rtype: void
        """
        for i in range(row+1,len(self.msum)):
            for j in range(col+1,len(self.msum[0])):
                self.msum[i][j]+= (val-self.matrix[row][col])
        self.matrix[row][col]=val
        #print(self.msum)
        

    def sumRegion(self, row1, col1, row2, col2):
        """
        :type row1: int
        :type col1: int
        :type row2: int
        :type col2: int
        :rtype: int
        """
        #print(self.msum[row2+1][col2+1],self.msum[row1][col1],self.msum[row1][col2+1],self.msum[row2+1][col1])
        return self.msum[row2+1][col2+1]+self.msum[row1][col1]-self.msum[row1][col2+1]-self.msum[row2+1][col1]
        
        
#817. Range Sum Query 2D - Mutable         
class NumMatrix(object):

    def __init__(self, matrix):
        """
        :type matrix: List[List[int]]
        """
        self.m=len(matrix)
        self.n=len(matrix[0])
        self.A=[[0 for _ in range(self.n+1)] for _ in range(self.m+1)]
        self.C=[[0 for _ in range(self.n+1)] for _ in range(self.m+1)]
        for i in range(self.m):
            for j in range(self.n):
                self.update(i,j,matrix[i][j])
        
        

    def update(self, row, col, val):
        """
        :type row: int
        :type col: int
        :type val: int
        :rtype: void
        """
        i=row+1
        dif=val-self.A[row+1][col+1]
        
        self.A[row+1][col+1]=val
        while i< self.m+1:
            j=col+1
            while j<self.n+1:
                self.C[i][j]+=dif
                j+=self.lowbit(j)
            i+=self.lowbit(i)
                
            
        
    
    def lowbit(self,x):
        return x & (-x)
    
    def prefix_sum(self, row, col):
        i=row+1
        res=0
        while i>0:
            j=col+1
            while j>0:
                res+=self.C[i][j]
                j-=self.lowbit(j)
            i-=self.lowbit(i)
        return res
                
                
        

    def sumRegion(self, row1, col1, row2, col2):
        """
        :type row1: int
        :type col1: int
        :type row2: int
        :type col2: int
        :rtype: int
        """
        
        return self.prefix_sum(row2,col2)-self.prefix_sum(row2,col1-1)-self.prefix_sum(row1-1,col2)+self.prefix_sum(row1-1,col1-1)
        
matrix = [
  [3, 0, 1, 4, 2],
  [5, 6, 3, 2, 1],
  [1, 2, 0, 1, 5],
  [4, 1, 0, 1, 7],
  [1, 0, 3, 0, 5]
]
matrix = [[1]]
# Your NumMatrix object will be instantiated and called as such:
# obj = NumMatrix(matrix)
# obj.update(row,col,val)
# param_2 = obj.sumRegion(row1,col1,row2,col2) 
obj.update(3, 2, 2)
obj.update(0, 0, -1)
obj.sumRegion(0, 0, 0, 0)
obj.sumRegion(2, 1, 4, 3)       
        
#822. Reverse Order Storage        
class Solution:
    """
    @param head: the given linked list
    @return: the array that store the values in reverse order 
    """
    def reverseStore(self, head):
        # write your code here     
        if not head :
            return []
        cur=head
        res=[]
        while cur:
            res=[cur.val]+res
            cur=cur.next
        return res
            
        
#823. Input Stream
class Solution:
    """
    @param inputA: Input stream A
    @param inputB: Input stream B
    @return: The answer
    """
    def inputStream(self, inputA, inputB):
        # Write your code here   
        
        ra=''
        rb=''
        for a in inputA:
            if a=='<':
                ra=ra[:-1]
            else:
                ra+=a
        for b in inputB:
            if b=='<':
                rb=rb[:-1]
            else:
                rb+=b
        if ra==rb:
            res='YES'
        else:
            res='NO'
        return res
 
inputA = 'abcde<<'
inputB = 'abcd<e<'        
        
inputA = 'a<<bc'
inputB = 'abc<'       
        
if __name__ == "__main__":
    print(Solution().inputStream( inputA, inputB))        
        
#824. Single Number IV        
class Solution:
    """
    @param nums: The number array
    @return: Return the single number
    """
    def getSingleNumber(self, nums):
        # Write your code here  
        
        n=len(nums)
        pre=None
        for i,v in enumerate(nums):
            if i%2==0:
                pre=v
            else:
                if pre!=v:
                    return pre
  
        
nums = [3,3,2,2,4,5,5] 
nums = [2,1,1,3,3]   
if __name__ == "__main__":
    print(Solution().getSingleNumber( nums))         
    
#825. Bus Station
class Solution:
    """
    @param N: The number of buses
    @param route: The route of buses
    @param A: Start bus station
    @param B: End bus station
    @return: Return the minimum transfer number
    """
    def getMinTransferNumber(self, N, route, A, B):
        # Write your code here
        
        from collections import defaultdict,deque
        graph=defaultdict(set)
        Ai=[]
        Bi=[]
        for i,stops in enumerate(route):
            stops=set(stops)
            for stop1 in stops:
                for stop2 in stops:
                    if stop1==A:
                        Ai.append(i)
                    if stop1==B:
                        Bi.append(i)
                    if stop1!=stop2:
                       graph[stop1].add(stop2)
        #print(graph)
                
        q=deque([A])
        visited=set([A])
        transfer=0
        while q:
            temp=deque([])
            
            for _ in range(len(q)):
                stop=q.popleft()
                if stop==B:
                    return transfer
                for nextstop in graph[stop]:
                    if nextstop not in visited:
                       visited.add(nextstop)
                       temp.append( nextstop)
            transfer+=1
            q=temp
        return -1
        
N = 2
route = [[1, 2, 3, 4], [3, 5, 6, 7]]
A = 1
B = 4   

N = 2
route = [[1, 2, 3, 4], [3, 5, 6, 7]]
A = 1
B = 7 
N=20
route =[[7075,7330],[7075,3517],[651,6438],[3517,7075],[7330,83],[10989,5061],[651,6995],[7075,9913],[10989,651],[7437,83],[11189,3897],[6995,3517],[83,5734],[3897,3517],[6995,7330],[7330,10989],[9913,651],[3517,3897],[83,7437],[3897,7075]]
A = 83
B = 6438


N=20
route =[[7075,7330],[7075,3517],[651,6438],[3517,7075],[7330,83],[10989,5061],[651,6995],[7075,9913],[10989,651],[7437,83],[11189,3897],[6995,3517],[83,5734],[3897,3517],[6995,7330],[7330,10989],[9913,651],[3517,3897],[83,7437],[3897,7075]]
A =651
B =3517



if __name__ == "__main__":
    print(Solution().getMinTransferNumber( N, route, A, B))     

#826. Computer Maintenance 
class Solution:
    """
    @param n: the rows of matrix
    @param m: the cols of matrix
    @param badcomputers: the bad computers 
    @return: The answer
    """
    def maintenance(self, n, m, badcomputers):
        # Write your code here    
#        from collections import defaultdict
#        
#        comdict=defaultdict(list)
#        pre=badcomputers[0][0]
#        for i,j in badcomputers:
#            comdict[i].append(j)
#            if i!=pre:
#                comdict[pre].sort()
#                pre=i
#        
#        comdict[i].sort()
#        self.res=float('inf')
#        def walk(x,y,comdict,step):
#            
#            if x==n:
#                if self.res>step:
#                    self.res=step
#                return 
#            
#            if not comdict[x]:
#                walk(x+1,y,comdict,step)
#            else:
#                if y==0:
#                    
#                   walk(x+1,0,comdict,step+comdict[x][-1]*2) 
#                   walk(x+1,m-1,comdict,step+m-1)
#                elif y==m-1:
#                   walk(x+1,m-1,comdict,step+  (m-1-comdict[x][0])*2) 
#                   walk(x+1,0,comdict,step+m-1)
#        walk(0,0,comdict,0)
#        return self.res+n-1
        
        
#826. Computer Maintenance 
class Solution:
    """
    @param n: the rows of matrix
    @param m: the cols of matrix
    @param badcomputers: the bad computers 
    @return: The answer
    """
    def maintenance(self, n, m, badcomputers):
        dp=[[0,0] for _ in range(201)]
        matrix=[[0 for _ in range(201)]for _ in range(201)]
        
        for node in badcomputers:
            matrix[node.x][node.y]=1
        
        for i in range( n):
            most_right=-1
            most_left=-1
            for j in range(m):
                if matrix[i][j]!=0:
                   most_right=max(most_right,j)
                   most_left=max(most_left,m-1-j)
                if i==0:
                    if most_right==-1:
                        dp[0][0]=0
                        dp[0][1]=m-1
                    else:
                        dp[0][0]=most_right*2
                        dp[0][1]=m-1
                    continue
                if most_right!=-1:
                    dp[i][0]=min(dp[i-1][0]+most_right*2, dp[i-1][1] +m-1  )+1
                    dp[i][1]=min(dp[i-1][0]+m-1,most_left*2+dp[i-1][1])+1
                else:
                    dp[i][0]=dp[i-1][0]+1
                    dp[i][1]=dp[i-1][1]+1
        return min(dp[n-1][0],dp[n-1][1])
n = 3
m = 10
badcomputers = [[0,0],[0,9],[1,7]


n = 3
m = 10
badcomputers = [[0,3],[1,7],[1,2]]# return 17
n =30
m =30
badcomputers =[[29,22],[13,1],[12,16],[9,5],[17,21],[0,2],[29,14],[17,8],[23,4],[14,29],[25,27],[6,23],[10,24],[28,22],[1,28],[0,28],[3,23],[9,28],[7,3],[19,25],[29,21],[7,11],[3,19],[5,18],[22,16],[21,7],[10,5],[11,25],[12,26],[15,10],[10,15],[28,23],[25,10],[8,28],[5,25],[28,0],[12,14],[1,4],[2,14],[15,7],[22,2],[22,23],[29,5],[12,20],[7,19],[13,0],[24,26],[9,21],[21,29],[16,24],[14,4],[3,11],[24,12],[13,5],[21,28],[17,10],[29,9],[28,29],[28,11],[25,25],[1,11],[23,14],[10,22],[28,8],[24,5],[3,0],[4,12],[22,4],[10,23],[17,14],[5,0],[25,3],[17,24],[8,8],[28,21],[15,21],[3,27],[23,27],[0,6],[27,20],[20,17],[25,14],[0,20],[7,17],[22,8],[21,23],[23,28],[0,14],[19,14],[3,6],[0,29],[24,19],[8,17],[1,14],[21,9],[28,26],[27,11],[2,24],[14,7],[4,18]]    
if __name__ == "__main__":
    print(Solution().maintenance(n, m, badcomputers))         
    
    

#828. Word Pattern 
class Solution:
    """
    @param pattern: a string, denote pattern string
    @param teststr: a string, denote matching string
    @return: an boolean, denote whether the pattern string and the matching string match or not
    """
    def wordPattern(self, pattern, teststr):
        # write your code here
        mapping={}
        
        for a,b in zip(pattern,teststr.split()):
            if a not in mapping:
                mapping[a]=b
            else:
                if mapping[a]!=b:
                    return False
            if b not in mapping:
                mapping[b]=a
            else:
                if mapping[b]!=a:
                    return False
        return True
         
pattern = "abba"
teststr = "dog cat cat dog"

pattern = "abba"
teststr  = "dog cat cat fish"

pattern ="abba"
teststr  = "dog cat dog cat"
if __name__ == "__main__":
    print(Solution().wordPattern( pattern, teststr))         
    
            
        
#829. Word Pattern II
class Solution:
    """
    @param pattern: a string,denote pattern string
    @param str: a string, denote matching string
    @return: a boolean
    """
    def wordPatternMatch(self, pattern, string):
        # write your code here
      
        
        def search(pattern,string,dictps,dictsp):
            if not pattern  and not string  and len(dictps)==len(dictsp):
                return True
            if not pattern  or not string:
                return False
            
            
            p=pattern[0]
            if p in dictps:
                if string.startswith(dictps[p]):
                    
                    return search(pattern[1:],string[len(dictps[p]):],dictps,dictsp)
                else:
                    return False
            else:
                for i in range(len(string)):
                    
                    if string[:i+1] in dictsp:
                        return False
                    dictps[p]=string[:i+1]
                    
                    dictsp[string[:i+1]]=p
                    if search(pattern[1:],string[i+1:],dictps,dictsp):
                        return True
                    
                    del dictps[p]
                    #print(dictsp,string[:i+1],p)
                    del dictsp[string[:i+1]]
            return False
        dictps={}
        dictsp={}
        return search(pattern,string,dictps,dictsp)
                    

    
pattern = "abab"
string = "redblueredblue"# return true    
pattern = "aaaa"
string = "asdasdasdasd"# return true
pattern = "aabb"
string = "xyzabcxzyabc"# return false
pattern ="lwpstyfsjf"
string ="htkvcxwxkymrvrpcxw"    
if __name__ == "__main__":
    print(Solution().wordPatternMatch( pattern, string))         
    
                
#834. Remove Duplicate Letters
class Solution:
    """
    @param s: a string
    @return: return a string
    """
    def removeDuplicateLetters(self, s):
        # write your code here   
        stack=[]
        from collections import defaultdict
        d=defaultdict(int)
        
        for c in s:
            d[c]+=1
        
        visited={}
        for k in d:
            visited[k]=False
            
        for c in s:
            d[c]-=1
            
            if visited[c]:
                continue
            
            while stack and stack[-1]>c and d[stack[-1]]>0:
                visited[stack[-1]]=False
                stack.pop()
            stack.append(c)
            visited[c]=True
        return ''.join(stack)
   
s="bcabc"    #"abc"
s="cbacdcbc"    #"acdb"
if __name__ == "__main__":
    print(Solution().removeDuplicateLetters( s))             
    
#835. Hamming Distance    
class Solution:
    """
    @param x: an integer
    @param y: an integer
    @return: return an integer, denote the Hamming Distance between two integers
    """
    def hammingDistance(self, x, y):
        # write your code here
        dis=0
        while x!=0  or y!=0:
            
            if x%2 !=y%2:
                dis+=1
            x=x//2
            y=y//2
        return dis
    
x = 1
y = 4                
if __name__ == "__main__":
    print(Solution().hammingDistance( x, y))             
            
        
#836. Partition to K Equal Sum Subsets        
class Solution:
    """
    @param nums: a list of integer
    @param k: an integer
    @return: return a boolean, denote whether the array can be divided into k non-empty subsets whose sums are all equal
    """
    def partitiontoEqualSumSubsets(self, nums, k):
        # write your code here 
        
        total=sum(nums)
        if total%k!=0:
            return False
        
        target=total//k
        
        nums.sort()
        if nums[-1]>target:
            return False
        
        while nums and nums[-1]==target:
            nums.pop()
            k-=1
        
        def search(groups):
            if not nums:
                return True
            
            v=nums.pop()
            
            for i,group in enumerate(groups):
                if group+v<=target:
                    groups[i]=group+v
                    if search(groups):
                        return True
                    groups[i]-=v
                if group==0:
                    break
            nums.append(v)
            return False
        return search([0]*k)
nums = [4, 3, 2, 3, 5, 2, 1]
k = 4  
nums =[3,10,20,36,6,8,6,89,73,80,16,161,90,87,55,160]
k =5                  
if __name__ == "__main__":
    print(Solution().partitiontoEqualSumSubsets( nums, k))                
            
                
#837. Palindromic Substrings       
class Solution:
    """
    @param str: s string
    @return: return an integer, denote the number of the palindromic substrings
    """
    def countPalindromicSubstrings(self, string):
        # write your code here       
        l=len(string)
        dp=[[False for _ in range(l)]  for _ in range(l)]
        count=0
        
        for i in range(l):
            dp[i][i]=True
            count+=1
            
            if i+1< l and string[i]==string[i+1]:
                dp[i][i+1]=True
                count+=1
        
        
        for length in range(3,l+1):
            for i in range(l-length+1):
                j=i+length-1
                if dp[i+1][j-1] and string[i]==string[j]:
                    dp[i][j]=True
                    count+=1
        return count
                    
 
string= "abc"  
string= "aaaa"       
if __name__ == "__main__":
    print(Solution().countPalindromicSubstrings( string))                
                    
        
#838. Subarray Sum Equals K
class Solution:
    """
    @param nums: a list of integer
    @param k: an integer
    @return: return an integer, denote the number of continuous subarrays whose sum equals to k
    """
    def subarraySumEqualsK(self, nums, k):
        # write your code here    
        n=len(nums)
        
        sumn=[0 for _ in range(n+1)]
        for i in range(1,n+1):
            sumn[i]=sumn[i-1]+nums[i-1]
        
        res=0
        
        from collections import defaultdict
        sumdict=defaultdict(int)
        
        for x in sumn:
            sumdict[x]+=1
        #print(sumdict)
        for x in sumn:
            sumdict[x]-=1
            res+=sumdict[x+k]
        return res
            
        
nums = [1,1,1]
k = 2    
if __name__ == "__main__":
    print(Solution().subarraySumEqualsK( nums, k))                
                        
    
#839. Merge Two Sorted Interval Lists    
"""
Definition of Interval.
class Interval(object):
    def __init__(self, start, end):
        self.start = start
        self.end = end
"""

class Solution:
    """
    @param list1: one of the given list
    @param list2: another list
    @return: the new sorted list of interval
    """
    def mergeTwoInterval(self, list1, list2):
        # write your code here
        
        
        if list1 is None or list2 is None:
            return []
        
#        if not list1:
#            return list2
#        if not list2:
#            return list1
        
        i=0
        j=0
        
        res=[]
        def add(interval,res):
            if len(res)==0:
                res.append(interval)
            else:
                if interval.start>res[-1].end:
                    res.append(interval)
                else:
                    res[-1].end=max(res[-1].end,interval.end)
        
        while i < len(list1)  and j < len(list2):
            if lista[i].start<list2[j].start:
                add(list1[i],res)
                i+=1
            else:
                add(list2[j],res)
                j+=1
        
        while i < len(list1):
             add(list1[i],res)
             i+=1
            
            
        while j < len(list2):
             add(list2[j],res) 
             j+=1
        return res
            
        
        
        
        
        
list1 = [(1,2),(3,4)] 
list2 = [(2,3),(5,6)]

list1 =[Interval(1,2),Interval(3,4)]
list2 = [Interval(2,3),Interval(5,6)]
if __name__ == "__main__":
    print(Solution().mergeTwoInterval( list1, list2))                
                        
#840. Range Sum Query - Mutable
class NumArray(object):

    def __init__(self, nums):
        """
        :type nums: List[int]
        """
        self.A=[0 for _ in range(len(nums))]
        self.bits=[0 for _ in range(len(nums)+1)]
        for i in range(len(nums)):
            self.update(i,nums[i])
        

    def update(self, i, val):
        """
        :type i: int
        :type val: int
        :rtype: void
        """
        delta=val-self.A[i]
        self.A[i]=val
        
        j=i+1
        
        while j<len(self.bits):
            self.bits[j]+=delta
            j+=self.lowbit(j)
        
        
        
    def lowbit(self,j):
        return j & (-j)
    
    def prefix_sum(self,i):
        j=i
        res=0
        while j>=1:
            res+=self.bits[j]
            j-=self.lowbit(j)
        return res
        

    def sumRange(self, i, j):
        """
        :type i: int
        :type j: int
        :rtype: int
        """
        return self.prefix_sum(j+1)-self.prefix_sum(i)


# Your NumArray object will be instantiated and called as such:
# obj = NumArray(nums)
# obj.update(i,val)
# param_2 = obj.sumRange(i,j)                
    
    
#845. Greatest Common Divisor    
class Solution:
    """
    @param a: the given number
    @param b: another number
    @return: the greatest common divisor of two numbers
    """
    def gcd(self, a, b):
        # write your code here
        
        if a==0:
            return b
        return self.gcd(b%a,a)
a = 15
b = 10    


if __name__ == "__main__":
    print(Solution().gcd( a, b))                
                            
    
#846. Multi-keyword Sort    
class Solution:
    """
    @param array: the input array
    @return: the sorted array
    """
    def multiSort(self, array):
        # Write your code here
        from collections import defaultdict
        dic=defaultdict(list)
        
        for i in range(len(array)):
            dic[array[i][1]].append(array[i][0])
        
        od=sorted (dic.keys(),reverse=True)
        ans=[]
        print(od)
        for score in od:
            for i in sorted(dic[score]):
                ans.append([i,score])
        return ans
        
        
array=[[2,50],[1,50],[3,100]]
if __name__ == "__main__":
    print(Solution().multiSort( array))    
    
#848. Minimize Max Distance to Gas Station
class Solution:
    """
    @param stations: an integer array
    @param k: an integer
    @return: the smallest possible value of D
    """
    def minmaxGasDist(self, stations, k):
        # Write your code here
        
        n=len(stations)
        import math
        def isValid(gap,stations, k):
            count=0
            for i in range(n-1):
              dis=  stations[i+1]-stations[i]
              count+= math.ceil(dis/gap)-1
            return count<=k
        
        left=0
        right=10**8
        
        while right-left>1e-6:
            
            mid=(left+right)/2
            if isValid(mid,stations, k):
                right=mid
            else:
                left=mid
        return mid
            
stations = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
k = 9        
if __name__ == "__main__":
    print(Solution().minmaxGasDist( stations, k))        
        
# -*- coding: utf-8 -*-
"""
Created on Tue Sep 25 01:32:57 2018

@author: cz
"""

#849. Basic Calculator III
class Solution:
    """
    @param s: the expression string
    @return: the answer
    """
    def calculate(self, s):
        # Write your code here
        op='+'
        s=s.replace(' ','')
        res=0
        curres=0
        num=0
        n=len(s)
        i=0
        
        while i<n:
            #print(i,num,curres,res)
            c=s[i]
            #print(c)
           
            
            if c>='0' and c<='9':
               num=num*10+ord(c)-ord('0')
               
               #print(num)
            elif c=='(':
                
                cnt=0
                j=i
                
                while i<n:
                    if s[i]=='(':
                        cnt+=1
                    elif s[i]==')':
                        cnt-=1
                    #print(i,j)
                    if cnt==0:
                        break
                    i+=1
                #print(s[j+1:i])
                num=self.calculate(s[j+1:i])
                
            if c=='+' or c=='-' or c=='*' or c=='/' or i==n-1 :
                print(num,op,c,curres,res)
                if op=='+':
                    curres+=num
                elif op=='-':
                    curres-=num
                elif op=='*':
                    curres*=num
                elif op=='/':
                    curres//=num
                
                if c=='+' or c=='-' or i==n-1:
                    res+=curres
                    curres=0
                op=c
                num=0
            i+=1
        return res
                    
s="1+2*9" #= 2 
s=" 6-4 / 2 " 
s="2*(5+5*2)/3+(6/2+8)"
s="(2+6* 3+5- (3*14/7+2)*5)+3"              
if __name__ == "__main__":
    print(Solution().calculate(s))         
            
#851. Pour Water                        
class Solution:
    """
    @param heights: the height of the terrain
    @param V: the units of water
    @param K: the index
    @return: how much water is at each index
    """
    def pourWater(self, heights, V, K):
        # Write your code here
        n=len(heights)
        for i in range(V):
            l=K
            r=K
            while l>0 and heights[l]>=heights[l-1]:
                  l-=1
            while l<K and heights[l]==heights[l+1]:
                  l+=1
            while r<n-1 and heights[r]>=heights[r+1]:
                  r+=1
            while r>K and heights[r]==heights[r-1]:
                  r-=1
            if heights[l]<heights[K]:
                heights[l]+=1
            else:
                heights[r]+=1
        return heights
                
heights = [2,1,1,2,1,2,2]
V = 4
K = 3    
heights = [1,2,3,4]
V = 2
K = 2 
heights = [3,1,3]
V = 5
K = 1           
if __name__ == "__main__":
    print(Solution().pourWater( heights, V, K))                 
            
#853. Number Of Corner Rectangles
class Solution:
    """
    @param grid: the grid
    @return: the number of corner rectangles
    """
    def countCornerRectangles(self, grid):
        # Write your code here   
        rows=[[i  for i,v in enumerate(row) if v] for row in grid]
        N=sum(  sum(row) for row in grid)
        target=N**0.5
        from collections import defaultdict
        count=defaultdict(int)
        ans=0
        import itertools
        
        for r ,row  in enumerate(rows):
            if len(row)>target:
                rset=set(row)
                for r2,row2 in enumerate(rows):
                    if r2<=r and len(row2)>target:
                        continue
                    f=sum( 1 for v in row2 if v in rset)
                    print(f)
                    ans+=f*(f-1)//2
                    
            else:
                
                for pair in itertools.combinations(row,2):
                    ans+=count[pair]
                    count[pair]+=1
        print(count)
        return ans
            
                    
     

grid = [[1, 0, 0, 1, 0],
 [0, 0, 1, 0, 1],
 [0, 0, 0, 1, 0],
 [1, 0, 1, 0, 1]] 
grid = [[1, 1, 1],
 [1, 1, 1],
 [1, 1, 1]]   
grid =[[1, 1, 1, 1]]
if __name__ == "__main__":
    print(Solution().countCornerRectangles( grid))      
    
    
#854. Closest Leaf in a Binary Tree    


class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None

class Node:
    def __init__(self, val):
        self.val = val
        self.leftness=0
        self.left, self.right,self.parent = None, None,None
class Solution:
    """
    @param root: the root
    @param k: an integer
    @return: the value of the nearest leaf node to target k in the tree
    """
    def findClosestLeaf(self, root, k):
        # Write your code here
        if not root:
            return None
        node=Node(root.val)
        node.leftness=0
        self.tranverse(node,root)
        k_node=self.find(node,k)
            
        from collections import deque
        q=deque([k_node])
        visited=set([k_node])
        res=[]
        found=False
        while q:
            for _ in range(len(q)):
                anode=q.popleft()
                if not anode.left and not anode.right:
                    found=True
                    res.append((anode.leftness,anode.val ))
                if anode.left  and anode.left not in visited:
                    visited.add(anode.left)
                    q.append(anode.left)
                if anode.right  and anode.right not in visited:
                    visited.add(anode.right)
                    q.append(anode.right)
                if anode.parent  and anode.parent not in visited:
                    visited.add(anode.parent)
                    q.append(anode.parent)
            if found:
                res.sort()
                return res[0][1]
        return None
    def tranverse(self,node,root):
            if not root.left and not root.right:
                return 
            if root.left:
                left=Node(root.left.val)
                left.parent=node
                node.left=left
                left.leftness=node.leftness-1
                self.tranverse(left,root.left)
            if root.right:
                right=Node(root.right.val)
                right.parent=node
                node.right=right
                right.leftness=node.leftness+1
                self.tranverse(right,root.right)
                
        
        
    def find(self,node,k):
            if node is None:
               return None
            if k == node.val:
               return node 
            left = self.find(node.left, k)    
            right = self.find(node.right, k)
            if left:
               return left
            if right:
               return right
            return None    
        
        
                    
root=TreeNode(1)
root.left=TreeNode(3)
root.right=TreeNode(2)
k=1

root = TreeNode(1)
k = 1

root = TreeNode(1)
root.left=TreeNode(2)
root.right=TreeNode(3)
root.left.left=TreeNode(4)
root.left.left.left=TreeNode(5)
root.left.left.left.left=TreeNode(6)
if __name__ == "__main__":
    print(Solution().findClosestLeaf( root, k))             
        
        
#856. Sentence Similarity
class Solution:
    """
    @param words1: a list of string
    @param words2: a list of string
    @param pairs: a list of string pairs
    @return: return a boolean, denote whether two sentences are similar or not
    """
    def isSentenceSimilarity(self, words1, words2, pairs):
        # write your code here 
        if len(words1)!=len(words2):
            return False
        
        for w1,w2 in zip(words1,words2):
            if [w1,w2] not in pairs  and [w2,w1]  not in pairs:
                return False
        return True
        
        
words1=["great","acting","skills"]
words2=["fine","drama","talent"]
pairs=[["great","fine"],["drama","acting"],["skills","talent"]]        
if __name__ == "__main__":
    print(Solution().isSentenceSimilarity( words1, words2, pairs))              
        
        
#857. Minimum Window Subsequence
class Solution:
    """
    @param S: a string
    @param T: a string
    @return: the minimum substring of S
    """
    def minWindow(self, S, T):
        # Write your code here
        m=len(S)
        n=len(T)
        
        dp=[[-1 for _ in range(n+1)] for _ in range(m+1)]
        
        for i in range(m+1):
            dp[i][0]=i
            
        res=float('inf')
        start=-1
        for i in range(1,m+1):
            for j in range(1,min(n,i)+1):
                if S[i-1]==T[j-1]:
                    dp[i][j]=dp[i-1][j-1]
                else:
                    dp[i][j]=dp[i-1][j]
                if dp[i][n]!=-1:
                    length=i-dp[i][n]
                    if res>length:
                       res=length
                       start=dp[i][n]
        if start==-1:
            return ''
        else:
            return S[start:res+start]
S = "abcdebdde"
T = "bde"        
if __name__ == "__main__":
    print(Solution().minWindow( S, T))              
                
#858. Candy Crush
class Solution:
    """
    @param board: a 2D integer array
    @return: the current board
    """
    def candyCrush(self, board):
        # Write your code here
        
        m=len(board)
        if m==0:
            return board
        n=len(board[0])
        
        
        while True:
            deletion=[]
            for i in range(m):
                for j in range(n):
                   if board[i][j]==0:
                        continue
                   x0=i
                   x1=i
                   y0=j
                   y1=j
                   while x0>=0 and x0 >i-3 and board[i][j]==board[x0][j]:
                       x0-=1
                   while x1<m and x1 <i+3 and board[i][j]==board[x1][j]:
                       x1+=1
                   while y0>=0 and y0 >j-3 and board[i][j]==board[i][y0]:
                       y0-=1
                   while y1<n and y1 <j+3 and board[i][j]==board[i][y1]:
                       y1+=1
                   if x1-x0>3 or y1-y0>3:
                       deletion.append((i,j))
            if not deletion:
                break
            for x,y in deletion:
                board[x][y]=0
            
            for j in range(n):
                t=m-1
                for i in range(m-1,-1,-1):
                    if board[i][j]:
                         board[i][j],board[t][j]=board[t][j],board[i][j]
                         t-=1
        return board
 
board=[[110,5,112,113,114],
 [210,211,5,213,214],
 [310,311,3,313,314],
 [410,411,412,5,414],
 [5,1,512,3,3],
 [610,4,1,613,614],
 [710,1,2,713,714],
 [810,1,2,1,1],
 [1,1,2,2,2],
 [4,1,4,4,1014]]        
        
if __name__ == "__main__":
    print(Solution().candyCrush( board))     
    
#860. Number of Distinct Islands    
class Solution:
    """
    @param grid: a list of lists of integers
    @return: return an integer, denote the number of distinct islands
    """
    def numberofDistinctIslands(self, grid):
        # write your code here
        m=len(grid)
        if m==0:
            return 0
        n=len(grid[0])
        from collections import deque
        ans=0
        check=set()
        for i in range(m):
            for j in range(n):
                if grid[i][j]==1:
                    
                     q=deque([(i,j)])
                     grid[i][j]==0
                     path=''
                     
                     while q:
                         x,y=q.popleft()
                         for nx,ny in ((x+1,y),(x-1,y),(x,y+1),(x,y-1)):
                             if nx>=0 and ny>=0 and nx<m and ny<n and grid[nx][ny]==1:
                                 q.append((nx,ny))
                                 grid[nx][ny]=0
                                 path+=str(nx-i)+str(ny-j)
                     if path not in check:
                        check.add(path)
                        ans+=1
        return ans
grid =[
[1,1,0,0,0],
[1,1,0,0,0],
[0,0,0,1,1],
[0,0,0,1,1]
]
grid =[
[1,1,0,1,1],
[1,0,0,0,0],
[0,0,0,0,1],
[1,1,0,1,1]
]        
if __name__ == "__main__":
    print(Solution().numberofDistinctIslands( grid))                                    
        
        
#861. K Empty Slots
class Solution:
    """
    @param flowers: the place where the flower will open in that day
    @param k:  an integer
    @return: in which day meet the requirements
    """
    def kEmptySlots(self, flowers, k):
        # Write your code here 
        if not flowers:
            return -1
        slot2bloomday=self.getSlot2Bloomdat(flowers)
        segTree=self.buildSegTree(slot2bloomday,0,len(slot2bloomday)-1)
        
        earliest=len(slot2bloomday)+1
        minbloomday=None
        for slot in range(len(slot2bloomday)-k-1):
            minbloomday=self.getMin( segTree, slot+1, slot+k)
            candidate=max( slot2bloomday[slot],  slot2bloomday[slot+k+1]    )
            if candidate<minbloomday:
                if candidate+1 <earliest:
                    earliest=candidate+1
        return earliest if earliest!=len(slot2bloomday)+1 else -1
    
    
    def getSlot2Bloomdat(self,flowers):
        slot2bloomday=[0 for _ in range(len(flowers))]
        for day , slot in enumerate(flowers):
            slot2bloomday[slot-1]=day
        return slot2bloomday
    
    
    
    # The following code is for segment tree
    class Node:
        def __init__(self,minval,start,end,left=None,right=None):
            self.minval=minval
            self.start=start
            self.end=end
            self.left=left
            self.right=right
    def buildSegTree(self,nums,start,end):
        if start>end:
            return None
        if start==end:
            return self.Node(nums[start],start,end)
        
        mid=(start+end)//2
        left=self.buildSegTree(nums,start,mid)
        right=self.buildSegTree(nums,mid+1,end)
        minval=float('inf')
        
        if left:
            minval=min(minval,left.minval)
        if right:
            minval=min(minval,right.minval)
        return self.Node(minval,start,end,left,right)
    
    def getMin(self, node, start, end):
        if start<=node.start and end>=node.end:
            return node.minval
        mid=(node.start+node.end)//2
        lvalue=float('inf')
        rvalue=float('inf')
        if mid>=start:
            lvalue=self.getMin(node.left,start,end)
        if mid+1<=end:
            rvalue=self.getMin(node.right,start,end)
        return min(lvalue,rvalue)
            
            
            
        
        
        
flowers = [1,3,2]
k = 1# return 2.        
        
flowers = [1,2,3]
k = 1# return -1.        


if __name__ == "__main__":
    print(Solution().kEmptySlots( flowers, k))         
        
        
#861. K Empty Slots
class Solution:
    """
    @param flowers: the place where the flower will open in that day
    @param k:  an integer
    @return: in which day meet the requirements
    """
    def kEmptySlots(self, flowers, k): 
        
#https://github.com/kamyu104/LeetCode/blob/master/Python/k-empty-slots.py 
#http://www.cnblogs.com/grandyang/p/8415880.html
        n=len(flowers)
        days=[0 for _ in range(n)]
        for day,position in enumerate(flowers):
            days[position-1]=day+1
        
        right=k+1
        left=0
        i=0
        res=float('inf')
        while right<n:
            if days[i]<days[left]  or days[i] <=days[right]:
                if i==right:
                    res=min(res,  max(days[left],days[right]))
                left=i
                right=i+k+1
            i+=1
        return res if res<float('inf') else -1
                
                    
        
            
            
        
flowers = [1,3,2]
k = 1# return 2.        
        
flowers = [1,2,3]
k = 1# return -1.        


if __name__ == "__main__":
    print(Solution().kEmptySlots( flowers, k))              
        
#862. Next Closest Time        
class Solution:
    """
    @param time: the given time
    @return: the next closest time
    """
    def nextClosestTime(self, time):
        # write your code here   
        
        h,m=time.split(':')
        curr=int(h)*60+int(m)
        
        for t in range(curr+1,curr+1441):
            res=t%1440
            h=res//60
            m=res%60
            result="%02d:%02d" %(h,m)
            
            if set(result)<=set(time):
                return result
        
time = "19:34"    
time = "23:59"    
if __name__ == "__main__":
    print(Solution().nextClosestTime(time))                      
        
#863. Binary Tree Path Sum IV
class Solution:
    """
    @param nums: a list of integers
    @return: return an integer
    """
    def pathSum(self, nums):
        # write your code here    
        dmap={1:0}
        
        leaves=set([1])
        
        for num in nums:
            path,value=num//10,num%10
            level,pos=path//10,path%10
            
            parent=(level-1)*10+(pos+1)//2
            
            dmap[path]=dmap[parent]+value
            
            leaves.add(path)
            
            if parent in leaves:
                leaves.remove(parent)
        return sum(dmap[v] for v in leaves)
            
        
        
        
#864. Equal Tree Partition
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""

class Solution:
    """
    @param root: a TreeNode
    @return: return a boolean
    """
    def checkEqualTree(self, root):
        # write your code here
        
        def treeSum(node,res):
            if not node:
                return res
            if not node.left and not node.right:
                return node.val+res
            if not node.left:
                return node.val+res+treeSum(node.right,0)
            if not node.right:
                return node.val+res+treeSum(node.left,0)
           
            return node.val+res+treeSum(node.left,0)+treeSum(node.right,0)
        allsum=treeSum(root,0)
        if allsum%2==1:
            return False
        target=allsum//2
        
        from collections import deque
        if not root:
            return False
        
        q=deque([])
        
        if not root.left and not root.right:
            return False
        
        if root.left:
            q.append(root.left)
        if root.right:
            q.append(root.right)
        
        while q:
           cur= q.popleft()
           if treeSum(cur,0)==target:
               return True
           if cur.left:
               q.append(cur.left)
           if cur.right:
               q.append(cur.right)
        return False
           
   
        
root=TreeNode(5)        
root.left=    TreeNode(10) 
root.right=    TreeNode(10)        
root.right.left=  TreeNode(2)        
root.right.right=   TreeNode(3)        

    1
   / \
  2  10
    /  \
   2   20    

root=TreeNode(1)        
root.left=    TreeNode(2) 
root.right=    TreeNode(10)        
root.right.left=  TreeNode(2)        
root.right.right=   TreeNode(20)     
    
if __name__ == "__main__":
    print(Solution().checkEqualTree(root))                      
                
#865. Remove 9
class Solution:
    """
    @param n: an integer
    @return: return an long integer
    """
    def newInteger(self, n):
        # write your code here
        #0，1，2，3，4，5，6，7，8 （移除了9）
#10，11，12，13，14，15，16，17，18 （移除了19）
#.....
#
#80，81，82，83，84，85，86，87，88 （移除了89）
#（移除了 90 - 99 ）
#100，101，102，103，104，105，106，107，108 （移除了109）
#我们可以发现，8的下一位就是10了，18的下一位是20，88的下一位是100，
#实际上这就是九进制的数字的规律，那么这道题就变成了将十进制数n转为九进制数，这个就没啥难度了
#，就每次对9取余，然后乘以base，n每次自除以9，base每次扩大10倍，参见代码如下：
        res=0
        base=1
        
        while n:
            res+=n%9 * base
            n=n//9
            base=base*10
        return res
 
        
n=10 
n=100
n=1000               
if __name__ == "__main__":
    print(Solution().newInteger(n))                      
                                  
#866. Coin Path        
class Solution:
    """
    @param A: a list of integer
    @param B: an integer
    @return: return a list of integer
    """
    def cheapestJump(self, A, B):
        # write your code here
        Adict={}
        N=len(A)
        for i,a in enumerate(A):
            Adict[i+1]=a
        
        from collections import deque,defaultdict
        
        q=deque([ (1, '1',Adict[1]) ])
        res=float('inf')
        resDict=defaultdict(list)
        while q:
            
            index,path,curSum=q.popleft()
            if index==N:
                if curSum <= res:
                    res=curSum
                    resDict[res].append(path)
            else:
                for jump in range(1,B+1):
                    if index+jump <=N  and Adict[index+jump]!=-1:
                        q.append( ( index+jump,path  + str(index+jump),curSum+Adict[index+jump] ))
        if res!=float('inf'):
           return [int(x) for x in resDict[res][0]]
        else:
            return []
        
A = [1,2,4,-1,2]
B = 2

A = [1,2,4,-1,2]
B = 1
A =[36,33,18,55,98,14,77,43,6,97,49,72,62,48,68,65,22,18,63,44,14,4,99,52,52,23,47]
B = 50
if __name__ == "__main__":
    print(Solution().cheapestJump( A, B))                     
                    
            
#866. Coin Path        
class Solution:
    """
    @param A: a list of integer
    @param B: an integer
    @return: return a list of integer
    """
    def cheapestJump(self, A, B): 
        N=len(A)
        cost=[float('inf')  for _ in range(N+1)]
        path=[[] for _ in range(N+1) ]
        
        cost[1]=A[0]
        path[1]=[1]
        
        for x in range(2,N+1):
            if A[x-1]==-1:
                continue
            for y in range(1,B+1):
                z=x-y
                if z>=1:
                   if A[z-1]==-1:
                      continue
                   if cost[x]>cost[z]+A[x-1]  or ( cost[x]==cost[z]+A[x-1] and path[x]>path[z]+[x]):
                       cost[x]=cost[z]+A[x-1]
                       path[x]=path[z]+[x]
        return path[-1]
        
A = [1,2,4,-1,2]
B = 2

A = [1,2,4,-1,2]
B = 1
A =[36,33,18,55,98,14,77,43,6,97,49,72,62,48,68,65,22,18,63,44,14,4,99,52,52,23,47]
B = 50
if __name__ == "__main__":
    print(Solution().cheapestJump( A, B))           
        
#867. 4 Keys Keyboard
class Solution:
    """
    @param N: an integer
    @return: return an integer
    """
    def maxA(self, N):
        # write your code here  
        
        dp=[0 for _ in range(N+1)]
        dp[1]=1
        dp[2]=2
        dp[3]=3

        for i in range(4,N+1):
            dp[i]=i
            prev=i-3
            count=2
            while prev>0:
                dp[i]=max(dp[i],dp[prev]*count)
                prev-=1
                count+=1
        return dp[N]
            
        
        
N = 3  
N = 7# return 9      
if __name__ == "__main__":
    print(Solution().maxA( N))           
            
#868. Maximum Average Subarray
class Solution:
    """
    @param nums: an array
    @param k: an integer
    @return: the maximum average value
    """
    def findMaxAverage(self, nums, k):
        # Write your code here
        n=len(nums)
        
        cursum=sum(nums[:k-1])
        res=float('-inf')
        for i in range(k-1,n):
            cursum+=nums[i]
            res=max(res,cursum/k)
            cursum-=nums[i-k+1]
        return res
nums = [1,12,-5,-6,50,3]
k = 4
if __name__ == "__main__":
    print(Solution().findMaxAverage(nums, k))            
            
        
#869. Find the Derangement of An Array        
class Solution:
    """
    @param n: an array consisting of n integers from 1 to n
    @return: the number of derangement it can generate
    """
    def findDerangement(self, n):
        # Write your code here
        
#n = 1 时有 0 种错排
#n = 2 时有 1 种错排 [2, 1]
#n = 3 时有 2 种错排 [3, 1, 2], [2, 3, 1]
#我们来想n = 4时该怎么求，我们假设把4排在了第k位，这里我们就让k = 3吧，
#那么我们就把4放到了3的位置，变成了：
#x x 4 x
#我们看被4占了位置的3，应该放到哪里，这里分两种情况，如果3放到了4的位置，那么有：
#x x 4 3
#那么此时4和3的位置都确定了，实际上只用排1和2了，那么就相当于只排1和2，就是dp[2]的值，
#是已知的。那么再来看第二种情况，3不在4的位置，那么此时我们把4去掉的话，就又变成了：
#x x x
#这里3不能放在第3个x的位置，在去掉4之前，这里是移动4之前的4的位置，那么实际上这又变成了排1，2，3
#的情况了，就是dp[3]的值。
#再回到最开始我们选k的时候，我们当时选了k = 3，其实k可以等于1,2,3，也就是有三种情况，
#所以dp[4] = 3 * (dp[3] + dp[2])。
#那么递推公式也就出来了：
#dp[i] = (i - 1) * (dp[i - 1] + dp[i - 2])
        
#        dp=[0 for _ in range(n+1)]
#        dp[1]=0
#        dp[2]=1
#        for i in range(3,n+1):
#            dp[i]=(i-1)*(dp[i-1]+dp[i-2])
#        return dp[n]%(10**9+7)
        
#我们假设 e[i] = dp[i] - i * dp[i - 1]
#
#递推公式为:  dp[i] = (i - 1) * (dp[i - 1] + dp[i - 2])
#
#将递推公式带入假设，得到：
#
#e[i] = -dp[i - 1] + (n - 1) * dp[i - 2] = -e[i - 1]
#
#从而得到 e[i] = (-1)^n
#
#那么带回假设公式，可得: dp[i] = i * dp[i - 1] + (-1)^n        
        
    
        if n==1:
            return 0
        if n==2:
            return 1
    
        first=0
        second=1
        temp=1
        for i in range(3,n+1):
            temp*=(-1)
            third=(i*second+temp)%(10**9+7)
            
            second=third
        return third%(10**9+7)


#871. Minimum Factorization
class Solution:
    """
    @param a: a positive integer
    @return: the smallest positive integer whose multiplication of each digit equals to a
    """
    def smallestFactorization(self, a):
        # Write your code here
        
        def decompose(x):
            if x<10:
              return [x]
        
            else:
              for i in range(9,1,-1):
                if x%i==0:
                    ans=decompose(x//i)+[i]
                    return ans
        ans=[]
        
        ans=decompose(a)
        print
        res=0
        if not ans:
            return 0
        else:
            ans.sort()
            if ans[-1]>9:
                return 0
            else:
                for j in range(len(ans)):
                    res*=10
                    res+=ans[j]
                
                return res if res<2**31 else 0
a=48
a=15     
a=18000000               
if __name__ == "__main__":
    print(Solution().smallestFactorization( a))            


#872. Kill Process
class Solution:
    """
    @param pid: the process id
    @param ppid: the parent process id
    @param kill: a PID you want to kill
    @return: a list of PIDs of processes that will be killed in the end
    """
    def killProcess(self, pid, ppid, kill):
        # Write your code here
        from collections import defaultdict
        
        graph=defaultdict(list)
        
        for s,p in zip(pid,ppid):
            graph[p].append(s)
            
        ans=[kill]
        
        def getChild(k):
            
            for c in graph[k]:
                ans.append(c)
                getChild(c)
        getChild(kill)
        return ans
              
            

pid = [1, 3, 10, 5]
ppid = [3, 0, 5, 3]
kill = 5# return [5,10]
           3
         /   \
        1     5
             /
            10


if __name__ == "__main__":
    print(Solution().killProcess(pid, ppid, kill))            


#873. Squirrel Simulation
class Solution:
    """
    @param height: the height
    @param width: the width
    @param tree: the position of tree
    @param squirrel: the position of squirrel
    @param nuts: the position of nuts
    @return: the minimal distance 
    """
    def minDistance(self, height, width, tree, squirrel, nuts):
        # Write your code here
        m=height
        n=width
        
        res=0
        maxdiff=float('-inf')
        
        for nut in nuts:
            dist=abs(tree[0]-nut[0])+abs(tree[1]-nut[1])
            res+=dist*2
            
            maxdiff=max(maxdiff,abs(tree[0]-nut[0])+abs(tree[1]-nut[1])-abs(squirrel[0]-nut[0])-abs(squirrel[1]-nut[1])  )
        return res-maxdiff


#那么正确思路应该是，假设小松树最先应该去粟子i，那么我们假设粟子i到树的距离为x，
#小松鼠到粟子i的距离为y，那么如果小松鼠不去粟子i，累加步数就是2x，如果小松鼠去粟子i，
#累加步数就是x+y，我们希望x+y尽可能的小于2x，那么就是y尽可能小于x，即x-y越大越好 



             
height = 5
width = 7
tree = [2,2]
squirrel = [4,4]
nuts = [[3,0], [2,5]]              
           
height = 1
width =3
tree =[0,1]
squirrel =[0,0]
nuts = [[0,2]]

height = 2
width =2
tree =[0,0]
squirrel =[1,1]
nuts =[[1,0]]

height =5
width =5
tree =[3,2]
squirrel =[0,1]
nuts =[[2,0],[4,1],[0,4],[1,3],[1,0],[3,4],[3,0],[2,3],[0,2],[0,0],[2,2],[4,2],[3,3],[4,4],[4,0],[4,3],[3,1],[2,1],[1,4],[2,4]]


if __name__ == "__main__":
    print(Solution().minDistance(height, width, tree, squirrel, nuts))            



#874. Maximum Vacation Days
class Solution:
    """
    @param flights: the airline status from the city i to the city j
    @param days: days[i][j] represents the maximum days you could take vacation in the city i in the week j
    @return: the maximum vacation days you could take during K weeks
    """
    def maxVacationDays(self, flights, days):
        # Write your code here
#http://bookshadow.com/weblog/2017/04/30/leetcode-maximum-vacation-days/        
        N=len(days)
        k=len(days[0])
        
        dp=[[-1 for _ in range(N)]  for _ in range(k+1)]
        
        dp[0][0]=0
        
        for w in range(k):
            
            for sc in range(N):
                if dp[w][sc]<0:
                    continue
                for tc in range(N):
                    if sc==tc  or flights[sc][tc]!=0:
                        dp[w+1][tc]=max(dp[w+1][tc] ,dp[w][sc] +days[tc][w] )
        return max(dp[k])
        
flights = [[0,1,1],[1,0,1],[1,1,0]]
days = [[1,3,1],[6,0,3] ,[3,3,3]]       
if __name__ == "__main__":
    print(Solution().maxVacationDays( flights, days))                    
                    
            
#875. Longest Line of Consecutive One in Matrix                
class Solution:
    """
    @param M: the 01 matrix
    @return: the longest line of consecutive one in the matrix
    """
    def longestLine(self, M):
        # Write your code here
        
        m=len(M)
        if m==0:
            return 0
        n=len(M[0])
        def isHbegin( x,y ):
            if y==0 or M[x][y-1]==0:
                return True
            return False
        
        def isVbegin( x,y ):
            if x==0 or M[x-1][y]==0:
                return True
            return False
        
        def isDbegin( x,y ):
            if x==0 or y==0 or  M[x-1][y-1]==0:
                return True
            return False
        
        def isADbegin( x,y ):
            if x==0 or y==n-1 or  M[x-1][y+1]==0:
                return True
            return False
        
        def HDFS(x,y):
            res=0
            while y<n and M[x][y]==1:
                y+=1
                res+=1
            return res
        
        def VDFS(x,y):
            res=0
            while x<m and M[x][y]==1:
                x+=1
                res+=1
            return res
        
        def DDFS(x,y):
            res=0
            while x<m and y<n and M[x][y]==1:
                x+=1
                y+=1
                res+=1
            return res
                
        def ADDFS(x,y):
            res=0
            while x<m and y>=0 and M[x][y]==1:
                x+=1
                y-=1
                res+=1
            return res       
        ans=float('-inf')
        for i in range(m):
            for j in range(n):
                tempH=0
                tempV=0
                tempD=0
                tempAD=0
                
                if M[i][j]==1:
                
                   if isHbegin( i,j ):
                       temp=HDFS( i,j)
                       if temp>ans:
                           ans=temp
                           
                   if isVbegin(  i,j ):
                       temp=VDFS( i,j)
                       if temp>ans:
                           ans=temp
                
                   if isDbegin(  i,j ):
                       temp=DDFS( i,j)
                       if temp>ans:
                           ans=temp
                   if isADbegin(  i,j):
                       temp=ADDFS( i,j)
                       if temp>ans:
                           ans=temp
        return ans if ans > 0 else 0

M =[
    [0,1,1,0],
    [0,1,1,0],
    [0,0,0,1]
]
if __name__ == "__main__":
    print(Solution().longestLine( M))       



#876. Split Concatenated Strings
class Solution:
    """
    @param strs: a list of string
    @return: return a string
    """
    def splitLoopedString(self, strs):
        # write your code here
        res='a'
        S=''
        
        for s in strs:
            temp=s[::-1]
            S+=max(s,temp)
        
        curIndex=0
        for i in range(len(strs)):
            tempIndex=len(strs[i])
            p1=strs[i]
            p2=p1[::-1]
            
            body=S[curIndex+tempIndex:]+S[:curIndex]
            curIndex+=tempIndex
            
            for j in range(tempIndex):
                if p1[j]>=res[0]:
                    res=max(p1[j:]+body+p1[:j] ,res)
                if p2[j]>=res[0]:
                    res=max(p2[j:]+body+p2[:j] ,res)
        return res
strs = ["abc", "xyz"]        

if __name__ == "__main__":
    print(Solution().splitLoopedString( strs))       



#877. Split Array with Equal Sum
class Solution:
    """
    @param nums: a list of integer
    @return: return a boolean
    """
    def splitArray(self, nums):
        # write your code here
        n=len(nums)
        lasttarget=None
        for i in range(1,n-3):
            target=sum(nums[:i])
            if lasttarget==target:
              continue
            lasttarget=target
            sumj=0
            for j in range(i+1,n-2):
                #print(sumj)
                sumj+=nums[j]
                if sumj > target:
                    break
                elif sumj==target:
                    sumk=0
                    for k in range(j+2,n-1):
                        sumk+=nums[k]
                        #print(i,j,sumj,sumk)
                        if sumk > target:
                           break
                        elif sumk==target:
                             if sum(nums[k+2:])==target:
                                 return True
                             else:
                                 break
        return False
                        
    
#0 < i, i + 1 < j, j + 1 < k < n - 1            
#(0, i - 1), (i + 1, j - 1), (j + 1, k - 1) (k + 1, n - 1)         
  
nums = [1,2,1,2,1,2,1]
nums = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1]        
if __name__ == "__main__":
    print(Solution().splitArray( nums))       
        
#878. Boundary of Binary Tree
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""

class Solution:
    """
    @param root: a TreeNode
    @return: a list of integer
    """
    def boundaryOfBinaryTree(self, root):
        # write your code here
        
        self.left=[]
        self.right=[]
        self.leaves=[]
        
        def find_left(node):
            self.left.append(node.val)
            if node.left and not is_leaves(node.left):
                find_left(node.left)
            elif not node.left and not is_leaves(node.right):
                find_left(node.right)
                
                
            
        
        def find_right(node):
            self.right.append(node.val)
            if node.right and not is_leaves(node.right):
                find_right(node.right)
            elif not node.right and not is_leaves(node.left):
                find_right(node.left)
        
        def find_leaves(node):
            
            if node.left:
                find_leaves(node.left)
            if is_leaves(node):
                self.leaves.append(node.val)
            if node.right:
                find_leaves(node.right)
        
        def is_leaves(node):
            return not node.left and not node.right
        
        if not root:
            return []
        
        if root.left and not is_leaves(root.left):
            find_left(root.left)
        if root.right and not is_leaves(root.right):
            find_right(root.right)
        
        if not is_leaves(root):
            find_leaves(root)
        
        return [root.val]+self.left+self.leaves+list(reversed(self.right))
            
            
        
        
        
        
        
        
        
        
            
            
                
        


#879. Output Contest Matches
class Solution:
    """
    @param n: a integer, denote the number of teams
    @return: a string
    """
    def findContestMatch(self, n):
        # write your code here








        
#880. Construct Binary Tree from String        
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""

class Solution:
    """
    @param s: a string
    @return: a root of this tree
    """
    def str2tree(self, s):
        # write your code here
        
        def parse(st):
            count=0
            left=''
            if not st:
                return None,None
            for i,c in enumerate(st):
                if c=='(':
                   count+=1
                elif c==')':
                   count-=1
                if count==0:
                    
                    break
            left=None
            right=None
            if len(st[:i+1])>0:
                left=st[1:i]
            if len(st[i+1:])>0:
                right=st[i+2:-1]
            return left,right
        
        def build(S):
            if not S:
                return None
            print(S)
            if S.isdigit():
                root=TreeNode(int(S))
                return root
            
            i=0
            while i<len(S) and (S[i]=='-' or S[i].isdigit()):
                i+=1
            root=TreeNode(int(S[:i]))
            left,right=parse(S[i:])
            
            left_child=build(left)
            right_child=build(right)
            root.left=left_child
            root.right=right_child
            return root
        return build(s)
                
                


s = "4(2(3)(1))(6(5))"
s = "-4(2(3)(1))(6(5))"
s = "1(2(3(4(5(6(7(8)))))))(9(10(11(12(13(14(15)))))))"
s = "351(821(568(621)(725))(516(622)(250)))(387(576(568))(607(835)(97)))"

       4
     /   \
    2     6
   / \   / 
  3   1 5  

if __name__ == "__main__":
    print(Solution().str2tree( s))  


#879. Output Contest Matches
class Solution:
    """
    @param n: a integer, denote the number of teams
    @return: a string
    """
    def findContestMatch(self, n):
        # write your code here
        S=[]
        for i in range(1,n+1):
            S.append(str(i))
        
        while n>1:
            for i in range(n//2):
                S[i]='('+S[i]+','+S[n-1-i]+')'
            n=n//2
            #print(S)
        
        return S[0]
n=8
if __name__ == "__main__":
    print(Solution().findContestMatch( n))  


#883. Max Consecutive Ones II        
class Solution:
    """
    @param nums: a list of integer
    @return: return a integer, denote  the maximum number of consecutive 1s
    """
    def findMaxConsecutiveOnes(self, nums):
        # write your code here 
        temp=[]
        zero=0
        one=0
        i=0
        while i < len(nums):
            
            while i < len(nums) and  nums[i]==0:
                zero+=1
                i+=1
            if zero >0:
                if zero>1:
                   temp.append('2')
                else:
                   temp.append('1')
                zero=0
                
            
            while i < len(nums) and  nums[i]==1:
                one+=1
                i+=1
            if one>0:
                temp.append(one)
                one=0
        print(temp)
        
        res=float('-inf')
        cur=0
        
        for j in range(len(temp)):
            if temp[j]=='1':
                if j>0:
                    cur+=temp[j-1]
                if j<len(temp)-1:
                    cur+=temp[j+1]
            res=max(res,cur+1)
            cur=0
        return res
            
            
                
nums = [1,0,1,1,0]# return 4              
                
if __name__ == "__main__":
    print(Solution().findMaxConsecutiveOnes(nums))  
            
            
#884. Find Permutation            
class Solution:
    """
    @param s: a string
    @return: return a list of integers
    """
    def findPermutation(self, s):
        # write your code here 
        n=len(s)
        res=[i for i in range(1,n+2)]
        
        i=0
        while i< n:
            
            if s[i]=='D':
               j=i
               
               while i<n and s[i]=='D':
                   i+=1
               res[j:i+1]=res[j:i+1][::-1]
               i-=1
               
            i+=1
               
        return res
            
            
        
        
s="DI"        
s='DDIIDI'       
if __name__ == "__main__":
    print(Solution().findPermutation( s))  
                    
#885. Encode String with Shortest Length        
class Solution:
    """
    @param s: a string
    @return: return a string
    """
    def encode(self, s):
        # write your code here
        #https://segmentfault.com/a/1190000008341304
        #其中dp[i][j]表示s在[i, j]范围内的字符串的缩写形式(如果缩写形式长度大于子字符串，那么还是保留子字符串)
        n=len(s)
        dp=[['' for _ in range(n)]for _ in range(n)]
        for i in range(n):
            dp[i][i]=s[i]
        
        for step in range(1,n+1):
            for i in range(n-step):
                j=i+step
                
                for k in range(i,j):
                    left=len(dp[i][k])
                    right=len(dp[k+1][j])
                    if not dp[i][j] or left+right<len(dp[i][j]):
                        dp[i][j]=dp[i][k]+dp[k+1][j]
                t=s[i:j+1]
              
                pos=(t+t).find(t,1)
                if pos<len(t):
                    t=str(len(t)//pos)+'['+dp[i][i+pos-1]+']'
                    
                if not dp[i][j] or len(t)<len(dp[i][j]):
                        dp[i][j]=t
        print(dp)
        return dp[0][n-1]
                        
                        
s = "aaa"                
s = "aaaaa"  
s = "aaaaaaaaaa" 
s = "aabcaabcd"   
s = "abbbabbbcabbbabbbc" 
if __name__ == "__main__":
    print(Solution().encode( s)) 


#886. Convex Polygon
class Vector:
    def __init__(self,x,y):
        self.x=x
        self.y=y
class Solution:
    """
    @param point: a list of two-tuples
    @return: a boolean, denote whether the polygon is convex
    """
    def isConvex(self, point):
        # write your code here
#已知A、B两点的坐标，求向量AB、向量BA的坐标：（1）A（3，5）B（6，9）
#AB=(6,9)-(3,5)=(3,4)
#BA=(3,5)-(6,9)=(-3,-4)
#验证边向量叉乘，当aXb<0时，b对应的线段在a的顺时针方向；当aXb=0时，a、b共线；当aXb>0时，
#b在a的逆时针方向。
#
#注意的是我们一开始不知道逆时针顺时针顺序，所以只需要所有的 相邻向量乘积都是同号即可
#
#先建立边的向量组，再两两验证即可
#叉积的运用（此处在之后的凸包和极角排序会用用到）：
#叉积运算结果为一个向量
#例如： a=（x1,y1）,b=(x2,y2) n为向量
#则 a×b=（x1y2-x2y1)n;
#a×b>0 则说明 b在a的左上方
#a×b<0 则说明b在a的右下方
        n=len(point)
        vectors=[None for _ in range(n) ]
        
        for i in range(n-1):
            vectors[i]=Vector(point[i+1][0]-point[i][0],point[i+1][1]-point[i][1])
            
        
        vectors[n-1]=Vector(point[0][0]-point[n-1][0],point[0][1]-point[n-1][1])
        
        cur=0
        prev=0
        
        for i in range(n-1):
            cur=vectors[i].x*vectors[i+1].y-vectors[i+1].x*vectors[i].y
            #print(prev,cur)
            if cur!=0:
                if cur*prev<0:
                    return False
                else:
                    prev=cur
        cur=vectors[n-1].x*vectors[0].y-vectors[0].x*vectors[n-1].y
        if cur*prev<0:
            return False
        else:
            return True
        
point = [[0, 0], [0, 1], [1, 1], [1, 0]]    
point = [[0, 0], [0, 10], [10, 10], [10, 0], [5, 5]]    
if __name__ == "__main__":
    print(Solution().isConvex( point))         

#887. Ternary Expression Parser
class Solution:
    """
    @param expression: a string, denote the ternary expression
    @return: a string
    """
    def parseTernary(self, expression):
        # write your code here
        
        def parse(s):
            n=len(s)
            if n==1:
                return s
            count1=0
            count2=0
            for i in range(n-1):
                if s[i]=='?':
                    count1+=1
                elif s[i]==':':
                    count2+=1
                    if count1==count2:
                        if s[0]=='T':
                            return parse(s[2:i])
                        else:
                            return parse(s[i+1:])
                
        return parse(expression)
                
expression = "T?2:3" # "2"
expression = "F?1:T?4:5" #"4"
expression = "T?T?F:5:3"#"F"
if __name__ == "__main__":
    print(Solution().parseTernary( expression))         


#888. Valid Word Square
class Solution:
    """
    @param words: a list of string
    @return: a boolean
    """
    def validWordSquare(self, words):
        # Write your code here
        m=len(words)
        col=[]
        
        rawl=[]
        coll=[]
        
        for i,row in enumerate(words):
            for j in range(len(row)):
                if i >= len(words[j]):
                    return False
                if words[i][j]!=words[j][i]:
                    return False
        return True
        
words=[
  "abcd",
  "bnrt",
  "crmy",
  "dtye"
]        
        
words=[
  "abcd",
  "bnrt",
  "crm",
  "dt"
]        
        
words=[
  "ball",
  "area",
  "read",
  "lady"
]        
if __name__ == "__main__":
    print(Solution().validWordSquare( words)) 

#889. Sentence Screen Fitting
class Solution:
    """
    @param sentence: a list of string
    @param rows: an integer
    @param cols: an integer
    @return: return an integer, denote times the given sentence can be fitted on the screen
    """
    def wordsTyping(self, sentence, rows, cols):
        # Write your code here
        
#        row=0
#        col=-1
#        n=len(sentence)
#        count=0
#        
#        temp={}
#        for i in range(n):
#            temp[i]=sentence[i]
#        sentence=temp
#            
#        
#        while True:
#        
#            for i in range(n):
#                
#                l=len(sentence[i])
#                #print(row,col,sentence[i],l,count)
#                if col!=-1:
#                  if col+1+l==cols-1:
#                     col=-1
#                     row+=1
#                  elif col+1+l>cols-1:
#                     col=l-1
#                     if col == cols-1:
#                         col=-1
#                         row+=2
#                     else:              
#                         
#                         row+=1
#                  else:
#                    col=col+l+1
#                else:
#                    if col+l==cols-1:
#                       col=-1
#                       row+=1
#                    elif col+l>cols-1:
#                       col=l-1
#                       if col == cols-1:
#                         col=-1
#                         row+=2
#                       else:              
#                         
#                         row+=1
#                    else:
#                       col=col+l
#            if col==-1 and row==rows:
#                    return count+1
#                
#            elif row>=rows :
#                    return count
#                
#            count+=1
#        

#https://medium.com/@rebeccahezhang/leetcode-418-sentence-screen-fitting-9d6258ce116e
#0      7     13          25
#abc de f abc de f abc de f
#XXXXXX
#       XXXXXX 
#             XXXXXX
#                  XXXXXX 
#                         X....
#abc-de
#f-abc-
#de-f--
#abc-de
#f...

        string=''
        for s in sentence:
            string+=s+' '
        n=len(string)
        start=0
        for row in range(rows):
            start+=cols
            if string[start%n]==' ':
                start+=1
            else:
                while start>0 and string[(start-1)%n]!=' ':
                    start-=1
        return start//n
                
            
            


   
rows = 2
cols = 8
sentence = ["hello", "world"]

#hello---
#world---


rows = 3
cols = 6
sentence = ["a", "bcd", "e"]
#a-bcd- 
#e-a---
#bcd-e-

rows = 4
cols = 5
sentence = ["I", "had", "apple", "pie"]


#I-had
#apple
#pie-I
#had--
sentence =["bcgqp", "xlqayc", "jzsxzhu", "ycxbxpxllq", "xqhz", "xtkegmw", "rtmye", "sxszyk", "mogkdakn", "tul", "jfn", "wh", "lldk", "schxgncgw", "jfdosso", "vnmxlag", "vkfo", "pzn", "nvyhr", "cqkerpihgn", "rrlggse"]
rows = 868
cols =942

sentence =["dfasaje", "yq", "nutwaqrxr", "hib", "fuoek", "msmlym", "rxkb", "g", "kxudip", "mt", "ezgdoxrjta", "xal", "ozfzdpp", "iqibu", "tuggjitblt", "jp", "m", "eqrkedg", "ojsg", "ksopshzvy", "xsukuxlqvo", "ln", "km", "osyq", "jeapard", "suq", "kgawxc", "ycpxhxzx", "iyz", "yfbqgcpl", "qfcqz", "nd", "wzgfu", "u", "trsn", "wutobt", "tdyz", "emqavunxf", "iok", "mtjclq", "gjbniqx", "wkuvit", "yalyp", "oqsbo", "zierybnyv", "rqyawhshit", "fpyexnqjnu", "djc", "tllwsfaei", "xv", "afp", "g", "jrjv", "cmtnkszzm", "fvbtrwaom", "rpyvzmzzni", "x", "cdqeitxbl", "zmvlow", "zhwus", "qe", "rzabtpalr", "c", "mbdbde", "d", "inisv", "pjwrunw", "yqnjztb", "bpp", "qqnnzrwvna", "fa", "bfq", "nwon", "ddklo", "iaxoozc", "nqn", "rwxdosoya", "qsxh", "nqq", "bj", "wgjf", "ekjerybaxq", "jbdudsyqne", "psohf", "prmj", "frpaxvra", "bjr", "fisirjwkq", "lily", "eyldhxrj", "bjuwf", "kvt", "glqa", "z", "rkn", "sgf", "k", "uwgda", "edtcfou", "hc"]
rows =20000
cols =20000
if __name__ == "__main__":
    print(Solution().wordsTyping(sentence, rows, cols)) 
        
#891. Valid Palindrome II
class Solution:
    """
    @param s: a string
    @return: nothing
    """
    def validPalindrome(self, s):
        # Write your code here
       
        
        def check(s):
               if not s:
                  return True
               n=len(s)
               if n==1:
                  return True
               left=0
               right=n-1
               while left<right:
                   if s[left]!=s[right]:
                       return False
                   left+=1
                   right-=1
               return True
                   
            
        if  check(s):
            return True
        n=len(s)
        left=0
        right=n-1
        while left<right:
            if s[left]!=s[right]:
#                print(s[left],s[right])
#                print(s[:left]+s[left:])
#                print(s[:right]+s[right:])
#                print(check(s[:left]+s[left:]))
#                print(check(s[:right]+s[right:]))
                if check(s[:left]+s[left+1:])   or check(s[:right]+s[right+1:]) :
                   
                    return True
                else:
                    return False
            left+=1
            right-=1
s = "aba" #return true
s = "abca" #return true
if __name__ == "__main__":
    print(Solution().validPalindrome( s))

        
#892. Alien Dictionary
class Solution:
    """
    @param words: a list of words
    @return: a string which is correct order
    """
    def alienOrder(self, words):
        # Write your code here
        from collections import defaultdict
        graph={ch : [] for word in words for ch in word}
        indegree={ch:0  for word in words for ch in word}
        
        for i in range(len(words)-1):
            for pos in range(min(len(words[i]),len(words[i+1]))):
                pre=words[i][pos]
                nxt=words[i+1][pos]
                if pre!=nxt:
                    indegree[nxt]+=1
                    graph[pre].append(nxt)
                    break
        
        import heapq
        print(indegree)
        heap=[w for w in indegree if indegree[w]==0]
        heapq.heapify(heap)
        order=[]
        while heap:
            for _ in range(len(heap)):
                word=heapq.heappop(heap)
                order.append(word)
                for child in graph[word]:
                    indegree[child]-=1
                    if indegree[child]==0:
                        heapq.heappush(heap,child)
        print(order)
        if len(order)!=len(indegree):
            return ''
        return ''.join(order)
                        
words=["wrt","wrf","er","ett","rftt"]        
if __name__ == "__main__":
    print(Solution().alienOrder(words)) 
                
        
#900. Closest Binary Search Tree Value        
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""

class Solution:
    """
    @param root: the given BST
    @param target: the given target
    @return: the value in the BST that is closest to the target
    """
    def closestValue(self, root, target):
        # write your code here
        
        self.mindif=float('inf')
        self.res=None
        def tranverse(node):
            
            if node.left:
                tranverse(node.left)
            dif=abs(node.val-target)
            if dif < self.mindif:
                self.res=node.val
                self.mindif=dif
            if node.right:
                tranverse(node.right)
        tranverse(root)
        return self.res
                
        
        
#901. Closest Binary Search Tree Value II
 """
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""

class Solution:
    """
    @param root: the given BST
    @param target: the given target
    @param k: the given k
    @return: k values in the BST that are closest to the target
    """
    def closestKValues(self, root, target, k):
        # write your code here
       
        self.res=[]
        self.count=0
        def tranverse(node):
            if self.count>2*k:
                return 
            
            if node.left:
                tranverse(node.left)
            dif=abs(node.val-target)
            
            self.res.append((dif,node.val))
            self.count+=1
            if self.count>2*k:
                    return 
                
            if node.right:
                tranverse(node.right)
        tranverse(root)
        self.res.sort()
        ans=[]
        for i in range(k):
            ans.append(self.res[i][1])
        return self.ans
        
        
        
#902. Kth Smallest Element in a BST
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""

class Solution:
    """
    @param root: the given BST
    @param k: the given k
    @return: the kth smallest element in BST
    """
    def kthSmallest(self, root, k):
        # write your code here  
        self.count=0
        self.res=None
        def tranverse(node):
            
            if self.count <k and node.left:
                tranverse(node.left)
            self.count+=1
            if self.count==k:
                self.res=node.val
                return 
            if self.count <k and node.right:
                tranverse(node.right)
        tranverse(root)
        return self.res
        
#903. Range Addition                
class Solution:
    """
    @param length: the length of the array
    @param updates: update operations
    @return: the modified array after all k operations were executed
    """
    def getModifiedArray(self, length, updates):
        # Write your code here  
        array=[0 for _ in range(length)]   
        add=[0 for _ in range(length+1)]
        
        for start,end,step in updates:
            add[start]+=step
            add[end+1]-=step
        
        array[0]=add[0]
        for i in range(1,length):
            array[i]=array[i-1]+add[i]
        return array
        
#        for start,end,step in updates:
#            for i in range(start,end+1):
#                array[i]+=step
#        return array
length = 5 
updates =[
[1,  3,  2],
[2,  4,  3],
[0,  2, -2]
]
#return [-2, 0, 3, 5, 3]        
if __name__ == "__main__":
    print(Solution().getModifiedArray(length, updates)) 
                        
        
#904. Plus One Linked List        
"""
Definition of ListNode
class ListNode(object):
    def __init__(self, val, next=None):
        self.val = val
        self.next = next
"""

class Solution:
    """
    @param head: the first Node
    @return: the answer after plus one
    """
    def plusOne(self, head):
        # Write your code here
        def add(node):
            if not node:
                return 1
            carry=add(node.next)
            sm=carry+node.val
            node.val=sm%10
            return sm//10
        
        carry=add(head)
        if carry==1:
            newhead=ListNode(1)
            newhead.next=head
            return newhead
        else:
            return head


#906. Sort Transformed Arra
class Solution:
    """
    @param nums: a sorted array
    @param a: 
    @param b: 
    @param c: 
    @return: a sorted array
    """
    def sortTransformedArray(self, nums, a, b, c):
        # Write your code here
        def cal(x):
            return a*x*x+b*x+c
        
        n=len(nums)
        res=[0 for _ in range(n)]
        
        if a==0 and b==0:
            return [c for _ in range(n)]        
        elif  a==0 and b!=0:
            
            for i in range(n):
                res[i]=cal(nums[i])
            return res if b>0 else res[::-1]
        else:
            left=0
            right=n-1
            if a>0:
                idx=n-1
            else:
                idx=0
                
            while left<=right:
                #print(left,right)
                left_val=cal(nums[left])
                right_val=cal(nums[right])
                #print(left_val,right_val)
                if a>0:
                   
                   if left_val>right_val:
                      res[idx]=left_val
                      left+=1
                      idx-=1
                   else:
                      res[idx]=right_val
                      right-=1
                      idx-=1
                else:
                    
                    if left_val<right_val:
                       res[idx]=left_val
                       left+=1
                       idx+=1
                    else:
                       res[idx]=right_val
                       right-=1
                       idx+=1
                #print(res)
        return res
                    
nums = [-4, -2, 2, 4]
a = 1
b = 3
c = 5# return [3, 9, 15, 33] 

nums = [-4, -2, 2, 4]
a = -1
b = 3
c = 5# return [-23, -5, 1, 7]           
if __name__ == "__main__":
    print(Solution().sortTransformedArray(nums, a, b, c))                     
            
                
#908. Line Reflection
class Solution:
    """
    @param points: n points on a 2D plane
    @return: if there is such a line parallel to y-axis that reflect the given points
    """
    def isReflected(self, points):
        # Write your code here
        
        mi=float('inf')
        ma=float('-inf')
        
        from collections  import defaultdict 
        m=defaultdict(list)
        for point in points:
            mi=min(mi,point[0])
            ma=max(ma,point[0])
            m[point[0]].append(point[1])
        
        y=(mi+ma)/2
        
        #print(m)
        for point in points:
            t=(mi+ma)-point[0]
            #print(point[0],t)
            m[point[0]].sort()
            m[t].sort()
            
            if m[point[0]]!=m[t]:
                return False
        return True
            
            
            
        
                
  
            
points = [[1,1],[-1,1]]# return true
points = [[1,1],[-1,-1]]# return false
points = [[0,0],[1,0]]        
points =[[1,1],[-3,1]]        
if __name__ == "__main__":
    print(Solution().isReflected(points))               
        
        
        
#909. Android Unlock Patterns        
class Solution:
    """
    @param m: an integer
    @param n: an integer
    @return: the total number of unlock patterns of the Android lock screen
    """
    def numberOfPatterns(self, m, n):
        # Write your code here
        visited=[False for _ in range(10)]
#| 1 | 2 | 3 |
#| 4 | 5 | 6 |
#| 7 | 8 | 9 | 
#http://www.cnblogs.com/grandyang/p/5541012.html
        jumps=[[0 for _ in range(10)]  for _ in range(10)]
        
        jumps[1][3]=2
        jumps[3][1]=2
        jumps[4][6]=5
        jumps[6][4]=5
        jumps[7][9]=8
        jumps[9][7]=8
        
        jumps[1][7]=4
        jumps[7][1]=4
        jumps[2][8]=5
        jumps[8][2]=5
        jumps[3][9]=6
        jumps[9][3]=6
              
              
        jumps[1][9]=5
        jumps[9][1]=5
        jumps[3][7]=5
        jumps[7][3]=5
        
        
        def dfs(num,l,res,m,n,visited,jumps):
            if l>=m :
                res+=1
            l+=1
            
            if l>n :
                return res
            visited[num]=True
            for nxt in range(1,10):
                jump=jumps[num][nxt]
                if not visited[nxt]  and ( jump==0 or visited[jump]):
                    res=dfs(nxt,l,res,m,n,visited,jumps)
            visited[num]=False
            return res
        
        ans=0
        ans+=dfs(1,1,0,m,n,visited,jumps)*4
        ans+=dfs(2,1,0,m,n,visited,jumps)*4
        ans+=dfs(5,1,0,m,n,visited,jumps)
        return ans
m=1
n=1

m=1
n=2

if __name__ == "__main__":
    print(Solution().numberOfPatterns( m, n))                       
                
        
#911. Maximum Size Subarray Sum Equals k        
class Solution:
    """
    @param nums: an array
    @param k: a target value
    @return: the maximum length of a subarray that sums to k
    """
    def maxSubArrayLen(self, nums, k):
        # Write your code here   
        from collections import defaultdict
        table=defaultdict(list)
        maxindex=0
        total=0
        table[0]=[-1]
        for i , num in enumerate(nums):
            total+=num
            if total-k in table:
                maxindex=max(maxindex,i-table[total-k][0])
            table[total].append(i)
            #print(i,table, total)
        return maxindex
nums = [1, -1, 5, -2, 3]
k = 3
nums = [-2, -1, 2, 1]
k = 1
if __name__ == "__main__":
    print(Solution().maxSubArrayLen( nums, k))                
        

#912. Best Meeting Point
class Solution:
    """
    @param grid: a 2D grid
    @return: the minimize travel distance
    """
    def minTotalDistance(self, grid):
        # Write your code here

        
#[思路] 二维的等于一维的相加, 一维的最小点必在median点(用反证法可以证明)   
        
        def calculate(array):
            array.sort()
            
            res=0
            
            n=len(array)
            left=0
            right=n-1
            
            while left<right:
                
                res+=array[right]-array[left]
                left+=1
                right-=1
            return res
        if len(grid)==0:
            return 0
        x=[]
        y=[]
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j]==1:
                    x.append(i)
                    y.append(j)
        return calculate(x)+calculate(y)
grid=[[1,0,0,0,1],[0,0,0,0,0],[0,0,1,0,0]]            
if __name__ == "__main__":
    print(Solution().minTotalDistance(grid))              
            
#913. Flip Game II            
class Solution:
    """
    @param s: the given string
    @return: if the starting player can guarantee a win
    """
    memo={}
    def canWin(self, s):
        # write your code here 
        if s in self.memo:
            return self.memo[s]
        
        for i in range(len(s)-1):
            if s[i:i+2]=='++':
                temp=s[:i]+'--'+s[i+2:]
                flag=self.canWin(temp)
                if not flag:
                    return True
                self.memo[temp]=flag
        return False
s='++++'            
if __name__ == "__main__":
    print(Solution().canWin(s))              
                       
#914. Flip Game            
class Solution:
    """
    @param s: the given string
    @return: all the possible states of the string after one valid move
    """
    def generatePossibleNextMoves(self, s):
        # write your code here
        n=len(s)
        if n<2:
            return []
        
        res=[]
        for i in range(n-1):
            if s[i]=='+'  and s[i+1]=='+':
                res.append(s[:i]+'--'+s[i+2:])
        return res
            
            
            
s = "++++"
[
  "--++",
  "+--+",
  "++--"
]            
if __name__ == "__main__":
    print(Solution().generatePossibleNextMoves( s))              

#915. Inorder Predecessor in BST                                   
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""

class Solution:
    """
    @param root: the given BST
    @param p: the given node
    @return: the in-order successor of the given node in the BST
    """
    def inorderSuccessor(self, root, p):
        # write your code here
        self.prev=None
        self.res=False
        def tranverse(node):
            if self.res:
                return 
            
            if node.left:
                tranverse(node.left)
            if node==p:
                self.res=self.prev
                return 
            else:
                self.prev=node
            if node.right:
                tranverse(node.right)
        tranverse(root)
        return self.res
        
        
#916. Palindrome Permutation
class Solution:
    """
    @param s: the given string
    @return: if a permutation of the string could form a palindrome
    """
    def canPermutePalindrome(self, s):
        # write your code here
        from collections import Counter
        
        count=Counter(s)
        
        odd=0
        for v in count.values():
            if v%2==1:
                odd+=1
            if odd==2:
                return False
        return True

s = "code"
s = "aab"
s = "carerac"
if __name__ == "__main__":
    print(Solution().canPermutePalindrome(s))     


#917. Palindrome Permutation II
class Solution:
    """
    @param s: the given string
    @return: all the palindromic permutations (without duplicates) of it
    """
    def generatePalindromes(self, s):
        # write your code here
        
        if not s:
            return []
        
        from collections import Counter
        count=Counter(s)
        
        if len(count)==1:
            return [s]
        odd=''
        string=''
        oddcount=0
        for k,v in count.items():
            if v%2==1:
                odd=k
                oddcount+=1
            string+=k*(v//2)
        
        #print(string)
        if oddcount>1:
            return []
        ans=set()
        
        def permutation(cur,s,odd):
            if not s:
                ans.add(cur[:] +odd+cur[::-1])
                
            for i in range(len(s)):
                permutation(cur+s[i],s[:i]+s[i+1:],odd)
        permutation('',string,odd)
        return list(ans)
            
            
#918. 3Sum Smaller
class Solution:
    """
    @param nums:  an array of n integers
    @param target: a target
    @return: the number of index triplets satisfy the condition nums[i] + nums[j] + nums[k] < target
    """
    def threeSumSmaller(self, nums, target):
        # Write your code here
        
        n=len(nums)
        if n==0:
            return []
        if n<3:
            return []
        
        nums.sort()
        count=0
        
        for i in range(n-2):
            
           start=i+1
           end=n-1
           while start<end:
               total=nums[i]+nums[start]+nums[end]
               if total<target:
                   count+=end-start
                   start+=1
               else:
                   end-=1
        return count
nums = [-2,0,1,3]
target = 2# return 2            
if __name__ == "__main__":
    print(Solution().threeSumSmaller( nums, target))     

        
#919. Meeting Rooms II
"""
Definition of Interval.
class Interval(object):
    def __init__(self, start, end):
        self.start = start
        self.end = end
"""

class Solution:
    """
    @param intervals: an array of meeting time intervals
    @return: the minimum number of conference rooms required
    """
    def minMeetingRooms(self, intervals):
        # Write your code here
        
        def meeting(intervals):
             n=len(intervals)
             if n==0:
                 return 0
             if n==1:
                return 1
             intervals.sort(key=lambda x: (x.start,x.end) )
             newmeeting=[]
             i=0
             j=i+1
             
             while j<n:
                 
                 while j<n and  intervals[i].end>intervals[j].start:
                     newmeeting.append(intervals[j])
                     j+=1
                 i=j
                 j=i+1
             return 1+meeting(newmeeting)
        return meeting(intervals)
intervals=[(0,30),(5,10),(15,20)]   
intervals=[(567707,730827),(166232,719216),(634677,756013),(285191,729059),(237939,915914),(201296,789707),(578258,585240),(164298,218749),(37396,968315),(666722,934674),(742749,824917),(141115,417022),(613457,708897),(343495,994363),(380250,428265),(214441,493643),(588487,811879),(97538,262361)]     
if __name__ == "__main__":
    print(Solution().minMeetingRooms( intervals))     
                
        
#920. Meeting Rooms        
"""
Definition of Interval.
class Interval(object):
    def __init__(self, start, end):
        self.start = start
        self.end = end
"""

class Solution:
    """
    @param intervals: an array of meeting time intervals
    @return: if a person could attend all meetings
    """
    def canAttendMeetings(self, intervals):
        # Write your code here
        
        n=len(intervals)
        if n<2:
            return True
        intervals.sort(key=lambda x: (x.start,x.end) )
        for i in range(n-1):
            if intervals[i].end>intervals[i+1].start:
                return False
        return True
            
        
        
        
intervals = [[0,30],[5,10],[15,20]]        
intervals =  [(465,497),(386,462),(354,380),(134,189),(199,282),(18,104),(499,562),(4,14),(111,129),(292,345)]       
if __name__ == "__main__":
    print(Solution().canAttendMeetings( intervals))     
        
#921. Count Univalue Subtrees
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""

class Solution:
    """
    @param root: the given tree
    @return: the number of uni-value subtrees.
    """
    def countUnivalSubtrees(self, root):
        # write your code here
        self.count=0
        
        def dfs(node):
            if not node:
                return True
            
            left=dfs(node.left)
            right=dfs(node.right)
            
            if left and right:
                if node.left and node.left.val!=node.val:
                    return False
                if node.right and node.right.val!=node.val:
                    return False
                self.count+=1
                return True
            return False
        dfs(root)
        return self.count
                
                    
#927. Reverse Words in a String II
class Solution:
    """
    @param str: a string
    @return: return a string
    """
    def reverseWords(self, string):
        # write your code here
          return ' '.join(string.split()[::-1])            
        
        
#937. How Many Problem Can I Accept
class Solution:
    """
    @param n: an integer
    @param k: an integer
    @return: how many problem can you accept
    """
    def canAccept(self, n, k):
        # Write your code here   
        target=2*n/k
        import math
        
        start=int(math.floor(target**0.5))
        
        while start*(start+1)<=target:
            start+=1
        return start-1
n = 30
k = 1            
if __name__ == "__main__":
    print(Solution().canAccept( n, k))          
        
        
#941. Sliding Puzzle
class Solution:
    """
    @param board: the given board
    @return:  the least number of moves required so that the state of the board is solved
    """
    def slidingPuzzle(self, board):
        # write your code here 
        cur=''.join([ str(i) for i in  board[0]+board[1]])
        swap={0:(1, 3) ,1:(0, 2, 4),2:(1, 5),3:(0, 4),4:(1, 3, 5),5:(2, 4)}
        from collections import deque
        
        cur_list=deque([cur])
        
        
        visited=set([cur])
        
        
        step=0
        while cur_list:
            #print(cur_list)
            nx_list=deque([])
            for _ in range(len(cur_list)):
                cur=cur_list.popleft()
                if cur=='123450':
                    return step
                
                idx=cur.index('0')
                for pos in swap[idx]:
                    cur_L=list(cur)
                    cur_L[pos],cur_L[idx]=cur_L[idx],cur_L[pos]
                    nx=''.join(cur_L)
                    if nx not in visited:
                        visited.add(nx)
                        nx_list.append(nx)
            cur_list=nx_list
            step+=1
        return -1
        
board=[[1,2,3],[4,0,5]]# return 1 
board = [[1,2,3],[5,4,0]] # return -1     
board = [[4,1,2],[5,0,3]]# return 5        
                               
if __name__ == "__main__":
    print(Solution().slidingPuzzle( board))          
        
                        
#943. Range Sum Query - Immutable            
class NumArray(object):

    def __init__(self, nums):
        """
        :type nums: List[int]
        """
        self.sums=[0 for _ in range(len(nums)+1)]
        for i in range(1,len(nums)+1):
            self.sums[i]=self.sums[i-1]+nums[i-1]
        #print(self.sums)
            
        

    def sumRange(self, i, j):
        """
        :type i: int
        :type j: int
        :rtype: int
        """
        return self.sums[j+1]-self.sums[i]
        
nums = [-2, 0, 3, -5, 2, -1]

# Your NumArray object will be instantiated and called as such:
# obj = NumArray(nums)
# param_1 = obj.sumRange(i,j)   
obj.sumRange(0,2)       
obj.sumRange(2, 5)     
obj.sumRange(0, 5)    
        
       
#944. Maximum Submatrix
class Solution:
    """
    @param matrix: the given matrix
    @return: the largest possible sum
    """
    def maxSubmatrix(self, matrix):
        # write your code here   
        m=len(matrix)
        if m==0:
            return 0
        n=len(matrix[0])
        
        sum1=[[0 for _ in range(n+1)] for _ in range(m+1)]
        
        for i in range(1,m+1):
            for j in range(1,n+1):
                sum1[i][j]=sum1[i-1][j]+matrix[i-1][j-1]
        
        
        maximum=float('-inf')
        for i in range(m):
            for j in range(i+1,m+1):
                cur=0
                for k in range(n+1):
                    cur+=sum1[j][k]-sum1[i][k]
                    maximum=max(maximum,cur)
                    cur=max(0,cur)
        return maximum
                    
                
        
   
matrix = [
[1,3,-1],
[2,3,-2],
[-1,-2,-3]
]  

#[[1,3],
#[2,3]
#]
if __name__ == "__main__":
    print(Solution().maxSubmatrix( matrix)) 

#945. Task Scheduler
class Solution:
    """
    @param tasks: the given char array representing tasks CPU need to do
    @param n: the non-negative cooling interval
    @return: the least number of intervals the CPU will take to finish all the given tasks
    """
    def leastInterval(self, tasks, n):
        # write your code here  
#Imagine task A appeared 4 times, others less than 4. And n=2. 
#You only need to arrange A in the way that doesn't violate the rule first,
#then insert other tasks in any order:
#A - - A - - A - - A
#It's obvious that we need 6 other tasks to fill it. If other tasks are less 6, we need 
#(4 - 1) * (n + 1) + 1 = 10 tasks in total, if other tasks are equal to or more than 6, 
#tasks.length will be our result.
#Now if we have more than one tasks have the same max occurrence, the scheduling will
#look like this:
#A B - A B - A B - A B
#So we only need to modify the formula by replacing 1 with the different amount of tasks 
#that has the max occurrence: (4 - 1) * (n + 1) + taskCountOfMax = 11 
        from collections import Counter
        count=Counter(tasks)
        l=list(count.values())
        l.sort(reverse=True)
 
        i=0
        while i < len(l)-1  and l[i]==l[i+1]:
            i+=1
        return max( len(tasks ) ,  (l[0]-1)*(n+1)+i+1)
tasks = ['A','A','A','B','B','B']
n = 2             
if __name__ == "__main__":
    print(Solution().leastInterval(tasks, n)) 
    
    
#946. 233 Matrix
class Solution:
    """
    @param X: a list of integers
    @param m: an integer
    @return: return an integer
    """
    def calcTheValueOfAnm(self, X, m):
        # write your code here
        n=len(X)
        
        
        A=[[0 for _ in range(m+1)]  for _ in range(n+1)]
        if m>0:
           A[0][1]=233
        for j in range(2,m+1):
            A[0][j]=A[0][j-1]*10+3
        
        for i in range(n):
            A[i+1][0]=X[i]
        
        for j in range(1,m+1):
          for i in range(1,n+1):
              
              A[j][i]=A[j-1][i]+A[j][i-1]% 10000007
        return A[n][m] % 10000007
X=[1]  
m=1  

X=[0,0]
m=2


#（矩阵快速幂）
#https://blog.csdn.net/Fusheng_Yizhao/article/details/79170197
if __name__ == "__main__":
    print(Solution().calcTheValueOfAnm( X, m)) 
    
    
    
    
#947. Matrix Power Series
    
    
    
    
#949. Fibonacci II
class Solution:
    """
    @param n: an integer
    @return: return a string
    """
    def lastFourDigitsOfFn(self, n):
        # write your code here 
        base=[[1,1],[1,0]]
        
        def fast_power(base,n):
            if n==0:
                return [[1,0],[0,1]]
            if n==1:
                return [[1,1],[1,0]]
            
            temp=fast_power(base,n//2)
            temp2=matrix_muti(temp,temp)
            if n%2==0:
                return temp2
            else:
                return matrix_muti(temp2,base)
            
            
        def matrix_muti(a,b):
            row=len(a)
            col=len(a[0])
            res=[[0 for _ in range(col)] for _ in range(row)]
            for i in range(row):
                for j in range(col):
                    for k in range(row):
                        res[i][j]+=a[i][k]*b[k][j]
                        res[i][j]%=10000
            return res
        
        if n==0:
            return '0'
        elif n==1:
            return '0001'
        
        else:
            result=fast_power(base,n)
        
        return '{:04d}'.format( result[0][1])
n=9                        
if __name__ == "__main__":
    print(Solution().lastFourDigitsOfFn( n))        
        
        
        
#954. Insert Delete GetRandom O(1) - Duplicates allowed
class RandomizedCollection(object):

    def __init__(self):
        """
        Initialize your data structure here.
        
        """
        self.map={}
        self.nums=[]
        

    def insert(self, val):
        """
        Inserts a value to the collection. Returns true if the collection did not already contain the specified element.
        :type val: int
        :rtype: bool
        """
        self.nums.append(val)
        if val in self.map:
            self.map[val].append(len(self.nums)-1)
            return False
        else:
            self.map[val]=[len(self.nums)-1]
            return True
        
            
        

    def remove(self, val):
        """
        Removes a value from the collection. Returns true if the collection contained the specified element.
        :type val: int
        :rtype: bool
        """
        if val in self.map:
            pos=self.map[val].pop()
            if not self.map[val]:
                del self.map[val]
            if pos!=len(self.nums)-1:
                self.map[self.nums[-1] ][-1]=pos
                
                self.nums[pos],self.nums[-1]=self.nums[-1],self.nums[pos]
            self.nums.pop()
            return True
        else:
            return False

    def getRandom(self):
        """
        Get a random element from the collection.
        :rtype: int
        """
        import random
        
        return random.choice(self.nums)
        


# Your RandomizedCollection object will be instantiated and called as such:
# obj = RandomizedCollection()
# param_1 = obj.insert(val)
# param_2 = obj.remove(val)
# param_3 = obj.getRandom()   
        
class CircularQueue:
    def __init__(self, n):
        # do intialization if necessary
        
        self.arr=[None for _ in range(n)]
        self.head=0
        self.tail=-1
        self.size=n
    """
    @return:  return true if the array is full
    """
    def isFull(self):
        # write your code here
        return self.head==(self.tail+1)%self.size  and self.arr[self.tail ] is not None

    """
    @return: return true if there is no element in the array
    """
    def isEmpty(self):
        # write your code here
        return not self.arr[self.tail]

    """
    @param element: the element given to be added
    @return: nothing
    """
    def enqueue(self, element):
        # write your code here
        self.tail=(self.tail+1)%self.size
        self.arr[self.tail]=element
        

    """
    @return: pop an element from the queue
    """
    def dequeue(self):
        # write your code here
        ele=self.arr[self.head]
        self.arr[self.head]=None
        self.head=(self.head+1)%self.size
        return ele
        
#960. First Unique Number in a Stream II
from collections import OrderedDict
class DataStream:
    
    def __init__(self):
        # do intialization if necessary
        self.d=OrderedDict()
        
    """
    @param num: next number in stream
    @return: nothing
    """
    def add(self, num):
        # write your code here
        if num in self.d:
            self.d[num]+=1
        else:
            self.d[num]=1

    """
    @return: the first unique number in stream
    """
    def firstUnique(self):
        # write your code here 
        
        for k,v in self.d.items():
            if v==1:
                return k
        
        
        
    
obj=    DataStream()
obj.add(1)
obj.add(2)
obj.firstUnique() #1
obj.add(1)
obj.firstUnique() # 2

#973. 1-bit and 2-bit Characters
class Solution:
    """
    @param bits: a array represented by several bits. 
    @return: whether the last character must be a one-bit character or not
    """
    def isOneBitCharacter(self, bits):
        # Write your code here
        #0,10 , 11
        def decompose(bits):
            n=len(bits)
            if n==1:
                return 
            if n==0:
                return 
            if len(bits)==2:
                if bits[0]==1 and bits[0]==0:
                    self.res=False
                if bits[0]==1 and bits[0]==1:
                    self.res=False
                return 
            
            if bits[0]==0:
                decompose(bits[1:])
            else:
                decompose(bits[2:])
        self.res=True
        if len(bits)==1:
            return True
        decompose(bits)
        return self.res 
bits = [1, 0, 0]
bits = [1, 1, 1, 0]
if __name__ == "__main__":
    print(Solution().isOneBitCharacter( bits))        
                
                
#974. 01 Matrix                    
class Solution:
    """
    @param matrix: a 0-1 matrix
    @return: return a matrix
    """
    def updateMatrix(self, matrix):
        # write your code here        
        from collections import deque
        m=len(matrix)
        n=len(matrix[0])
        
        res=[[0 for _ in range(n)] for _ in range(m)]
        
        for i in range(m):
            for j in range(n):
                if matrix[i][j]==1:
                    visited=set( [( i,j)])
                    q=deque(  [ ( i,j,0)])
                    
                    while q:
                        x,y,step=q.popleft()
                        if matrix[x][y]==0:
                            res[i][j]=step
                            break
                        else:
                            for a, b in (x+1,y),(x-1,y),(x,y+1),(x,y-1):
                                if a>=0 and b>=0 and a<m and b <n  and (a,b) not in visited:
                                    q.append((  a,b,step+1))
                                    visited.add(  (  a,b))
        return res
                                    
 
matrix=[[0,0,0],
[0,1,0],
[1,1,1]
]

#[
#[0,0,0],
#[0,1,0],
#[1,2,1]
#]

if __name__ == "__main__":
    print(Solution().updateMatrix(matrix))        
                


#975. 2 Keys Keyboard
class Solution:
    """
    @param n: The number of 'A'
    @return: the minimum number of steps to get n 'A'
    """
    def minSteps(self, n):
        # Write your code here

#https://leetcode.com/problems/2-keys-keyboard/discuss/105899/Java-DP-Solution
        
        dp=[i for i in range(n+1)]
        
        for i in range(2,n+1):
            for j in range( i-1,1,-1):
                if i%j==0:
                    dp[i]=dp[j]+i//j
                    break
        return dp[n]
n=3
if __name__ == "__main__":
    print(Solution().minSteps( n))        
                

#976. 4Sum II
class Solution:
    """
    @param A: a list
    @param B: a list
    @param C: a list
    @param D: a list
    @return: how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero
    """
    def fourSumCount(self, A, B, C, D):
        # Write your code here
        
        dictAB={}
        dictCD={}
        
        for i in range(len(A)):
            for j in range(len(B)):
                
                if A[i]+B[j] not in dictAB:
                    dictAB[A[i]+B[j]]=1
                else:
                    dictAB[A[i]+B[j]]+=1
        res=0           
        for k in range(len(C)):
            for l in range(len(D)):
             
                if -(C[k]+D[l]) in dictAB:
                    res+=dictAB[-(C[k]+D[l])]
        return res
                
A = [ 1, 2]
B = [-2,-1]
C = [-1, 2]
D = [ 0, 2]
if __name__ == "__main__":
    print(Solution().fourSumCount( A, B, C, D))  
    
    
#977. Base 7    
class Solution:
    """
    @param num: the given number
    @return: The base 7 string representation
    """
    def convertToBase7(self, num):
        # Write your code here
        if num<0:
            symbol=-1
        else:
            symbol=1
        res=[]
        num=abs(num)
        if num<7 :
            return symbol*num
        
        else:
            
            while num>0:
                remainder=num%7
                num=num//7
                res.append(str(remainder))
        
        if symbol==-1:
            res.append('-')
        res=res[::-1]
        return ''.join(res)
num = 100
#return "202"
num = -7#
#return "-10"            
if __name__ == "__main__":
    print(Solution().convertToBase7( num))    
    
    
    
#978. Basic Calculator    
class Solution:
    """
    @param s: the given expression
    @return: the result of expression
    """
    def calculate(self, s):
        # Write your code here
        
        res=0
        sign=1
        number=0
        stack=[]
        
        for i,c in enumerate(s):
            if c.isdigit():
                number=number*10+int(c)
            elif c=='+':
                res+=sign*number
                number=0
                sign=1
            elif c=='-':
                res+=sign*number
                number=0
                sign=-1
            elif c=='(':
                
                stack.append(res)
                stack.append(sign)
                sign=1
                res=0
            elif c==')':
                res+=sign*number
                number=0
                res*=stack.pop()
                res+=stack.pop()
               
                
        if number!=0:
            res+=sign*number
        return res 
s='1+1'
s="(1+(4+5+2)-3)+(6+8)"
s=" 2-1 + 2 "
if __name__ == "__main__":
    print(Solution().calculate( s))    
                    
#979. Additive Number                
class Solution:
    """
    @param num: a string
    @return: Is it a valid additive number
    """
    def isAdditiveNumber(self, num):
        # Write your code here
        
        def decompose(s,first,second):
            if s.startswith(  str(first+ second   )):
                if s==str(first+ second   ):
                    return True
                else:
                    l=len(str(first+second))
                    return decompose(s[l:],second,first+second)
            else:
                return False
            
        n=len(num)   
        if n==3:
            return int(num[0])+int(num[1])==int(num[2])
        for i in range(1,n-2):
            if num[:i].startswith('0') and num[:i]!='0':
                continue
            first=int(num[:i])
            for j in range(i+1,n-1):
                if num[i:j].startswith('0') and num[i:j]!='0':
                   continue
                second=int(num[i:j])
                if num[j:].startswith(str(first+second)):
                    
                    if num[j:]==str(first+second):
                            return True
                    else:
                            l=len(str(first+second))
                            
                            if decompose(num[j+l:],second,first+second):
                                return True
        return False
num="112358"   
num="199100199" 
num="123"                        
if __name__ == "__main__":
    print(Solution().isAdditiveNumber( num))        
           
                
                            
#980. Basic Calculator II                   
class Solution:
    """
    @param s: the given expression
    @return: the result of expression
    """
    def calculate(self, s):
        # Write your code here 
        
        number=0
        stack=[]
        sign='+'
        for i, c in enumerate(s):
            
            if c.isdigit():
                number=number*10+int(c)
            if c!=' ' and not c.isdigit()  or i==len(s)-1:
                if sign=='+':
                    stack.append(number)
                elif sign=='-':
                    stack.append(-number)
                elif sign=='*':
                    last=stack.pop()
                    print( last,number)
                    stack.append(last*number)
                elif sign=='/':
                    last=stack.pop()
                    print( last,number)
                    stack.append(   int(last/number))
                number=0
                sign=c
        print(stack)
        
        return sum(stack)
s="3+2*1" #= 7        
s= " 3/2 "
s= "1*2-3/4+5*6-7*8+9/10"       
if __name__ == "__main__":
    print(Solution().calculate( s))        
           
                                
#981. Basic Calculator IV
            
        
#982. Arithmetic Slices
class Solution:
    """
    @param A: an array
    @return: the number of arithmetic slices in the array A.
    """
    def numberOfArithmeticSlices(self, A):
        # Write your code here

        curr=0
        res=0
        for i in range(2,len(A)):
            if A[i]-A[i-1]==A[i-1]-A[i-2]:
                curr+=1
                res+=curr
            else:
                curr=0
        return res
        
        
        



#983. Baseball Game
class Solution:
    """
    @param ops: the list of operations
    @return:  the sum of the points you could get in all the rounds
    """
    def calPoints(self, ops):
        # Write your code here
        res=0
        stack=[]
        
        for op in ops:
            if op.isdigit() or op.startswith('-'):
                stack.append(op)
                res+=int(op)
            elif op=='C':
                c=stack.pop()
                res-=int(c)
            elif op=='D':
                c=stack[-1]
                score=2*int(c)
                res+=score
                stack.append(score)
            elif op=='+':
                res+=int(stack[-1])+int(stack[-2])
                stack.append(int(stack[-1])+int(stack[-2]))
            print(stack)
        return res
ops=["5","2","C","D","+"]
ops=["5","-2","4","C","D","9","+","+"]               
if __name__ == "__main__":
    print(Solution().calPoints(ops))                            
                
            

#984. Arithmetic Slices II - Subsequence            
class Solution:
    """
    @param A: an array
    @return: the number of arithmetic subsequence slices in the array A
    """
    def numberOfArithmeticSlices(self, A):
        # Write your code here   
        from collections import defaultdict
        total=0
        n=len(A)
        if n<3:
            return 0
        dp=[defaultdict(int) for _ in range(n)]
        
        for i in range(n):
            for j in range(i):
                dp[i][A[i]-A[j]]+=1
                if A[i]-A[j] in dp[j]:
                    dp[i][A[i]-A[j]]+=dp[j][A[i]-A[j]]
                    total+=dp[j][A[i]-A[j]]
        return total
                    
A=[2, 4, 6, 8, 10]
if __name__ == "__main__":
    print(Solution().numberOfArithmeticSlices( A))                            
                
#985. Can I Win                    
class Solution:
    """
    @param maxChoosableInteger: a Integer
    @param desiredTotal: a Integer
    @return: if the first player to move can force a win
    """
    def canIWin(self, maxChoosableInteger, desiredTotal):
        # Write your code here  
        
        if sum( range( 1, maxChoosableInteger+1)) <desiredTotal:
            return False
        
        memo={}
        def dfs( nums, desiredTotal   ):
            
            hashn=str(nums)
            
            if nums[-1]>=desiredTotal:
                return True
                
            if hashn in memo:
                return memo[hashn]
            
            for i in range( len( nums)):
                if not dfs( nums[:i]+nums[i+1:], desiredTotal-nums[i]     ):
                    memo[str(nums)]=True
                    return True
            
            memo[str(nums)]=False
            return False
        
        return dfs( list(  range( 1, maxChoosableInteger+1)  ), desiredTotal   )
maxChoosableInteger=10
desiredTotal = 11    
if __name__ == "__main__":
    print(Solution().canIWin( maxChoosableInteger, desiredTotal))        
        
        
        
#986. Battleships in a Board
class Solution:
    """
    @param board: the given 2D board
    @return: the number of battle ships
    """
    def countBattleships(self, board):
        # Write your code here    
        m=len(board)
        if m==0:
            return 0
        n=len(board[0])
        
        self.visited=set()
        
        def dfs(board,i,j):
            
            
            for x,y in (i+1,j), (i-1,j), (i,j+1), (i,j-1):
                if x>=0 and y>=0 and x<m and y<n and board[x][y]=='X' and ( x,y) not in self.visited:
                    self.visited.add(( x,y))
                    dfs(board,x,y)
        res=0
        for i in range(m):
            for j in range(n):
                if board[i][j]=='X' :
                    if (i,j) in self.visited:
                        continue
                    else:
                        res+=1
                        self.visited.add(( i,j))
                        dfs(board,i,j)
        return res
                     
        
board=["X..X",
 "...X",
 "...X"] 
if __name__ == "__main__":
    print(Solution().countBattleships( board))             
        
        
#987. Binary Number with Alternating Bits
class Solution:
    """
    @param n: a postive Integer
    @return: if two adjacent bits will always have different values
    """
    def hasAlternatingBits(self, n):
        # Write your code here
        
        
        last='X'
        
        while n:
            temp=n%2
            if last=='X':
                last=temp
            else:
                if last==temp:
                    return False
                last=temp
            n=n//2
        return True
n=5
n=7
if __name__ == "__main__":
    print(Solution().hasAlternatingBits( n))             
                        
#988. Arranging Coins
class Solution:
    """
    @param n: a non-negative integer
    @return: the total number of full staircase rows that can be formed
    """
    def arrangeCoins(self, n):
        # Write your code here
        
        if n==1:
            return 1
        if n==2:
            return 1
        if n==3:
            return 2
        if n==4:
            return 2
        if n==5:
            return 2
        if n==6:
            return 3
        
        l=0
        r=n
        
        target=2*n
        
        while l+1<r:
            
            mid=(l+r)//2
            
            if mid*(mid+1)==target:
                return mid
            elif mid*(mid+1)>target:
                r=mid
            else:
                l=mid
       
        if l*(l+1)==target:
            return l
        
        if l*(l+1) <target and (l+2)*(l+1)>target:
            return l
        
        
        if l*(l+1) <target and (l+2)*(l+1)<target  and (l+2)*(l+3)>target:
            return l+1
n=5 
n=8
n=100       
if __name__ == "__main__":
    print(Solution().arrangeCoins( n))             
                                    
            
#989. Array Nesting
class Solution:
    """
    @param nums: an array
    @return: the longest length of set S
    """
    def arrayNesting(self, nums):
        # Write your code here   
        self.visited=set()
        self.res=float('-inf')
        
        
        def dfs(i):
            temp=set()
            temp
            
          
            
            while nums[i] not in temp:
                temp.add(nums[i])
                self.visited.add(i)
                i=nums[i]
                
                #print(temp)
            if len(temp)>self.res:
                self.res=len(temp)
            
        for i,num in enumerate(nums):
            if i in self.visited:
                continue
            self.visited.add(num)
            dfs(i)
        return self.res
    
nums = [5,4,0,3,1,6,2]        

if __name__ == "__main__":
    print(Solution().arrayNesting( nums))   

#990. Beautiful Arrangement
class Solution:
    """
    @param N: The number of integers
    @return: The number of beautiful arrangements you can construct
    """
    def countArrangement(self, N):
        # Write your code here
        
        integers=set(range(1,N+1))
        #print(integers)
      
        self.res=0
        
        def place(integers,cur,res):
            
            if cur==N+1:
                print(integers,cur,res)
                self.res+=1
                return 
                
            for integer in integers:
                if cur % integer==0 or integer % cur==0:
                    
                    place(integers-set([integer]),cur+1,res+[integer])
                     
               
        place(integers,1,[]) 
        return self.res
N=3
N=2
N=4
if __name__ == "__main__":
    print(Solution().countArrangement( N))               

#991. Bulb Switcher
class Solution:
    """
    @param n: a Integer
    @return: how many bulbs are on after n rounds
    """
    def bulbSwitch(self, n):
        # Write your code here
        
        table = [0 for _ in range(n)]
        
        for i in range(n):# 第几轮
            for j in range(n): # 第几个
                if (j+1) % (i+1)==0:
                    table[j]=1-table[j]
            print(table)
        return sum(table)
    
        
    
    
    
        return int(n**0.5)
        
n=3        
if __name__ == "__main__":
    print(Solution().bulbSwitch( n))               
    
#992. Beautiful Arrangement II
class Solution:
    """
    @param n: the number of integers
    @param k: the number of distinct integers
    @return: any of answers meet the requirment
    """
    def constructArray(self, n, k):
        # Write your code here
#    i++ j-- i++ j--  i++ i++ i++ ...
#out: 1   9   2   8    3   4   5   6   7
#dif:   8   7   6   5    1   1   1   1  
        
#https://leetcode.com/problems/beautiful-arrangement-ii/discuss/106948/C++-Java-Clean-Code-4-liner 

        res=[]
        l=1
        r=n
        
        if k%2:
            
          i=0
        else:
            i=1
        
        while len(res)!=n:
          if i<k:
            if i%2==0:
                res.append(l)
                l+=1
            else:
                res.append(r)
                r-=1
            i+=1
          else:
              res.append(l)
              l+=1
        return res
n=9
k=5  

n=5
k=2          
if __name__ == "__main__":
    print(Solution().constructArray( n, k))            




#993. Array Partition I
class Solution:
    """
    @param nums: an array
    @return: the sum of min(ai, bi) for all i from 1 to n
    """
    def arrayPairSum(self, nums):
        # Write your code here
        
        nums.sort()
        
        res=0
        
        for i,num in enumerate(nums):
            if i%2==0:
                res+=num
        return res
        
        
#994. Contiguous Array        
class Solution:
    """
    @param nums: a binary array
    @return: the maximum length of a contiguous subarray
    """
    def findMaxLength(self, nums):
        # Write your code here
        n=len(nums)
        nsum={}
        nsum[0]=-1      
        for i in range(n):
            if nums[i]==0:
                nums[i]=-1
                
        res=0
        s=0
   
        for i in range(n):
            s+=nums[i]
            if s in nsum:
                res=max(res,i-nsum[s])
            else:
                nsum[s]=i
        return res
                
            
nums= [0,1,0,1,1,1,0,0]
nums=[0,1]            
if __name__ == "__main__":
    print(Solution().findMaxLength(nums))            
            

#995. Best Time to Buy and Sell Stock with Cooldown
class Solution:
    """
    @param prices: a list of integers
    @return: return a integer
    """
    def maxProfit(self, prices):
        # write your code here
        
        n=len(prices)
        
        if n==0:
            return 0
        sell=[0]*n
        do_nothing=[0]*n
        
        sell[1]=prices[1]-prices[0]
        
        
        for i in range(2,n):
            #sell on i day
            sell[i]=max(sell[i-1],do_nothing[i-2])+prices[i]-prices[i-1]
            do_nothing[i]=max(do_nothing[i-1],sell[i-1])
        return max(do_nothing[n-1],sell[n-1])
prices = [1, 2, 3, 0, 2] 
prices = [3,3,5,0,0,3,1,4]       
if __name__ == "__main__":
    print(Solution().maxProfit( prices))                 
        
        
#1000. Best Time to Buy and Sell Stock with Transaction Fee
class Solution:
    """
    @param prices: a list of integers
    @param fee: a integer
    @return: return a integer
    """
    def maxProfit(self, prices, fee):
        # write your code here
        n=len(prices)
        
        if n==0:
            return 0
        sell=[0]*n
        own=[0]*n
        own[0]=-prices[0]
        
        for i in range(1,n):
            sell[i]=max(sell[i-1],own[i-1]+prices[i]-fee)
            own[i]=max(own[i-1],sell[i-1]-prices[i])
        return sell[n-1]
        
     
prices = [1, 3, 2, 8, 4, 9]
fee = 2
if __name__ == "__main__":
    print(Solution().maxProfit( prices,fee))    


#1001. Asteroid Collision
class Solution:
    """
    @param asteroids: a list of integers
    @return: return a list of integers
    """
    def asteroidCollision(self, asteroids):
        # write your code here
        
#        def collision(ls):
#            n=len(ls)
#            if n==1 or n==0:
#                return ls
#                
#            for i in range(1,n):
#                if ls[i] * ls[i-1]<0:
#                    if  (ls[i-1]>0 and  ls[i]<0) :
#                    
#                      if abs(ls[i])== abs(ls[i-1]):
#                          return collision(ls[:i-1]+ls[i+1::])
#                      elif abs(ls[i])> abs(ls[i-1]):
#                          return collision(ls[:i-1]+ls[i:])
#                      else :
#                          return collision(ls[:i]+ls[i+1::])
#            return ls
#        return collision(asteroids)
        
        
        ls=asteroids
        if True:
            stack=[asteroids[0]]
            
            for i in range(1,len(asteroids)):
                if (stack[-1]>0 and  ls[i]<0):
                    if abs(stack[-1])> abs(ls[i]):
                        pass
                    elif abs(stack[-1])< abs(ls[i]):
                         while stack and (stack[-1]>0 and  ls[i]<0)  and abs(stack[-1])< abs(ls[i]):
                              stack.pop()
                         if not stack:
                             stack.append(ls[i])
                             
                         elif abs(stack[-1])== abs(ls[i]):
                             stack.pop()
                         elif stack[-1]<0:
                             stack.append(ls[i])
                             
                        
                    else:
                        
                        stack.pop()
                else:
                    stack.append(ls[i])
        return stack
            
                
            
            
            
asteroids = [5, 10, -5]
asteroids = [5, 10, -11,-5]
asteroids = [5, 10, -10,-5]
asteroids =[-2,-1,1,2]
if __name__ == "__main__":
    print(Solution().asteroidCollision(asteroids))    

#1002. Bus Routes
class Solution:
    """
    @param routes:  a list of bus routes
    @param S: start
    @param T: destination
    @return: the least number of buses we must take to reach destination
    """
    def numBusesToDestination(self, routes, S, T):
        # Write your code here
        n=len(routes)
        
        if S==T:
            return 0
        
        from collections import defaultdict,deque
        
        graph=defaultdict(set)
        
        routes=list(map(set,routes))
        
        for i,stopi in enumerate(routes):
            for j in range(i+1,n):
                if any( [r  for r in routes[j] if r in stopi]):
                    graph[i].add(j)
                    graph[j].add(i)
        
        seen=set()
        target=set()
        
        for i in range(n):
            if S in routes[i]:
               seen.add(i)
            if T in routes[i]:
               target.add(i)
        q=deque([(r,1) for r in seen])
        
        while q:
            node,depth=q.popleft()
            
            if node in target:
                return depth
            
            for nei in graph[node]:
                if nei not in seen:
                    seen.add(nei)
                    q.append(( nei,depth+1))
        return -1
            
routes = [[1, 2, 7], [3, 6, 7]]
S = 1
T = 6            
if __name__ == "__main__":
    print(Solution().numBusesToDestination( routes, S, T))                
                
        
 
#1003. Binary Tree Pruning
"""
Definition of TreeNode
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""

class Solution:
    """
    @param root: the root
    @return: the same tree where every subtree (of the given tree) not containing a 1 has been removed
    """
    def pruneTree(self, root):
        # Write your code here
        
        def delete(node):
            if not node:
                return None
            if not node.left and not node.right:
                if node.val==0:
                    return None
                else:
                    return node
            if node.left:
                left=delete(node.left)
                node.left=left
            if node.right:
                right=delete(node.right)
                node.right=right
            return node
        def equal(node1,node2):
            if not node1 and not node2:
                return True
            if not node1 and node2:
                return False
            if not node2 and node1:
                return False
            if node1.val==node2.val:
                return equal(node1.left,node2.left)  and equal(node1.right,node2.right)
            else:
                return False
            
            
        while  not equal(root,delete(root)):
               root=delete(root)
        return root

#1005. Largest Triangle Area
class Solution:
    """
    @param points: List[List[int]]
    @return: return a double
    """
    def largestTriangleArea(self, points):
        # write your code here
        from itertools import combinations
        
        res=float('-inf')
        
        for i,j,k in combinations(points,3):
            res=max(res, abs(i[0]*j[1]+j[0]*k[1]+k[0]*i[1] - i[1]*j[0]-j[1]*k[0] - k[1]*i[0] ))
        return round(res/2,2)
points = [[0,0],[0,1],[1,0],[0,2],[2,0]]
points =[[1,0],[0,0],[0,1]]
if __name__ == "__main__":
    print(Solution().largestTriangleArea(points))                
                

#1006. Subdomain Visit Count
class Solution:
    """
    @param cpdomains: a list cpdomains of count-paired domains
    @return: a list of count-paired domains
    """
    def subdomainVisits(self, cpdomains):
        # Write your code here
        from collections import defaultdict
        d=defaultdict(int)
        for i in range( len(cpdomains)):
            count,domain=cpdomains[i].split()
            #print(count,domain)
            count=int(count)
            d[domain]+=count
            
            domain=domain+'.'
            
            while domain:
            
                 index=domain.index('.')
                 nxt=domain[index+1:-1]
                 if nxt:
                    d[nxt]+=count
                 domain=domain[index+1:]
        res=[]
        
        for k,v in d.items():
            res.append(str(v)+' '+k)
        return res
cpdomains=["9001 discuss.lintcode.com"]        
cpdomains=["900 google.mail.com", "50 yahoo.com", "1 intel.mail.com", "5 wiki.org"]        
        
if __name__ == "__main__":
    print(Solution().subdomainVisits( cpdomains))                
                
        
#1007. Chalkboard XOR Game        
class Solution:
    """
    @param nums: a list of integers
    @return: return a boolean
    """
    def xorGame(self, nums):
        # write your code here  
        
        xor=0
        for i in nums:
            xor^=i
        
        return xor==0 or len(nums)%2==0
        
        
        
#1008. Expressive Words
class Solution:
    """
    @param S: a string
    @param words: a list of strings
    @return: return a integer
    """
    def expressiveWords(self, S, words):
        # write your code here 
        def countbegining(word):
            n=len(word)
            for i in range(1,n):
                if word[i]!=word[i-1]:
                    return i
        
        def gettable(S):
            tableS=[]
            S=S+'#'
            while S!='#':
                count=countbegining(S) 
                tableS.append( (S[0] ,count))
                S=S[count:]
            return tableS
        res=0
        Stable=gettable(S)
        n=len(Stable)
        for word in words:
            wtable=gettable(word)
            temp=True
            if len(wtable)==n:
                
                for (Sl,Sc ) , (wl,wc) in zip(Stable,wtable):
                    if not (Sl==wl and (Sc==wc  or ( wc<=2 and  Sc>=3) or (wc >=3 and  Sc>=wc) )):
                        temp=False
            else:
                continue
            if temp:
                res+=1
        return res
                    
            
S = "heeellooo"
words = ["hello", "hi", "helo"]        
if __name__ == "__main__":
    print(Solution().expressiveWords( S, words))                
                        
        
#1010. Max Increase to Keep City Skyline        
class Solution:
    """
    @param grid: a 2D array
    @return: the maximum total sum that the height of the buildings can be increased
    """
    def maxIncreaseKeepingSkyline(self, grid):
        # Write your code here
        
        rowmax=[]
        colmax=[]
        sumgrid=0
        
        for row in grid:
            rowmax.append(max(row))
            sumgrid+=sum(row)
        for x in  zip(*grid):
            colmax.append(max(x))
        
        m=len(grid)
        if m==0:
            return 0
        n=len(grid[0])
        
        aftersum=0
        for i in range(m):
            for j in range(n):
                grid[i][j]= min(rowmax[i],colmax[j])
                aftersum+=grid[i][j]
        return aftersum-sumgrid    
grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]        
if __name__ == "__main__":
    print(Solution().maxIncreaseKeepingSkyline( grid))                
                        
#1011. Number of Lines To Write String
class Solution:
    """
    @param widths: an array
    @param S: a string
    @return: how many lines have at least one character from S, and what is the width used by the last such line
    """
    def numberOfLines(self, widths, S):
        # Write your code here
        
        ord('f')-ord('a')
        
        line=0
        curlen=0
        
        for s in S:
            curlen+=widths[ord(s)-ord('a')]
            if curlen>100:
                curlen=widths[ord(s)-ord('a')]
                line+=1
            elif curlen==100:
                line+=1
                last=curlen
                curlen=0
        return [line+1,curlen] if curlen>0  else [line,last]
widths = [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]
S = "abcdefghijklmnopqrstuvwxyz"                


widths = [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]
S = "bbbcccdddaaa"
if __name__ == "__main__":
    print(Solution().numberOfLines( widths, S))                
                        

#1013. 独特的摩尔斯编码        
class Solution:
    """
    @param words: the given list of words
    @return: the number of different transformations among all words we have
    """
    def uniqueMorseRepresentations(self, words):
        # Write your code here
        hashset=set()

        dictionary=[".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."]    
        
        for word in words:
            temp=''
            for c in word:
                temp+=dictionary[ord(c)-ord('a')]
            hashset.add(temp)
        return len(hashset)
words = ["gin", "zen", "gig", "msg"]
if __name__ == "__main__":
    print(Solution().uniqueMorseRepresentations( words))                     
        
        
#1014. Bricks Falling When Hit        
class Solution:
    """
    @param grid: a grid
    @param hits: some erasures order
    @return: an array representing the number of bricks that will drop after each erasure in sequence
    """
    def hitBricks(self, grid, hits):
        # Write your code here    
        
        m=len(grid)
        n=len(grid[0])
        
        def dfs(i,j):
            if  not ( i>=0 and j>=0 and i<m and j < n  )  or grid[i][j]!=1:
                return 0
            res=1
            grid[i][j]=2
            
            res+= sum( dfs(x,y) for x ,y in  ((i+1,j),  (i-1,j),(i,j+1),(i,j-1)))   
            
            return res
        def is_connect(i,j):
            if i==0 or any( [x >=0 and y>=0 and x <m and y < n and grid[x][y]==2 for x,y in ((i+1,j),  (i-1,j),(i,j+1),(i,j-1)) ]):
                return True
            return False
        
        for i,j in hits:
            grid[i][j]-=1
        
        for i in range(n):
            dfs(0,i)
        
        res=[0 for _ in range( len(hits))]
        
        for k in range( len(hits)-1,-1,-1):
            
            x,y=hits[k]
            grid[x][y]+=1
            
            if grid[x][y]==1 and is_connect(x,y):
                res[k]=dfs(x,y)-1
        return res
            
        
grid = [[1,0,0,0],
        [1,1,1,0]]
hits = [[1,0]]
#Output: [2]   

grid = [[1,0,0,0],[1,1,0,0]]
hits = [[1,1],[1,0]]     
if __name__ == "__main__":
    print(Solution().hitBricks( grid, hits))                     
                
        
#1015. Find Eventual Safe States
class Solution:
    """
    @param graph: a 2D integers array
    @return: return a list of integers
    """
    def eventualSafeNodes(self, graph):
        # write your code here
        n=len(graph)
        out_degree=[0 for _ in range(n)]
        from collections import defaultdict,deque
        in_node=defaultdict(list)
        
        
        queue=[]
        
        for i in range(n):
            out_degree[i]=len(graph[i])
            if out_degree[i]==0:
                queue.append(i)
            for j in graph[i]:
                in_node[j].append(i)
        for term_node in queue:
            for innode in in_node[term_node]:
                out_degree[innode]-=1
                if out_degree[innode]==0:
                    queue.append(innode)
        return list(sorted(queue))
graph = [[1,2],[2,3],[5],[0],[5],[],[]]
if __name__ == "__main__":
    print(Solution().eventualSafeNodes( graph))                     
                        
#1016. Minimum Swaps To Make Sequences Increasing        
class Solution:
    """
    @param A: an array
    @param B: an array
    @return: the minimum number of swaps to make both sequences strictly increasing
    """
    def minSwap(self, A, B):
        # Write your code here
        n=len(A)
        swap=[n]*n
        not_swap=[n]*n
        if n==1:
            return 0
        swap[0]=1
        not_swap[0]=0
        
        for i in range(1,n):
            if  A[i-1]<A[i]  and B[i-1]<B[i]:
                not_swap[i]=not_swap[i-1]
                swap[i]=swap[i-1]+1
            if  A[i-1]<B[i]  and B[i-1]<A[i]:
                not_swap[i]=min( not_swap[i],swap[i-1])
                swap[i]=min( swap[i],not_swap[i-1]+1)
        return min(swap[-1],    not_swap[-1])
        
A = [1,3,5,4]
B = [1,2,3,7]    
if __name__ == "__main__":
    print(Solution().minSwap( A, B))                  
                
#1017. Similar RGB Color
class Solution:
    """
    @param color: the given color
    @return: a 7 character color that is most similar to the given color
    """
    def similarRGB(self, color):
        # Write your code here 
#很容易发现 shorthand color 就是 RGB 都可以被17整除的颜色。
#
#所以只需要分别对 RGB 部分除以 17 取整，就可以得到对应的值，然后格式化为十六进制即可    
        red=       int(color[1:3],16 )
        green=       int(color[3:5],16 )
        blue=       int(color[5:7],16 )
        
        r=round(red/17)*17
        g=round(green/17)*17
        b=round(blue/17)*17
        
        return '#{:02x}{:02x}{:02x}'.format(r,g,b)
color = "#09f166"
if __name__ == "__main__":
    print(Solution().similarRGB( color))         

        
#1018. Champagne Tower
class Solution:
    """
    @param poured: an integer
    @param query_row: an integer
    @param query_glass: an integer
    @return: return a double
    """
    def champagneTower(self, poured, query_row, query_glass):
        # write your code here
        dp=[[0.00 for _ in range(i)]  for i in range(1,query_row+2)]
        dp[0][0]=poured
        
        for i in range(query_row):
            for j in range(i+1):
                if dp[i][j]>1:
                   dp[i+1][j]+=(dp[i][j]-1)/2.0
                   dp[i+1][j+1]+=(dp[i][j]-1)/2.0
        return round(dp[query_row][query_glass] if dp[query_row][query_glass]<=1 else 1.00,2)


        
#1019. Smallest Rotation with Highest Score        
class Solution:
    """
    @param A: an array
    @return: the smallest index K that corresponds to the highest score we could receive
    """
    def bestRotation(self, A):
        # Write your code here    
#        table={}
#        n=len(A)
#        
#        for i, a in enumerate(A):
#            table[i]=a
#            
#        res=float('-inf')
#        resk=0
#        
#        
#        for i in range(n):
#            temp=0
#            for idx,v in table.items():
#                if v<= (idx-i)%n:
#                    temp+=1
#            if temp>res:
#                res=temp
#                resk=i
#            
#        return resk
#https://leetcode.com/problems/smallest-rotation-with-highest-score/discuss/118725/C++JavaPython-Solution-with-Explanation        
        n=len(A)
        change=[1]*n
        
        for i in range(n):
            change[(i-A[i]+n+1)%n]-=1
        for i in range(1,n):
            change[i]+=change[i-1]
            
        return change.index(max(change))
            
        
        
        
        
A=[2, 3, 1, 4, 0]
A=[1, 3, 0, 2, 4]
if __name__ == "__main__":
    print(Solution().bestRotation( A))             


#1020. All Paths From Source to Target
class Solution:
    """
    @param graph: a 2D array
    @return: all possible paths from node 0 to node N-1
    """
    def allPathsSourceTarget(self, graph):
        # Write your code here
        self.res=[]
        
        def connecting(graph,cur,path,visited):
            if cur==len(graph)-1:
                self.res.append(path[:])
            
            for nx in graph[cur]:
                if nx not in visited:
                    connecting(graph,nx,path+[nx],visited|set([nx]))
        connecting(graph,0,[0],set([0]))
            
        return self.res
graph=[[1,2], [3], [3], []]         
if __name__ == "__main__":
    print(Solution().allPathsSourceTarget( graph))             
        
        
#1021. Number of Subarrays with Bounded Maximum
class Solution:
    """
    @param A: an array
    @param L: an integer
    @param R: an integer
    @return: the number of subarrays such that the value of the maximum array element in that subarray is at least L and at most R
    """
    def numSubarrayBoundedMax(self, A, L, R):
        # Write your code here  
#https://leetcode.com/problems/number-of-subarrays-with-bounded-maximum/discuss/117595/Short-Java-O(n)-Solution
        n=len(A)
        left=0
        count=0
        res=0
        for right in range(n):
            if A[right]>=L and A[right]<=R:
                count=right-left+1
                res+=count
            elif A[right]<L:
                res+=count
            else:
                left=right+1
                count=0
        return res
A = [2, 1, 4, 3]     
L=2
R=3  
A =[2,9,2,5,6]
L=2
R=8 
if __name__ == "__main__":
    print(Solution().numSubarrayBoundedMax( A, L, R))             
        

#1022. Valid Tic-Tac-Toe State
class Solution:
    """
    @param board: the given board
    @return: True if and only if it is possible to reach this board position during the course of a valid tic-tac-toe game
    """
    def validTicTacToe(self, board):
        # Write your code
        
        def isWin(board,c):
            for i in range(3):
                if board[i]==c*3:
                    return True
            
            for i in range(3):
                if board[0][i]==c and board[1][i]==c and board[2][i]==c:
                    
                    return True
            
            if board[0][0] ==c and board[1][1] ==c and board[2][2] ==c:
                return True
            if board[0][2] ==c and board[1][1] ==c and board[2][0] ==c:
                return True
            return False
        
        
        count_x=0
        count_o=0
        
        for i in range(3):
            for j in range(3):
                if board[i][j]=='X':
                    count_x+=1
                if board[i][j]=='O':
                    count_o+=1
                    
        if count_o>count_x or count_x>count_o+1:
                    return False
                
#                if ( isWin(board,'X')  and count_x >= count_o) or ( isWin(board,'O')  and count_x > count_o):
#                    return False
        if  count_x==count_o  and isWin(board,'X')  or isWin(board,'O')  and count_x==count_o+1:
                    return False
        return True
board = ["O  ", "   ", "   "]
board = ["XOX", " X ", "   "]
board = ["XXX", "   ", "OOO"]
board = ["XOX", "O O", "XOX"]            
if __name__ == "__main__":
    print(Solution().validTicTacToe( board))                 
                    
#1023. Preimage Size of Factorial Zeroes Function                
class Solution:
    """
    @param K: an integer
    @return: how many non-negative integers x have the property that f(x) = K
    """
    def preimageSizeFZF(self, K):
        # Write your code here
        def nzero(n):
            f=5
            count=0
            while f<=n:
                count+=n//f
                f*=5
            return count
        
        if K==0:
            return 5
        
        l=0
        r=K*5
        
        while l<r:
            mid=(l+r)//2
            if nzero(mid)<K:
                l=mid+1
            else:
                r=mid
        
        
        if nzero(l)!=K:
            return 0
        else:
            return 5
K = 5            
if __name__ == "__main__":
    print(Solution().preimageSizeFZF( K))                       
                
        
#1024. Number of Matching Subsequences
        
class Solution:
    """
    @param S: a string
    @param words: a dictionary of words
    @return: the number of words[i] that is a subsequence of S
    """
    def numMatchingSubseq(self, S, words):
        # Write your code here  
        from collections import defaultdict
        waiting=defaultdict(list)
        
        for it in map(iter,words):
            waiting[next(it,())].append(it)
        
        for c in S:
            for it in waiting.pop(c,()):
                waiting[next(it,None)].append(it)
        return len(waiting[None])


#1026. Domino and Tromino Tiling
class Solution:
    """
    @param N: a integer
    @return: return a integer
    """
    def numTilings(self, N):
        # write your code here

#https://s3-lc-upload.s3.amazonaws.com/users/yuweiming70/image_1519549786.png
#https://leetcode.com/problems/domino-and-tromino-tiling/discuss/116506/Python-recursive-DP-solution-with-cache-w-Explanation
       
        cacheD={}
        cacheT={}
        
        def tilingD(N):
            if N in cacheD:
                return cacheD[N]
            if N==0:
                return 1
            if N==1:
                return 1
            if N==2:
                return 2
            
            cacheD[N]=tilingD(N-1)+tilingD(N-2)+2*tilingT(N-1)
            return cacheD[N]
        
        def tilingT(N):
            if N in cacheT:
                return cacheT[N]
            if N==0:
                return 1
            if N==1:
                return 0
            if N==2:
                return 1
            
            cacheT[N]=tilingD(N-2)+tilingT(N-1)
            return cacheT[N]
        
        return tilingD(N)

N=3
if __name__ == "__main__":
    print(Solution().numTilings( N))               

#1027. Escape The Ghosts
class Solution:
    """
    @param ghosts: a 2D integer array
    @param target: a integer array
    @return: return boolean
    """
    def escapeGhosts(self, ghosts, target):
        # write your code here
        
        distance=abs(target[0])+abs(target[1])
        
        for r, c in ghosts:
            if abs(r-target[0])+abs(c-target[1])<=distance:
                return False
        return True
        


#1028. Rotated Digits
class Solution:
    """
    @param N: a positive number
    @return: how many numbers X from 1 to N are good
    """
    def rotatedDigits(self, N):
        # write your code here
        
        res=0
        for i in range(2,N+1):
            ns=str(i)
            temp=''
            for c in ns:
               if c =='0'  or c=='1' or c=='8':
                   temp+=c
               elif c=='6':
                   temp+='9'
               elif c=='9':
                   temp+='6'
               elif c=='2':
                   temp+='5'
               elif c=='5':
                   temp+='2'
               else:
                   break
            if temp!=ns and len(temp)==len(ns):
                   print(ns,temp)
                   res+=1
        return res
                   
N=10                   
if __name__ == "__main__":
    print(Solution().rotatedDigits( N))                    
                   
#1029. Cheapest Flights Within K Stops                   
class Solution:
    """
    @param n: a integer
    @param flights: a 2D array
    @param src: a integer
    @param dst: a integer
    @param K: a integer
    @return: return a integer
    """
    def findCheapestPrice(self, n, flights, src, dst, K):
        # write your code here
        
        from collections import defaultdict,deque
        
        graph=defaultdict(dict)
        
        for i,j,v in flights:
            graph[i][j]=v
        
        q=deque([(src,0)])
        res=float('inf')
        table={}
        while  q and K>=-1: 
          temp=deque()
          for _ in range(len(q)):
              cur,price=q.popleft()
              if cur==dst:
                if price <res:
                    res=price
                continue
              if cur not in table:
                  table[cur]=price
              elif table[cur] < price:
                   continue
              for nx in graph[cur]:
                 if nx not in table or table[nx]>price+graph[cur][nx]:
                     temp.append((nx,price+graph[cur][nx]))
          q=temp
          #print(q,res)
          K-=1
        return res if res<float('inf') else -1
n = 3
flights = [[0,1,100],[1,2,100],[0,2,500]]
src = 0
dst = 2
K = 1

n = 3
flights = [[0,1,100],[1,2,100],[0,2,500]]
src = 0
dst = 2
K = 0
if __name__ == "__main__":
    print(Solution().findCheapestPrice( n, flights, src, dst, K)) 



#1029. Cheapest Flights Within K Stops                   
class Solution:
    """
    @param n: a integer
    @param flights: a 2D array
    @param src: a integer
    @param dst: a integer
    @param K: a integer
    @return: return a integer
    """
    def findCheapestPrice(self, n, flights, src, dst, K):
        # write your code here
        
        from collections import defaultdict
        import heapq
        graph=defaultdict(list)
        
        for i,j,v in flights:
            graph[i].append(( v,j ))
        if src not in graph:
            return -1
            
        hq=[]
        
        for cost, stop in graph[src]:
            heapq.heappush(hq,( cost,stop,0      ))
            
            
        while hq:
            culcost,cur,level=heapq.heappop(hq)
            if level>K:
                continue
            if cur==dst:
                return culcost
            
            if cur in graph:
                for cost,nx in graph[cur]:
            
                    heapq.heappush( hq, ( cost+ culcost,nx,level+1        ))
        return -1
n = 3
flights = [[0,1,100],[1,2,100],[0,2,500]]
src = 0
dst = 2
K = 1

n = 3
flights = [[0,1,100],[1,2,100],[0,2,500]]
src = 0
dst = 2
K = 0
if __name__ == "__main__":
    print(Solution().findCheapestPrice( n, flights, src, dst, K)) 

#1030. K-th Smallest Prime Fraction
class Solution:
    """
    @param A: a list of integers
    @param K: a integer
    @return: return two integers
    """
    def kthSmallestPrimeFraction(self, A, K):
        # write your code here
        import bisect
        l=0
        r=1
        N=len(A)
        
        while True:
            
            m=(l+r)/2
            border=[bisect.bisect_left(A,A[i]/m) for i in range(N)]
            cur=sum(N-i for i in border)
            if cur>K:
                r=m
            elif cur<K:
                l=m
            else:
                return max( [(A[i],A[j]) for i, j in enumerate(border) if j<N] ,key=lambda x: x[0]/x[1])
 
A = [1, 2, 3, 5]
K=3
if __name__ == "__main__":
    print(Solution().kthSmallestPrimeFraction( A, K))


#1031. Is Graph Bipartite?
class Solution:
    """
    @param graph: the given undirected graph
    @return:  return true if and only if it is bipartite
    """
    def isBipartite(self, graph):
        # Write your code here
        set1=set()
        set2=set()
        for node , neiList in enumerate(graph):
            if node not in set1 and node not in set2:
                for nei in neiList:
                    if nei in set1:
                        set2.add(node)
                        
                    else:
                        set1.add(node)
                
            if node in set1:
                for  nei in neiList:
                    if nei in set1:
                        return False
                    set2.add(nei)
            if node in set2:
                for  nei in neiList:
                    if nei in set2:
                        return False
                    set1.add(nei)
        return True
graph=[[1,3], [0,2], [1,3], [0,2]]
graph=[[1,2,3], [0,2], [0,1,3], [0,2]]
               
                   
if __name__ == "__main__":
    print(Solution().isBipartite( graph))
        
        

#1032. Letter Case Permutation
class Solution:
    """
    @param S: a string
    @return: return a list of strings
    """
    def letterCasePermutation(self, S):
        # write your code here
        res=[]
        
        def adding(cur,S):
            if not S:
                res.append(cur)
                return 
            
            c=S[0]
            if c.isdigit():
               adding(cur+c,S[1:])
            else:
               adding(cur+c.lower(),S[1:]) 
               adding(cur+c.upper(),S[1:]) 
        adding('',S)
        return res
S = "a1b2"
S = "3z4"
S = "12345"
if __name__ == "__main__":
    print(Solution().letterCasePermutation(S))
        


#1033. Minimum Difference Between BST Nodes
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""

class Solution:
    """
    @param root: the root
    @return: the minimum difference between the values of any two different nodes in the tree
    """
    def minDiffInBST(self, root):
        # Write your code here
        self.pre=None
        self.res=float('inf')
        def inorder(node):
            if not node:
                return 
            
            if node.left:
                inorder(node.left)
            if self.pre and abs(self.pre-node.val) <self.res:
                self.res=abs(self.pre-node.val)
                
            self.pre=node.val
            
            if node.right:
                inorder(node.right)
        
                
        inorder(root)
        return self.res
                
        
        
        
#1034. Transform to Chessboard
class Solution:
    """
    @param board: the given board
    @return: the minimum number of moves to transform the board into a "chessboard"
    """
    def movesToChessboard(self, board):
        # Write your code here
#https://leetcode.com/problems/transform-to-chessboard/discuss/114847/Easy-and-Concise-Solution-with-Explanation-C++JavaPython  
        rowswap=0
        colswap=0
        n=len(board)
        if any(board[0][0]^board[i][0]^board[0][j]^board[i][j]  for i in range(n) for j in range(n)):
            return -1
        if  not n//2<=sum(board[0])<=(n+1)//2:
            return -1
        if not n//2<=sum(board[j][0] for j in range(n))<=(n+1)//2:
            return -1
        
        for i in range(n):
            if board[0][i]==(i%2):
                rowswap+=1
            if board[i][0]==(i%2):
                colswap+=1
        
        
        if n%2:
            if colswap%2:
                colswap=n-colswap
            if rowswap%2:
                rowswap=n-rowswap
        else:
            colswap=min(n-colswap,colswap)
            rowswap=min(n-rowswap,rowswap)
        return  (colswap+rowswap)//2
        
        
#1035. Rabbits in Forest        
class Solution:
    """
    @param answers: some subset of rabbits (possibly all of them) tell 
    @return: the minimum number of rabbits that could be in the forest.
    """
    def numRabbits(self, answers):
        # write your code here   
#来看一个比较tricky的例子，[0, 0, 1, 1, 1]，前两只兔子都说森林里没有兔子和其颜色相同了，
#那么这两只兔子就是森林里独一无二的兔子，且颜色并不相同，所以目前已经确定了两只。
#然后后面三只都说森林里还有一只兔子和其颜色相同，那么这三只兔子就不可能颜色都相同了，
#但我们可以让两只颜色相同，另外一只颜色不同，那么就是说还有一只兔子并没有在数组中，
#所以森林中最少有6只兔子。分析完了这几个例子，我们可以发现，如果某个兔子回答的数字是x，
#那么说明森林里共有x+1个相同颜色的兔子，我们最多允许x+1个兔子同时回答x个，一旦超过了x+1个兔子，
#那么就得再增加了x+1个新兔子了。所以我们可以使用一个HashMap来建立某种颜色兔子的总个数和在数组中还
#允许出现的个数之间的映射，然后我们遍历数组中的每个兔子，如果该兔子回答了x个，若该颜色兔子的总个
#数x+1不在HashMap中，或者映射为0了，我们将这x+1个兔子加入结果res中，然后将其映射值设为x，
#表示在数组中还允许出现x个也回答x的兔子；否则的话，将映射值自减1即可，参见代码如下： 
        from collections import defaultdict
        dd =defaultdict(int)
        
        res=0
        
        for num in answers:
            if num+1 not in dd or dd[num+1]==0:
                dd[num+1]=num
                res+=num+1
            else:
                dd[num+1]-=1
        return res
                
        
        
#1036. Reaching Points
class Solution:
    """
    @param sx: x for starting point
    @param sy: y for starting point
    @param tx: x for target point 
    @param ty: y for target point
    @return: if a sequence of moves exists to transform the point (sx, sy) to (tx, ty)
    """
    def reachingPoints(self, sx, sy, tx, ty):
        # write your code here
        if sx==tx and sy==ty:
            return True
        if sx>=tx or sy>=ty:
            return False
        def move(i,j):
            
            if i==tx and j==ty:
                
                return True
            if (i == tx and  j < ty ) :
                if move(i,i+j):
                    return True
            elif (i < tx and  j == ty ):
                if move(i+j,j):
                    return True
            elif (i < tx and  j < ty ):
                if move(i,i+j) or  move(i+j,j):
                    return True
            return False
        
        return move(sx,sy)
sx = 1
sy = 1
tx = 3
ty = 5  
 
sx = 1
sy = 1
tx = 2
ty = 2 

sx = 1
sy = 1
tx = 1
ty = 1        
if __name__ == "__main__":
    print(Solution().reachingPoints(sx, sy, tx, ty))
        

#1036. Reaching Points
class Solution:
    """
    @param sx: x for starting point
    @param sy: y for starting point
    @param tx: x for target point 
    @param ty: y for target point
    @return: if a sequence of moves exists to transform the point (sx, sy) to (tx, ty)
    """
    def reachingPoints(self, sx, sy, tx, ty):
        # write your code here
        if sx==tx and sy==ty:
            return True
        if sx>=tx or sy>=ty:
            return False
        
        while sx<tx  and sy<ty:
            tx,ty=tx%ty,ty%tx
           
        if sx==tx and (ty-sy)%sx==0:
            return True
        elif sy==ty and (tx-sx)%sy==0:
            return True
        else:
            return False
    
sx = 1
sy = 1
tx = 3
ty = 5  
 
sx = 1
sy = 1
tx = 2
ty = 2 

sx = 1
sy = 1
tx = 1
ty = 1        
if __name__ == "__main__":
    print(Solution().reachingPoints(sx, sy, tx, ty))
        

#1037. Global and Local Inversions
class Solution:
    """
    @param A: an array
    @return: is the number of global inversions is equal to the number of local inversions
    """
    def isIdealPermutation(self, A):
        # Write your code here
        n=len(A)
        
        if n==1:
            return True
        if n==2:
            return True
        
        leftmost=float('-inf')
        
        for i in range(n-2):
            leftmost=max(leftmost,A[i])
            if leftmost>A[i+2]:
                return False
        return True
        

#1038. Jewels And Stones
class Solution:
    """
    @param J: the types of stones that are jewels
    @param S: representing the stones you have
    @return: how many of the stones you have are also jewels
    """
    def numJewelsInStones(self, J, S):
        # Write your code here
        
        return sum(1  for s in S if s in J)
J = "aA"
S = "aAAbbbb"
if __name__ == "__main__":
    print(Solution().numJewelsInStones(J, S))
    
    
    
#1039. Max Chunks To Make Sorted
class Solution:
    """
    @param arr: a permutation of N
    @return: the most number of chunks
    """
    def maxChunksToSorted(self, arr):
        # write your code here
        temp=sorted(arr)
        d={}
        
        for i ,x in enumerate(temp):
            if i==0:
                d[x]=i
            elif temp[i]==temp[i-1]:
                d[x]=d[temp[i-1]]
            else:
                d[x]=i
        
        arr=[d[x]+1  for x in arr]
        res=0
        leftmax=arr[0]
        
        
        
        for i,x in enumerate(arr):
            leftmax=max(leftmax,x)
            if leftmax<=i+1:
                res+=1
        return res




arr = [4,3,2,1,0]
arr = [1,0,2,3,4]

if __name__ == "__main__":
    print(Solution().maxChunksToSorted(arr))
    

#1040. Max Chunks To Make Sorted II
class Solution:
    """
    @param arr: an array of integers
    @return: number of chunks
    """
    def maxChunksToSorted(self, arr):
        # Write your code here
        
        temp=sorted(arr)
        d={}
        
        for i ,x in enumerate(temp):
            if i==0:
                d[x]=i
            elif temp[i]==temp[i-1]:
                d[x]=d[temp[i-1]]
            else:
                d[x]=i
        
        arr=[d[x]+1  for x in arr]
        res=0
        leftmax=arr[0]
        
        
        
        for i,x in enumerate(arr):
            leftmax=max(leftmax,x)
            if leftmax<=i+1:
                res+=1
        return res
arr=[5,4,3,2,1]   

arr = [2,1,3,4,4]

arr =[27060055,4149524,8328754,79457994,30081343,11566671,30491837,71497332,16256213,93710529,93175212,3693641,44884302,48127487,161953,92240077,28000502,31990617,76344525,76896676,49059253,28358998,98536606,60361334,94956361,55843085,25273835,26664886,58306390,96119848,88024294,96932082,74856864,13303607,54392395,28161577,5435331,37308156,37841081,30070833,71605463,29887588,65756334,33143104,59246664,38742699,90550314,91628578,51532923,8980040,4022527,63178924,40854697,75390619,96878630,46200002,86125370,18706146,49430368,63088205,49029921,52728510,36694190,73193003,81749342,22331904]     

if __name__ == "__main__":
    print(Solution().maxChunksToSorted( arr))   

#1042. Toeplitz Matrix
class Solution:
    """
    @param matrix: the given matrix
    @return: True if and only if the matrix is Toeplitz
    """
    def isToeplitzMatrix(self, matrix):
        # Write your code here
        
        m=len(matrix)
        n=len(matrix[0])
        def isTrue(i,j):
            
            if i+1 > m-1 or j+1 >n-1:
                return True
            elif matrix[i][j] !=  matrix[i+1][j+1] :
                return False
            else:
                
               return isTrue(i+1,j+1)
           
        for i in range(m):
            if not isTrue(i,0):
                return False
        for j in range(m):
            if not isTrue(0,j):
                return False
        return True
        
matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]]
matrix = [[1,2],[2,2]]
    
if __name__ == "__main__":
    print(Solution().isToeplitzMatrix( matrix))       
    
    
    
    
            
#1043. Couples Holding Hands       
class Solution:
    """
    @param row: the couples' initial seating
    @return: the minimum number of swaps
    """
    def minSwapsCouples(self, row):
        # Write your code here
        
        swap=0
        d={ x:i for i,x in enumerate(row) }
        
        for i,x in enumerate(row):
            partner=x^1
            
            j=d[partner]
            
            if abs(i-j)>1:
                
                row[i+1],row[j]=row[j],row[i+1]
                d[row[i+1]]=i+1
                d[row[j]]=j
                swap+=1
        return swap
row = [0, 2, 1, 3]    
if __name__ == "__main__":
    print(Solution().minSwapsCouples( row))
                    

        
        
        
#1044. Largest Plus Sign
class Solution:
    """
    @param N: size of 2D grid
    @param mines: in the given list
    @return: the order of the plus sign
    """
    def orderOfLargestPlusSign(self, N, mines):
        # Write your code here
        banned=set((x,y) for x, y in mines)    
        
        dp=[[0 for _ in range(N)]  for _ in range(N)]
        for r in range(N):
            count=0
            for c in range(N):
                count=0 if (r,c) in banned else count+1
                
                dp[r][c]=count
            count=0
            for c in range(N-1,-1,-1):
                count=0 if (r,c) in banned else count+1
                if count<dp[r][c]:
                    dp[r][c]=count
        
        ans=0
        for c in range(N):
            count=0
            
            for r in range(N):
                count=0 if (r,c) in banned else count+1
                if count<dp[r][c]:
                    dp[r][c]=count
            count=0
            
            for r in range(N-1,-1,-1):
                count=0 if (r,c) in banned else count+1
                if count<dp[r][c]:
                    dp[r][c]=count
                if ans<dp[r][c]:
                    ans=dp[r][c]
        return ans
                    
  
        
N = 5
mines = [[4, 2]]     

if __name__ == "__main__":
    print(Solution().orderOfLargestPlusSign( N, mines))   
        
        
#1045. Partition Labels
class Solution:
    """
    @param S: a string
    @return: a list of integers representing the size of these parts
    """
    def partitionLabels(self, S):
        # Write your code here
        res=[]
        
        for i in range(len(S)):
           if not  any(True for x in set(S[:i])  if x in set(S[i:]) ):
               res.append(i)
        res.append(len(S))
        return [res[i]-res[i-1]  for i in range(1,len(res))]
S = "ababcbacadefegdehijhklij"               
if __name__ == "__main__":
    print(Solution().partitionLabels( S))   
    
class Solution:
    """
    @param S: a string
    @return: a list of integers representing the size of these parts
    """
    def partitionLabels(self, S):
        # Write your code here
        location={c:i for i,c in enumerate(S)}
        left=0
        right=0
        res=[]
        for i in range(len(S)):
            
            right=max(right, location[S[i]])
            if i==right:
                res.append(right-left+1)
                left=i+1
        return res
        
S = "ababcbacadefegdehijhklij"               
if __name__ == "__main__":
    print(Solution().partitionLabels( S))   
                
        
#1046. Prime Number of Set Bits in Binary Representation        
class Solution:
    """
    @param L: an integer
    @param R: an integer
    @return: the count of numbers in the range [L, R] having a prime number of set bits in their binary representation
    """
    def countPrimeSetBits(self, L, R):
        # Write your code here
        
        def isPrime(y):
            if y==1:
                return False
            if y==2 or y==3 or y==5 or y==7:
                return True
            
            if y==4 or y==6 or y==8 or y==9:
                return False
            
            if y%2==0:
                return False
            
            for i in range(2,y//2):
                if y%i==0:
                    return False
            return True
        
        res=0
        for x in range(L,R+1):
          n=bin(x).count('1') 
          if isPrime(n):
              res+=1
        return res
L = 6
R = 10    
L = 10
R = 15          
if __name__ == "__main__":
    print(Solution().countPrimeSetBits( L, R))           


        
            
#1047. Special Binary String        
class Solution:
    """
    @param S: a string
    @return: return a string
    """
    def makeLargestSpecial(self, S):
        # write your code here
#https://leetcode.com/problems/special-binary-string/discuss/113211/Easy-and-Concise-Solution-with-Explanation-C++JavaPython
        res=[]
        i=0
        count=0        
        for j , v in enumerate(S):
            if v=='1':
                count+=1
            else:
                count-=1
            if count==0:
                
               res.append('1'+ self.makeLargestSpecial( S[i+1:j])+'0'     )
               i=j+1
        return ''.join(sorted(res)[::-1])
S = "11011000"            
if __name__ == "__main__":
    print(Solution().makeLargestSpecial( S))                   

#1048. Set Intersection Size At Least Two
class Solution:
    """
    @param intervals: List[List[int]]
    @return: return an integer
    """
    def intersectionSizeTwo(self, intervals):
        # write your code here
        intervals.sort(key= lambda x : ( x[1],-x[0]))
        res=0
        
        left=intervals[0][1]-1
        right=intervals[0][1]
        res+=2
        for i in range(1,len(intervals)):
            cur=intervals[i]
            
            if cur[0]>left and cur[0]<=right:
                res+=1
                left=right
                right=cur[1]
            elif cur[0]>right:
                left=cur[1]-1
                right=cur[1]
                res+=2
        return res
        
        
#1049. Pyramid Transition Matrix
class Solution:
    """
    @param bottom: a string
    @param allowed: a list of strings
    @return: return a boolean
    """
    def pyramidTransition(self, bottom, allowed):
        # write your code here  
        
        from collections import defaultdict
        from itertools import product
        
        f=defaultdict( lambda: defaultdict(list))
        
        for a,b ,c in allowed:
            f[a][b].append(c)
            
        
        def build(bottom):
            if len(bottom)==1:
                return True
            
            for i in product(  *(f[a][b]  for a,b in  zip(bottom[:-1],bottom[1:] )      )):
                if build(i):
                    return True
            return False
        return build(bottom)
    A
   / \
  D   E
 / \ / \
X   Y   Z
bottom = "XYZ"
allowed = ["XYD", "YZE", "DEA", "FFF"]

bottom = "XXYX"
allowed = ["XXX", "XXY", "XYX", "XYY", "YXZ"]

if __name__ == "__main__":
    print(Solution().pyramidTransition( bottom, allowed)) 


#1051. Contain Virus
class Solution:
    """
    @param grid: the given 2-D world
    @return: the number of walls
    """
    def containVirus(self, grid):
        # Write your code here
        R=len(grid)
        C=len(grid[0])
        def neighbor(i,j):
            
            for x ,y in ((i+1,j),(i-1,j),(i,j+1),(i,j-1)):
                if x>=0 and x<R and y>=0 and y<C:
                    yield (x,y)
        
        
        
        def dfs(i,j):
            if (i,j) not in seen:
                seen.add(( i,j))
                region[-1].add((i,j))
                for nr,nc in neighbor(i,j) :
                   if grid[nr][nc]==1:
                      dfs(nr,nc)
                   elif grid[nr][nc]==0:
                      frontiers[-1].add((nr,nc))
                      perimeter[-1]+=1
        ans=0
        
        while True:
            region=[]
            frontiers=[]
            seen=set()
            
            perimeter=[]
            
            for i,row in enumerate(grid):
                for j,c in enumerate(row):
                    if grid[i][j]==1  and ( i,j) not in seen:
                        region.append(set())
                        frontiers.append(set())
                        perimeter.append(0)
                        dfs(i,j)
            
            if not region:
                break
            
            triage_index=frontiers.index(  max(frontiers,key=len  ))
            ans+=perimeter[triage_index]
           # print('region',region)
            #print('frontiers',frontiers)
            #print('perimeter',perimeter)
            
            
            
            
            for i , reg in enumerate(region):
                if i==triage_index:
                    for r,c in reg:
                        grid[r][c]=-1
                else:
                    for r,c in reg:
                        for nr,nc in neighbor(r,c):
                            #print('***')
                            if grid[nr][nc]==0:
                                grid[nr][nc]=1
            #print('grid',grid)
        return ans
grid = [[0,1,0,0,0,0,0,1],
 [0,1,0,0,0,0,0,1],
 [0,0,0,0,0,0,0,1],
 [0,0,0,0,0,0,0,0]]   

grid = [[1,1,1],
 [1,0,1],
 [1,1,1]]
grid = [[1,1,1,0,0,0,0,0,0],
 [1,0,1,0,1,1,1,1,1],
 [1,1,1,0,0,0,0,0,0]]                             
if __name__ == "__main__":
    print(Solution().containVirus( grid)) 
                        
                        
#1052. Shortest Completing Word
class Solution:
    """
    @param licensePlate: a string
    @param words: List[str]
    @return: return a string
    """
    def shortestCompletingWord(self, licensePlate, words):
        # write your code here 
        licensePlate=licensePlate.lower()
        words.sort(key=len)
        
        from collections import Counter
        
        LP_count=Counter(licensePlate)
        print(LP_count)
        for word in words:
            WD_count=Counter(word)
            isbreak=False
            for k,v in   LP_count.items():
                if k.isalpha()   :
                    if not (k in WD_count and WD_count[k]>=v):
                        isbreak=True
                        break
                else:
                    continue
            if isbreak:
                continue
            
                        
            return word
            
            
                    
licensePlate = "1s3 PSt"
words = ["step", "steps", "stripe", "stepple"]            
            
                
licensePlate = "1s3 456"
words = ["looks", "pest", "stew", "show"]        
if __name__ == "__main__":
    print(Solution().shortestCompletingWord(licensePlate, words)) 
                                
#1054. Min Cost Climbing Stairs
class Solution:
    """
    @param cost: an array
    @return: minimum cost to reach the top of the floor
    """
    def minCostClimbingStairs(self, cost):
        # Write your code here        
        #dp[i] to get i min cost
        n=len(cost)
        dp=[float('inf') for _ in range(n+1)]
        dp[0]=0
        dp[1]=0
        
        if n==0:
            return 0
        if n==1:
            return 1
        if n==2:
            return min(cost[0],cost[1])
        
        dp[0]=0
        dp[1]=0
       
        
        for i in range(2,n+1):
            dp[i]= min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2])
        #print(dp)
        return dp[-1]
cost = [10, 15, 20]        
        
        
cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]        
        
if __name__ == "__main__":
    print(Solution().minCostClimbingStairs(cost))         
        
        
        

#1056. Find Smallest Letter Greater Than Target        
class Solution:
    """
    @param letters: a list of sorted characters
    @param target: a target letter
    @return: the smallest element in the list that is larger than the given target
    """
    def nextGreatestLetter(self, letters, target):
        # Write your code here      
        for letter in letters:
            if letter > target:
                return letter
        
        
        
        
        
#1057. Network Delay Time
class Solution:
    """
    @param times: a 2D array
    @param N: an integer
    @param K: an integer
    @return: how long will it take for all nodes to receive the signal
    """
    def networkDelayTime(self, times, N, K):
        # Write your code here   
        from collections import defaultdict,deque
        import heapq
        graph=defaultdict(dict)
        
        for start,target,time in times:
            graph[start][target]=time
        
        q=[]
        heapq.heappush( q,(   0, K))
        seen=set()
        res=0
        while q and len(seen)!=N:
            curtime,cur=heapq.heappop(q)
            seen.add(cur)
            res=curtime
            
            for nx,time in graph[cur].items():
                if nx not in seen:
                    heapq.heappush(q,( curtime+ time,nx    ))
        return res if len(seen)==N else-1
        
       
      
            
times=[[2,1,1],[2,3,1],[3,4,1]]
N=4
K=2  

times=[[1,2,1],[2,3,7],[1,3,4],[2,1,2]]      
N=3
K=1

times=[[1,2,1],[2,3,7],[1,3,4],[2,1,2]]
N=3
K=2
if __name__ == "__main__":
    print(Solution().networkDelayTime( times, N, K))         
        
                
        
#1058. Cherry Pickup        
class Solution:
    """
    @param grid: a grid
    @return: the maximum number of cherries possible
    """
    def cherryPickup(self, grid):
        # Write your code here
        dp={}
        
        n=len(grid)
        
        def twoWalker(i1,j1,i2,j2,dp,grid ):
            if (i1,j1,i2,j2) in dp:
                return dp[i1,j1,i2,j2]
            if i1==n-1 and j1==n-1 and i2==n-1 and j2==n-1:
                return grid[-1][-1]
            if i1>=n or j1>=n or i2>=n or j2>=n :
                return float('-inf')
            if grid[i1][j1]==-1 or grid[i2][j2]==-1:
                return float('-inf')
            ans=0
            best=max( twoWalker(i1+1,j1,i2+1,j2,dp,grid ) ,twoWalker(i1,j1+1,i2,j2+1,dp,grid ),twoWalker(i1,j1+1,i2+1,j2,dp,grid ),twoWalker(i1+1,j1,i2,j2+1,dp,grid )    )
            ans+=best
            ans+=grid[i1][j1] if (i1,j1)==(i2,j2)  else grid[i1][j1]+grid[i2][j2]
            dp[i1,j1,i2,j2]=ans
            return ans
        res=twoWalker(0,0,0,0,dp,grid )
        return res if res>float('-inf') else 0
grid =[[0, 1, -1],
 [1, 0, -1],
 [1, 1,  1]]        
        
if __name__ == "__main__":
    print(Solution().cherryPickup( grid))         
                
        
        
#1059. Delete and Earn
class Solution:
    """
    @param nums: a list of integers
    @return: return a integer
    """
    def deleteAndEarn(self, nums):
        # write your code here
        n=10001
        values=[0 for _ in range(n)]
        
        for num in nums:
            values[num]+=num
        
        take=0
        skip=0
        
        for i in range(1,n):
            takei=skip+values[i]
            skipi=max(take,skip)
            skip=skipi
            take=takei
        return max(skip,take)
                

#1060. Daily Temperatures
class Solution:
    """
    @param temperatures: a list of daily temperatures
    @return: a list of how many days you would have to wait until a warmer temperature
    """
    def dailyTemperatures(self, temperatures):
        # Write your code here
        n=len(temperatures)
        ans=[0  for _ in range(n)]
        stack=[]
        
        for i in range(n-1,-1,-1):
            
            while stack and temperatures[i]>=temperatures[stack[-1]]:
                stack.pop()
            if stack:
                ans[i]=stack[-1]-i
            stack.append(i)
        return ans


#1061. Parse Lisp Expression        
class Solution:
    """
    @param expression:  a string expression representing a Lisp-like expression 
    @return: the integer value of
    """
    def evaluate(self, expression):
        # write your code here  
        tokens=expression.split(' ')
        scope=[{}]
        
        def continue_let(i):
            return 'a'<=tokens[i][0]<='z'  and tokens[i][-1]!=')'
        
                
        def helper(start):
            if start>len(tokens)-1:
                return 0,start
            operator=tokens[start]
            
            if operator[0]=='(':
                operator=operator[1:]
                scope.append(dict( scope[-1]))
            closing_brackets=0
            while operator[len(operator)-1-closing_brackets]==')':
                closing_brackets+=1
            if closing_brackets>0:
               operator=operator[:-closing_brackets]
            
            if operator.isdigit() or ( operator[0]=='-' and operator[1:].isdigit()):
                result= int(operator),start+1
            elif operator=='add':
                    left,nexti=helper(start+1)
                    right,nexti=helper(nexti)
                    result=(left+right,nexti)
            
            elif operator=='mult':
                    left,nexti=helper(start+1)
                    right,nexti=helper(nexti)
                    result=(left*right,nexti)
            
            
            elif operator=='let':   
                nexti=start+1
                while continue_let(nexti):
                    variable=tokens[nexti]
                    expression,nexti=helper(nexti+1)
                    scope[-1][variable]=expression
                result= helper(nexti)
            else:
                result=(scope[-1][operator],start+1)
            
            
            while closing_brackets>0:
                closing_brackets-=1
                scope.pop()
            return result
        return helper(0)[0]
expression='(add 1 2)'  
expression='(mult 3 (add 2 3))' 
expression='(let x 2 (mult x 5))'  
expression='(let x 2 (mult x (let x 3 y 4 (add x y))))'        
expression='(let x 3 x 2 x)'     
expression='(let x 1 y 2 x (add x y) (add x y))'
expression='(let x 2 (add (let x 3 (let x 4 x)) x))'
expression='(let a1 3 b2 (add a1 1) b2)'
if __name__ == "__main__":
    print(Solution().evaluate( expression))         
                                    
                
#1062. Flood Fill
class Solution:
    """
    @param image: a 2-D array
    @param sr: an integer
    @param sc: an integer
    @param newColor: an integer
    @return: the modified image
    """
    def floodFill(self, image, sr, sc, newColor):
        # Write your code here
        m=len(image)
        n=len(image[0])
        color=image[sr][sc]
        def dfs(i,j,color,newColor):
            #print(image)
            image[i][j]=newColor
            #print(image)
            for x,y in  ((i-1, j),(i+1, j),(i, j+1),(i,j-1)):
                if x>=0 and y>=0 and x <m and y<n:
                    if image[x][y]==color:
                        
                        dfs(x,y,color,newColor)
        
        
                        
        dfs(sr,sc,color,newColor)  
        return  image              
                    
image = [[1,1,1],[1,1,0],[1,0,1]]                
sr = 1
sc = 1
newColor = 2


image =[[0,0,1,2,0,0,9,5,6,5],[4,5,4,3,1,0,3,9,3,6],[6,2,4,1,2,6,5,0,5,7],[0,6,7,8,9,1,6,4,1,9],[2,2,8,6,0,7,6,4,8,2],[0,0,2,0,6,4,0,6,6,8],[4,8,7,4,9,9,7,1,2,7],[9,8,7,0,0,5,5,8,6,8],[3,0,2,1,2,8,5,2,3,9],[0,4,9,2,2,6,1,6,2,5]]                
       
sr = 9
sc = 0
newColor =9
if __name__ == "__main__":
    print(Solution().floodFill( image, sr, sc, newColor)) 
    
#1063. My Calendar III
import bisect
class MyCalendarThree(object):

    def __init__(self):
        self.time=[]
        

    def book(self, start, end):
        """
        :type start: int
        :type end: int
        :rtype: int
        """
        bisect.insort(self.time,(  start,1))
        bisect.insort(self.time,(  end,-1))
        
        
        ans=0
        maxv=0
        for _,x in self.time:
            ans+=x
            maxv=max(ans,maxv)
        return maxv
            
        


# Your MyCalendarThree object will be instantiated and called as such:
# obj = MyCalendarThree()
# param_1 = obj.book(start,end)    
    
#1064. My Calendar II
class MyCalendarTwo(object):

    def __init__(self):
        self.calendar=[]
        self.overlap=[]
        

    def book(self, start, end):
        """
        :type start: int
        :type end: int
        :rtype: bool
        """
        for i ,j in self.overlap:
            if start<j and end>i:
                return False
        for i ,j in self.calendar:
            if start<j and end>i:
                self.overlap.append( ( max( i,start   ),min(j,end) )   )
        self.calendar.append( (start, end  )  )
        return True
            
        


# Your MyCalendarTwo object will be instantiated and called as such:
# obj = MyCalendarTwo()
# param_1 = obj.book(start,end)    
            
            
#1065. My Calendar I            
class MyCalendar(object):

    def __init__(self):
        self.table=[]
        

    def book(self, start, end):
        """
        :type start: int
        :type end: int
        :rtype: bool
        """
        
        import bisect
        if not self.table:
            self.table.append( (start, end))
            return True
        elif len(self.table)==1:
            if start>=self.table[0][1]  :
                self.table.append((start,end))
                return True
                
            elif end<self.table[0][0]:
                self.table= [(start,end)]+self.table  
                return True
            else:
                return False
        else:
            idx=bisect.bisect_left(self.table,(start,end))
            if start>=self.table[-1][-1]:
                self.table.append((start,end))
                return True
            if idx==0:
                if end<=self.table[idx][0]:
                    self.table= [(start,end)]+self.table
                    return True
                return False
            elif idx==len(self.table):
                 return False
            else:
                if end<=self.table[idx][0] and start>=self.table[idx-1][1] :
                    self.table= self.table[:idx]  + [(start,end)]+self.table[idx:]
                    
                    return True
                else:
                    return False
                    
            
            
        


# Your MyCalendar object will be instantiated and called as such:
# obj = MyCalendar()
# param_1 = obj.book(start,end) 

obj.book(23,32)
obj.book(42,50)
obj.book(6,14)
obj.book(0,7)
obj.book(21,30)
obj.book(26,31)
obj.book(46,50)
obj.book(28,36)
obj.book(0,6)
obj.book(27,36)
obj.book(6,11)
obj.book(20,25)
obj.book(32,37)
obj.book(14,20)
obj.book(7,16)
obj.book(13,22)
obj.book(39,47)
obj.book(37,46)
obj.book(42,50)
obj.book(9,17)
obj.book(49,50)
obj.book(31,37)
obj.book(43,49)
obj.book(2,10)
obj.book(3,12)
obj.book(8,14)
obj.book(14,21)
obj.book(42,47)
obj.book(43,49)
obj.book(36,43)
            
#1066. Verify Preorder Serialization of a Binary Tree
class Solution:
    """
    @param preorder: a string
    @return: return a bool
    """
    def isValidSerialization(self, preorder):
        # write your code here
        p=preorder.split(',')
        
        slot=1
        #print(p)
        
        for x in p:
            if slot==0:
                return False
            if x=='#':
                 slot-=1
            else:
                slot+=1
        #print(slot)
        return slot==0
preorder='#'            
if __name__ == "__main__":
    print(Solution().isValidSerialization( preorder))            
            
            
            
#1068. Find Pivot Index
class Solution:
    """
    @param nums: an array
    @return: the "pivot" index of this array
    """
    def pivotIndex(self, nums):
        # Write your code here
        n=len(nums)
        if n==0 or n==1:
            return -1
        if n==2:
            return False
        
        total=sum(nums)
        
        cur=0
               
        for i,x in enumerate(nums):
            if (total-x)/2==cur:
                return i
            cur+=x
            if i==0:
                continue
        return -1
            
nums=[1, 7, 3, 6, 5, 6]     
nums=[-1,-1,0,1,1,0] 
      
if __name__ == "__main__":
    print(Solution().pivotIndex( nums))            
            
            
#1069. Remove Comments
class Solution:
    """
    @param source: List[str]
    @return: return List[str]
    """
    def removeComments(self, source):
        # write your code here

        ans=[]
        in_block=False
        
        for line in source:
            i=0
            if not in_block:
               new_line=[]
            while i<len(line):
                if line[i:i+2]=='/*' and not in_block:
                    in_block=True
                    i+=1
                elif line[i:i+2]=='*/' and  in_block:
                    in_block=False
                    i+=1
                elif line[i:i+2]=='//' and  not in_block:
                    break
                elif not in_block:
                    new_line.append(line[i])
                i+=1
            if not in_block and new_line :
                ans.append(''.join(new_line))
            
        return ans
source = ["/*Test program */", "int main()", "{ ", "  // variable declaration ", "int a, b, c;", "/* This is a test", "   multiline  ", "   comment for ", "   testing */", "a = b + c;", "}"]
source =["a/*comment", "line", "more_comment*/b"]
if __name__ == "__main__":
    print(Solution().removeComments( source))    
                    
                    
               
#1070. Accounts Merge
class Solution:
    """
    @param accounts: List[List[str]]
    @return: return a List[List[str]]
    """
    def accountsMerge(self, accounts):
        # write your code here
#https://leetcode.com/problems/accounts-merge/discuss/175269/My-Python-DFS-and-Union-Find-solutions-beats-98.7-and-100
        n=len(accounts)
        parent=[i for i in range(n)]
        
        def find(i):
            while i!=parent[i]:
                parent[i]=parent[ parent[i]]
                i=parent[i]
            return i

        d= {}
        
        for i,a in enumerate(accounts)  :
            
            for email in a[1:]:
                if email in d:
                    r1,r2=find(i),find(d[email])
                    parent[r2]=r1
                else:
                    d[email]=i
        
        
        from collections import defaultdict
        res0=defaultdict(set)
        print(parent)
        
        for i in range(n):
            res0[find(i)] |= set(accounts[i][1:])
            
        res=[]
        
        for k,v in res0.items():
            res.append([accounts[k][0]]+ sorted(v))
        return res
accounts=[
  ["John", "johnsmith@mail.com", "john00@mail.com"],
  ["John", "johnnybravo@mail.com"],
  ["John", "johnsmith@mail.com", "john_newyork@mail.com"],
  ["Mary", "mary@mail.com"]
]  

accounts=[["David","David0@m.co","David1@m.co"],["David","David3@m.co","David4@m.co"],["David","David4@m.co","David5@m.co"],["David","David2@m.co","David3@m.co"],["David","David1@m.co","David2@m.co"]]          
if __name__ == "__main__":
    print(Solution().accountsMerge( accounts))            
        
            
#1071. Longest Word in Dictionary
class Solution:
    """
    @param words: a list of strings
    @return: the longest word in words that can be built one character at a time by other words in words
    """
    def longestWord(self, words):
        # Write your code here
        
        words=set(words)
        ans=''
        if not words:
            return 0
        
        for word in words:
            if len(word)>len(ans)  or ( len(word)==len(ans)  and word<ans):
                if all(  word[:k]  in words for k in range(1,len(word))):
                    ans=word
        return ans


words = ["w","wo","wor","worl", "world"]
words = ["a", "banana", "app", "appl", "ap", "apply", "apple"]


#1074. Range Module
from bisect import bisect_left,bisect_right
class Solution(object):

    def __init__(self):
        self.intervals=[]
        

    def addRange(self, left, right):
        """
        :type left: int
        :type right: int
        :rtype: void
        """
        intervals=self.intervals
        
        lo=bisect_left(intervals,left)
        hi=bisect_right(intervals,right)
        
        if lo%2==1:
           lo-=1
           left=intervals[lo]
        if hi%2==1:
            right=intervals[hi]
            hi+=1
           
        
        self.intervals=intervals[:lo]+[left,right]+intervals[hi:]
        print(self.intervals)
        
        
        

    def queryRange(self, left, right):
        """
        :type left: int
        :type right: int
        :rtype: bool
        """
        
        idx=bisect_right(self.intervals,left)
        
        return idx%2==1 and idx<len(self.intervals)  and self.intervals[idx-1]<=left <right<=self.intervals[idx]
        
    def removeRange(self, left, right):
        """
        :type left: int
        :type right: int
        :rtype: void
        """
        intervals=self.intervals
        new=[]
        
        lo=bisect_left(intervals,left)
        hi=bisect_right(intervals,right)
        
        if lo%2==1:
           lo-=1
           new.extend([intervals[lo] , left])
          
        if hi%2==1:
            new.extend([right,intervals[hi] ])
            right=intervals[hi]
            hi+=1
           
        
        self.intervals=intervals[:lo]+new+intervals[hi:]
        print(self.intervals)



         
obj=Solution()         
obj.addRange(10,20)
obj.removeRange(14,16)
obj.queryRange(10,14)
obj.queryRange(13,15)
obj.queryRange(16,17)            
            
            
            
            
            
            
        
#1075. Subarray Product Less Than K        
class Solution:
    """
    @param nums: an array
    @param k: an integer
    @return: the number of subarrays where the product of all the elements in the subarray is less than k
    """
    def numSubarrayProductLessThanK(self, nums, k):
        # Write your code here    
        n=len(nums)
        
        if n==0:
            return 0
        if k<=1:
            return 0
        
        ans=0
        left=0
        
        product=1
        
        for i in range(n):
            product*=nums[i]
            
            while product>=k:
                product/=nums[left]
                left+=1
            ans+=i-left+1
        return ans
        
        
        
nums=[10,5,2,6]  
k=100      
if __name__ == "__main__":
    print(Solution().numSubarrayProductLessThanK( nums, k))            
                
        
#1076. Minimum ASCII Delete Sum for Two Strings
class Solution:
    """
    @param s1: a string
    @param s2: a string
    @return: the lowest ASCII sum of deleted characters to make two strings equal
    """
    def minimumDeleteSum(self, s1, s2):
        # Write your code here
        n1=len(s1)
        n2=len(s2)
        
        dp=[[0 for _ in range(n2+1)]  for _ in range(n1+1)  ]
        
        for i in range(1,n1+1):
            dp[i][0]=dp[i-1][0]+ord(s1[i-1])
        for j in range(1,n2+1):
            dp[0][j]=dp[0][j-1]+ord(s2[j-1])
        
        
        for i in range(1,n1+1):
            for j in range(1,n2+1):
                if s1[i-1]==s2[j-1]:
                    dp[i][j]=dp[i-1][j-1]
                else:
                    
                    dp[i][j]=min(dp[i-1][j]+ord(s1[i-1]),dp[i][j-1]+ord(s2[j-1]))
        return dp[n1][n2]
s1 = "sea"
s2 = "eat"   
s1 = "delete"
s2 = "leet"     
if __name__ == "__main__":
    print(Solution().minimumDeleteSum( s1, s2))          
    
    
#1077. Falling Squares
class Solution:
    """
    @param positions: a list of (left, side_length)
    @return: return a list of integer
    """
    def fallingSquares(self, positions):
        # write your code here
        
        h={}
        ans=[]
        maxh=float('-inf')
        
        for position,side in positions:
            left=position
            right=position+side-1
            
            nearby=[h[key]  for key in h if  not (left>key[1]  or right <key[0]) ]
            
            if len(nearby)>0:
                cur=side+max(nearby)
            else:
                cur=side
            h[(left,right)]=cur
            maxh=max(maxh,cur)
            ans.append( maxh)
        return ans
        
positions=[[1, 2], [2, 3], [6, 1]]            
if __name__ == "__main__":
    print(Solution().fallingSquares( positions))          
        
    
#971. Flip Binary Tree To Match Preorder Traversal    
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def flipMatchVoyage(self, root, voyage):
        """
        :type root: TreeNode
        :type voyage: List[int]
        :rtype: List[int]
        """
        res=[]
        self.i=0
        def dfs(node):
            if not node:
                return True
            if node.val!=voyage[self.i]:
                return False
            self.i+=1
            if node.left and node.left.val!=voyage[self.i]:
                res.append(node.val)
                node.left,node.right=node.right,node.left
            return dfs(node.left)  and dfs(node.right)
        return res if dfs(root)  else [-1]
        
        
        
        
        
        
        
        
        
        
root = [1,2]
voyage = [2,1] 

root = [1,2,3]
voyage = [1,3,2]

root = [1,2,3]
voyage = [1,2,3]

       
            
        
        
        
        
        
        
        
        
        
        
        
        
    
    
    
      
        
        
        
        
            
        
        
                    
        
        
        
        
   
        
        

        
        
        
        
        
        
        
            
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    
    
    
    
    
    
    
    
    
    